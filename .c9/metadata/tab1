{"filter":false,"title":"Immediate (Javascript (browser))","tooltip":"Immediate (Javascript (browser))","undoManager":{"mark":6,"position":6,"stack":[[{"start":{"row":7009,"column":9},"end":{"row":7010,"column":0},"action":"insert","lines":["",""],"id":138},{"start":{"row":7010,"column":0},"end":{"row":7011,"column":0},"action":"insert","lines":["",""]}],[{"start":{"row":7011,"column":0},"end":{"row":7011,"column":1},"action":"insert","lines":["v"],"id":139}],[{"start":{"row":7011,"column":1},"end":{"row":7011,"column":2},"action":"insert","lines":["o"],"id":140}],[{"start":{"row":7011,"column":2},"end":{"row":7011,"column":3},"action":"insert","lines":["i"],"id":141}],[{"start":{"row":7011,"column":2},"end":{"row":7011,"column":3},"action":"remove","lines":["i"],"id":142}],[{"start":{"row":7011,"column":1},"end":{"row":7011,"column":2},"action":"remove","lines":["o"],"id":143}],[{"start":{"row":7011,"column":0},"end":{"row":7011,"column":1},"action":"remove","lines":["v"],"id":144}]]},"immediate":{"folds":[],"scrolltop":0,"scrollleft":0,"selection":{"start":{"row":2,"column":0},"end":{"row":2,"column":0},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":0,"type":"jsbrowser","history":["<script>\n    /** ==========================================================\n     * QRTEngine.js v16\n     * ==========================================================\n     * Copyright 2013-2014 Erwin Haasnoot\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     * http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     *\n     *\n     *\n     * ========================================================== */\n    /**\n     * Qualtrics Reaction Time Engine or QRTE is an add-on providing an interface\n     * for easy reaction time experiment creation in the Qualtrics survey research suite (tm).\n     * For instructions on how to use this add-on, see xxxx\n     *\n     * QRTE was developed by Erwin Haasnoot\n     * Email: erwinhaasnoot[at]gmail.com\n     * @class QRTE\n     *\n     */\n     \n    var QRTE = {\n        version: 'v16',\n        columnsField: 'QRTE_columns',\n        blockDataField: 'QRTE_blockData',\n        idField: 'QRTE_idData',\n        exitQuestions: 'QRTE_exitQuestions',\n        inited: false,\n        /**\n         * TDCache contains the Trial-Level Data in an Object. DO NOT directly manipulate this Object. It might cause inconsistencies in the data file and cause unexpected once parsed.\n         * Use QRTE.setTrialData and QRTE.getTrialData instead.\n         *\n         * @property TDCache\n         * @private\n         * @type Object\n         */\n        TDCache: {},\n\n        /**\n         * ColumnCache contains all the mappings from QID to Columns\n         * @property columnCache\n         * @private\n         * @type Object\n         */\n        columnCache: {},\n\n        /**\n         * BDCache contains the BlockLevel Data in an Object. Directly manipulating this Object might cause inconsistencies\n         * @property BDCache\n         * @private\n         * @type Object\n         */\n        BDCache: {},\n\n        /**\n         * SDCache is a cache for speeding up retrieval of Survey level Data,\n         * All Survey data is saved to both Embedded Data and Survey Data\n         * @private\n         * @property SDCache\n         * @type Object\n         */\n        SDCache: {},\n\n        /**\n         * idCache is a cache for quickly retrieving the Qualtrics QID to QRTLib Id mappings.\n         * Saved in the idData embedded data field after every trial.\n         * @private\n         * @property idCache\n         * @type Object\n         */\n        idCache: {},\n\n        /**\n         * questionQueue contains Objects (stimuli) that are waiting to be presented\n         * @private\n         * @property questionQueue\n         * @type Array\n         */\n        questionQueue: [],\n\n        /**\n         * currentPageQuestions contains the Question Objects that are\n         * displayed at any given time.\n         * @private\n         * @property currentPageQuestions\n         * @type Array\n         */\n        currentPageQuestions: [],\n\n        /**\n         * Contains Trial Data Columns that were 'newly' added in this trial run.\n         * @private\n         * @property newlyAddedColumns\n         * @type Array\n         */\n        newlyAddedColumns: [],\n\n        /**\n         * Contains the Post-Initialization Element.\n         * @private\n         * @property postInitElement\n         * @type Object\n         */\n        postInitElement: {},\n\n        /**\n         * Setter function for Trial-Level Data.\n         * @method setTrialData\n         * @param key {String} Key\n         * @param value {Value} Value\n         */\n        setTrialData: function(key, value) {\n            //Store value in trial cache\n            this.TDCache[key] = value;\n            if (this.BDCache.QRTLib_trialColumns[key] === undefined) {\n                //Add column to overall trial data\n                this.BDCache.QRTLib_trialColumns[key] = '';\n                this.newlyAddedColumns.push(key);\n            }\n        },\n\n        /**\n         * Gets the value of Trial-Level Data field 'key\n         * @method getTrialData\n         * @param key {String} Key\n         */\n        getTrialData: function(key) {\n            return this.TDCache[key];\n        },\n\n        /**\n         * Setter function for Block-Level Data.\n         * @method setBlockData\n         * @param key {String} Key\n         * @param value {Value} Value\n         */\n        setBlockData: function(key, value) {\n            this.BDCache[key] = value;\n        },\n\n\n        /**\n         * Gets the value of Block-Level Data field 'key\n         * @method getBlockData\n         * @param key {String} Key\n         */\n        getBlockData: function(key) {\n            return this.BDCache[key];\n        },\n\n\n\n\n        /**\n         * Stringify the Block Data and store it in the Embedded Data Field. This preserves the values stored on Block Level for use in later trials\n         * @method saveBlockData\n         * @param key {String} Key\n         */\n        saveBlockData: function() {\n            //Store blockData in ED so that we can use it next trial\n            QRTEController.storeBlockData(QRTE.BDCache);\n            Qualtrics.SurveyEngine.setEmbeddedData(QRTE.blockDataField, Object.toJSON(QRTE.BDCache));\n        },\n\n\n\n        /**\n         * Setter function for Survey-Level Data (Embedded Data).\n         * @method setSurveyData\n         * @param key {String} Key\n         * @param value {Value} Value\n         */\n        setSurveyData: function(key, value) {\n            this.SDCache[key] = value;\n            Qualtrics.SurveyEngine.setEmbeddedData(key, value);\n        },\n\n\n\n        /**\n         * Gets the value of Survey-Level Data (Embedded Data) 'key'\n         * @method getSurveyData\n         * @param key {String} Key\n         */\n\n        getSurveyData: function(key) {\n            if (this.SDCache[key] !== undefined) {\n                return this.SDCache[key];\n            }\n            //This only works if the Survey Data has been set during the same trial due to a bug in Qualtrics.\n            return Qualtrics.SurveyEngine.getEmbeddedData(key);\n        },\n\n        /**\n         * Sets a configuration for a question\n         * @method setConfig\n         * @param QID {String} The QRTE Question Id of the Question you want the configuration to apply to\n         * @param option {String} The type of configuration you want to set, Allowed options: 'cresp', 'allowable', 'duration', 'endaction', 'delay'. Refer to website for documentation on these configs\n         * @param value {String} The value the configuration needs to be set to. Differs per option.\n         */\n        setConfig: function(QID, option, value) {\n            var setterFunc;\n            if (typeof QID === 'string') {\n                setterFunc = function(QID, option, value) {\n                    this.setTrialData(QID + \"[\" + option + \"]\", value);\n                };\n            } else {\n                setterFunc = function(QID, option, value) {\n                    this.setTrialData(QID.questionId + \"[\" + option + \"]\", value);\n                    QID['_' + option] = value;\n                };\n\n            }\n\n            this._setConfig(QID, option, value, setterFunc);\n        },\n\n\n        /**\n         * Loads the configuration for a question.\n         * @private\n         * @method loadConfig\n         * @param question {Object} Question for which the configuration needs to be loaded.\n         */\n        loadConfig: function(question) {\n            if (this.idCache[question.questionId] !== undefined) {\n                question.QRTLib_configId = this.idCache[question.questionId];\n            } else {\n                question.QRTLib_configId = question.question;\n            }\n            question.duration = this.getDuration(question);\n            question.allowable = this.getAllowable(question);\n            question.cresp = this.getCResp(question);\n            question.offset = this.getOffset(question);\n            question.endAction = this.getEndAction(question);\n        },\n\n        /**\n         * Stores the accuracy of a trial\n         * @private\n         * @method saveAcc\n         * @param question {Object} Question for which accuracy needs to be stored\n         * @param acc {Integer} Accuracy of question\n         */\n\n        saveAcc: function(question, acc) {\n            if (acc === 0 || acc === 1) {\n                this.setTrialData(question.QRTLibId + \"[ACC]\", acc);\n                this.setSurveyData(\"ACC\", acc);\n            }\n        },\n\n\n\n        /**\n         * Check whether the given response was a correct response\n         * @method isCorrectResponse\n         * @param question {Object} Question for which correct response needs to be checked\n         * @param resp {String} Given response\n         */\n        isCorrectResponse: function(question, resp) {\n            return question.cresp.indexOf(resp) >= 0;\n        },\n\n        /**\n         * Check whether the given response was an allowable response\n         * @method isAllowableResponse\n         * @param question {Object} Question for which allowable response needs to be checked\n         * @param resp {String} Given response\n         */\n        isAllowableResponse: function(question, resp) {\n            return question.allowable.indexOf(resp) >= 0;\n        },\n\n\n\n        /**\n         * Check whether the given response was an allowable response\n         * @private\n         * @method keycode2string\n         * @param e {Object} KeyPress event from which to retrieve the response\n         */\n        keycode2string: function(e) {\n            return String.fromCharCode(e.charCode);\n        },\n\n        /** \n         * Wait for images to load before starting trial.\n         * @property waitForImageLoad\n         * @private\n         * @type Boolean\n         */\n\n        waitForImageLoad: true,\n\n        /** \n         * Trial Start waiting list - initialised with waiting for TrialStart\n         * @property loadWaitingList\n         * @private\n         * @type Array\n         */\n\n        loadWaitingList: [false],\n\n        /**\n         * Initializes the Engine, called at the start of the 'Init' question.\n         * @private\n         * @method initLib\n         * @param blockDataString {String} JSON string containing information saved for this block (block-level data)\n         * @param blockId {String} Id of the current block\n         * @param columns {String} JSON string containing information about the columns that have been defined in this block\n         * @param idData {String} JSON string containing information about the mapping of the QID to the name of the question\n         * @param exitQuestions {String} String containing the currently defined QuestionTags of the Exit questions\n         * @param exitItemTag {String} String containing the Tag of this block's Exit question.\n         */\n\n\n        initLib: function(blockDataString, blockId, columns, idData, exitQuestions, exitItemTag) {\n            //var blockDataString = Qualtrics.SurveyEngine.getEmbeddedData(QRTE.blockDataField),\n            //columns = Qualtrics.SurveyEngine.getEmbeddedData(QRTE.columnsField),\n            //idData = Qualtrics.SurveyEngine.getEmbeddedData(QRTE.idField);\n            var glue;\n            QRTE.fixSetEmbeddedDataBug();\n            //Initialise block Data\n            if (blockDataString === undefined || blockDataString === null || blockDataString === '') {\n                blockDataString = '{}';\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.blockDataField, blockDataString);\n            }\n\n            this.BDCache = QRTEController.loadBlockData(blockDataString);\n\n            if (this.BDCache.QRTLib_currentBlock !== blockId) {\n                //If this is a new block, initialise a new block\n                this.BDCache = {\n                    QRTLib_currentBlock: blockId,\n                    QRTLib_blockCounter: 1,\n                    QRTLib_trialColumns: {}\n                };\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.blockDataField, Object.toJSON(this.BDCache));\n                if (exitQuestions === null) {exitQuestions = '';}\n                glue = '';\n                if (exitQuestions !== '') {\n                    glue = ';';\n                }\n                //And update the exit questions\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.exitQuestions, exitQuestions + glue + exitItemTag);\n\n            }\n            QRTE.TDCache = Object.toJSON(QRTE.getBlockData('QRTLib_trialColumns')).evalJSON();\n            if (columns === undefined || columns === null || columns === '') {\n                columns = '{}';\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.columnsField, columns);\n            }\n            QRTE.SDCache[QRTE.columnsField] = columns.evalJSON();\n            if (idData === undefined || idData === null || idData === '') {\n                idData = '{}';\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.idField, idData);\n            }\n            QRTE.idCache = idData.evalJSON();\n        },\n\n        /**\n         * Init initializes the QRTEngine, expects are params object with possible fields defined with parameters.\n         * @method Init\n         * @param paramObj {Object} object containing parameters of Init function\n         *  @param paramObj.blockData {String} blockData string in json format (from embedded data)\n         *  @param paramObj.columnData {String} columnData string in json format (from embedded data)\n         *  @param paramObj.exitQuestions {String} exitQuestions string (from embedded data)\n         *  @param paramObj.exitItemTag {String} Tag of the Exit question of this block\n         *  @param paramObj.blockId {String} Identificaton of the block\n         *  @param [paramObj.onLoadFn] {Function} Function to be called when this Question is displayed\n         *  @param [paramObj.interTrialDelay] {Integer|Array} Specify millisecond delay between end of previous trial and beginning of new trial\n         *  @param [paramObj.preTrialDelay] {Integer|Array} Specify millisecond (ms) delay before the start of the first trial of the block. //NYI\n         *  @param [paramObj.initQuestionIndex] {Integer} Specify index of the Init question in the Question Block (defaults to 1)\n         *  @param [paramObj.waitForImages] {Boolean} Specify whether we should wait for images or not. Is on by default, but could be turned off if all images are pre-loaded in cache, or are very small in general.\n         */\n        Init: function(paramObj) {\n            var validationArray, qArray, initIndex;\n            //init the library\n            QRTE.init();\n\n            //set the initIndex (if the Init question is not the first question of the block)\n            QRTE.initIndex = paramObj.initQuestionIndex - 1 || 0;\n\n\n            validationArray = [{\n                name: 'blockData',\n                type: ['JSON', 'Empty'],\n                required: true\n            }, {\n                name: 'columnData',\n                type: ['JSON', 'Empty'],\n                required: true\n            }, {\n                name: 'idData',\n                type: ['JSON', 'Empty'],\n                required: true\n            }, {\n                name: 'blockId',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'onLoadFn',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'interTrialDelay',\n                type: ['Integer', 'Array'],\n                required: false\n            }, {\n                name: 'exitQuestions',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'exitItemTag',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'waitForImages',\n                type: ['Boolean'],\n                required: false\n            }];\n\n            //Validate Parameter Object, outputs stuff to console\n            QRTE.validateParams(paramObj, validationArray, 'Init');\n\n\n            //Initialize the library itself (necessary for each trial)\n            QRTE.initLib(paramObj.blockData, paramObj.blockId, paramObj.columnData, paramObj.idData, paramObj.exitQuestions, paramObj.exitItemTag);\n\n\n            if (paramObj.waitForImages !== undefined) {\n                QRTE.waitForImageLoad = paramObj.waitForImages;\n            }\n            //calculate server communication delay\n            QRTE.setTrialData('InitPre[OnsetTime]', QRTE.getBlockData('QRTLib_previousStorageDone'));\n\n            QRTE.setTrialData('InitPre[OffsetTime]', window.requestAnimationFrame.now());\n            QRTE.setTrialData('InitPre[CalculatedDuration]', QRTE.getTrialData('InitPre[OffsetTime]') - QRTE.getTrialData('InitPre[OnsetTime]'));\n            QRTE.setTrialData('Init[OnsetTime]', window.requestAnimationFrame.now());\n\n\n\n            Qualtrics.SurveyEngine.addOnload(function() {\n                this.qHTML = document.getElementById(this.questionId);\n                this.QRTLib_isActive = false;\n                this.hideChoices();\n                this.proceed = QRTE.proceed;\n                this.QRTLibId = 'InitPost';\n\n                paramObj.onLoadFn.apply(this);\n                var QuestionStackElement = {\n                    questionElement: this,\n                    onShowFunc: function() {},\n                    type: 'Stimulus',\n                    loadConfig: true,\n                    id: 'InitPost',\n                    conditional: function() {\n                        return true;\n                    },\n                    proceedOnHide: true\n\n                };\n                QRTE.setConfig(QuestionStackElement.id, 'duration', 0);\n                QRTE.postInitElement = QuestionStackElement;\n                QRTE.questionQueue.push(QuestionStackElement);\n            });\n\n            if (paramObj.interTrialDelay instanceof Array) {\n                paramObj.interTrialDelay = paramObj.interTrialDelay[Math.floor(Math.random() * paramObj.interTrialDelay.length)];\n            }\n            QRTE.setTrialData(paramObj.blockId + '[InterTrialDelay]', paramObj.interTrialDelay);\n            if (paramObj.interTrialDelay > 0) {\n                QRTE.setBlockData('QRTLib_intraTrialDelay', paramObj.interTrialDelay);\n            } else {\n                QRTE.setBlockData('QRTLib_intraTrialDelay', -1);\n            }\n        },\n\n        /**\n         * Create a Stimulus question\n         * @method Stimulus\n         * @param paramObj {Object}\n         *  @param paramObj.id {String} Id of the Question\n         *  @param paramObj.onShowFn {Function} Function to be called upon showing the question (not the same as upon loading)\n         *  @param [paramObj.conditional] {Function} Function to be called with which to decide whether to present this question or not, should return a boolean.\n         *  @param [paramObj.loadConfig] {Boolean} Load predefined config for this question (defaults to true)\n         *  @param [paramObj.stimContinue] {Boolean} Continue looking for stimuli after having seen this one, only if set to true (defaults to false)\n         *  @param [paramObj.onKeyPress] {Function} Function to be called upon receiving a key press while this Question is active (called next to onAllowableKey or onCorrectKey)\n         *  @param [paramObj.onAllowableKey] {Function} Function to be called upon receiving a key press on a key defined as 'allowable' \n         *  @param [paramObj.onCorrectKey] {Function} Function to be called upon receiving a key press on a key defined as 'correct'\n         *  @param [paramObj.onIncorrectKey] {Function} Function to be called upon receiving an allowable key that is not defined as correct (only if correct responses are defined)\n         *  @param [paramObj.proceedOnHide] {Boolean} Set whether all currently displayed elements should be removed on hide, or if only this should be removed from display (Defaults to True). This allows the user to decouple presentation of a stimulus from proceeding of a slide.\n         *  @param [paramObj.onHideFn] {Function} Function to be called upon Stimulus being hidden\n         *  @param [paramObj.duringDisplayFn] {Function} Function to be called during each frame that the Stimulus is being displayed\n         \n         */\n        Stimulus: function(paramObj) {\n            var validationArray = [{\n                name: 'id',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'onShowFn',\n                type: ['Function'],\n                required: true\n            }, {\n                name: 'conditional',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'loadConfig',\n                type: ['Boolean'],\n                required: false\n            }, {\n                name: 'duringDisplayFn',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'continue',\n                type: ['Boolean'],\n                required: false\n            }, {\n                name: 'onAllowableKey',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'onCorrectKey',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'onKeyPress',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'onIncorrectKey',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'proceedOnHide',\n                type: ['Boolean'],\n                required: false\n            }, {\n                name: 'onHideFn',\n                type: ['Function'],\n                required: false\n            }];\n\n            //Validate Parameter Object, outputs stuff to console\n            QRTE.validateParams(paramObj, validationArray, 'Stimulus');\n\n\n            if (paramObj.conditional === undefined) {\n                paramObj.conditional = function() {\n                    return true;\n                };\n            }\n            if (paramObj.loadConfig === undefined) {\n                paramObj.loadConfig = true;\n            }\n\n            if (paramObj.stimContinue === undefined) {\n                paramObj.stimContinue = false;\n            }\n\n            if (paramObj.proceedOnHide === undefined) {\n                paramObj.proceedOnHide = true;\n            }\n            Qualtrics.SurveyEngine.addOnload(function() {\n                this.QRTLib_isActive = false;\n                this.proceed = QRTE.proceed;\n                this.QRTLibId = paramObj.id;\n                var QuestionStackElement = {\n                    questionElement: this,\n                    onShowFunc: paramObj.onShowFn,\n                    duringDisplayFn: paramObj.duringDisplayFn,\n                    onHideFn: paramObj.onHideFn,\n                    type: 'Stimulus',\n                    loadConfig: paramObj.loadConfig,\n                    id: paramObj.id,\n                    conditional: paramObj.conditional,\n                    stimContinue: paramObj.stimContinue,\n                    onAllowableKey: paramObj.onAllowableKey,\n                    onCorrectKey: paramObj.onCorrectKey,\n                    onKeyPress: paramObj.onKeyPress,\n                    onIncorrectKey: paramObj.onIncorrectKey,\n                    proceedOnHide: paramObj.proceedOnHide\n                };\n                QRTE.questionQueue.push(QuestionStackElement);\n            });\n        },\n\n        /**\n         * Exit denotes the end of the block. Important for the initialization phase and the exit phase.\n         * Make the question a Form question with precisely 2 answer fields (more is unnecessary, those will get ignored)\n         * @method Exit\n         */\n        Exit: function() {\n\n\n            qArray = $('Questions').getElementsByClassName('QuestionOuter');\n            for (var i = 0; i < qArray.length && i < QRTE.initIndex + 1; i += 1) {\n                qArray[i].style.display = 'block';\n            }\n            Qualtrics.SurveyEngine.addOnload(function() {\n                //Hide all choice\n                this.hideChoices();\n                //display the question\n                //this.questionContainer.style.display = 'none';\n                var QuestionStackElement, onShowFn;\n                onShowFn = function() {\n\n                    //Create and/or store standard information about the trial\n                    var blockId = QRTE.getBlockData('QRTLib_currentBlock'),\n                        tempTD = {},\n                        key,\n                        i;\n\n                    QRTE.setBlockData('QRTLib_previousEndTime', window.requestAnimationFrame.now());\n                    QRTE.setTrialData(blockId + '[TrialNr]', QRTE.getBlockData('QRTLib_blockCounter'));\n                    QRTE.setTrialData(blockId + '[RefreshPeriod]', QRTE.refreshPeriod);\n                    QRTE.setTrialData('BlockId', blockId);\n                    QRTE.setTrialData('EngineType', window.requestAnimationFrame.method);\n                    QRTE.setTrialData('Exit[OnsetTime]', window.requestAnimationFrame.now());\n                    QRTE.setTrialData('QRTEngine[Version]', QRTE.version);\n\n                    //CHECK IF ATLEAST TWO FORM FIELDS HAVE BEEN DEFINED\n                    this.setChoiceValue(2, 'testtest');\n                    if (this.getChoiceValue(2) !== 'testtest') {\n                        //alert('You need to define two answer form fields in the Exit question!!');\n                    }\n\n                    for (key in QRTE.TDCache) {\n                        if (QRTE.TDCache.hasOwnProperty(key) && key !== '') {\n                            //Change QID thingies to entered ID's, also force every value to a string so that the Parser handles high numerical values correctly\n                            tempTD[QRTE.getOutputKey(key)] = String(QRTE.TDCache[key]);\n                        }\n                    }\n\n                    this.setChoiceValue(1, Object.toJSON(tempTD));\n                    this.setChoiceValue(2, blockId);\n                    if (QRTE.SDCache[QRTE.columnsField][blockId] === undefined) {\n                        QRTE.SDCache[QRTE.columnsField][blockId] = [];\n                    }\n                    for (i = 0; i < QRTE.newlyAddedColumns.length; i += 1) {\n                        QRTE.SDCache[QRTE.columnsField][blockId].push(QRTE.getOutputKey(QRTE.newlyAddedColumns[i]));\n                    }\n\n                    QRTE.setSurveyData(QRTE.columnsField, Object.toJSON(QRTE.SDCache[QRTE.columnsField]));\n                    QRTE.setBlockData('QRTLib_blockCounter', QRTE.getBlockData('QRTLib_blockCounter') + 1);\n                    QRTE.setBlockData('QRTLib_previousStorageDone', window.requestAnimationFrame.now());\n                    QRTE.saveBlockData();\n\n                    //If wanting to test, uncomment this line and comment the one after that to enforce manual nextbutton clicks\n                    //$('NextButton').style.display = 'block';\n                    //QRTE.submitPage();\n                    QRTEController.loadNextTrial();\n                };\n\n                QuestionStackElement = {\n                    questionElement: this,\n                    onShowFunc: onShowFn,\n                    type: 'Storage',\n                    loadConfig: true,\n                    conditional: function() {\n                        return true;\n                    }\n                };\n                QRTE.questionQueue.push(QuestionStackElement);\n\n                QRTE.startTrial(0);\n\n            });\n\n            QRTE.loadWaitingList = [false];\n            if (QRTE.waitForImageLoad === true) {\n                //set wait for image load queues.\n                var loadIndex = 1,\n                    images = $$('.QuestionOuter img'),\n                    i = 0;\n\n                var l = images.length;\n                for (; i < l; i += 1) {\n                    images[i].observe('load', function(e) {\n                        QRTE.startTrial(e.path[0].QRTELoadIndex);\n                    })\n                    images[i].QRTELoadIndex = i + 1;\n                    QRTE.loadWaitingList[i + 1] = false;\n                }\n\n            }\n\n        },\n\n        /**\n         * Remove the padding Qualtrics adds between Questions (causes question presentation to drift downwards if not called).\n         * DEPRECATED: Separators hidden through CSS now\n         * @method removeSeparators\n         * @private\n         */\n        removeSeparators: function() {\n            var questionElement = document.getElementById('Questions'),\n                index;\n            for (index = 0; index < questionElement.children.length; index += 1) {\n                if (questionElement.children[index].className === \"Separator\") {\n                    questionElement.children[index].parentNode.removeChild(questionElement.children[index]);\n                }\n            }\n        },\n        /**\n         * Notifies the engine the first trial is ready to be started. Called at the end of the 'exit' question\n         * @private\n         * @method startTrial\n         */\n        startTrial: function(startId) {\n            var duringDisplayFn, onHideFn, onDisplayFn, serverCommDelay, remainingDelay;\n            //All questions have been hidden, so display the parent block again\n            //$('Questions').style.display = 'block';\n\n            QRTE.loadWaitingList[startId] = true;\n            if (!QRTE.loadWaitingList.every()) {\n                QRTE.log('Process ' + startId + 'finished, waiting for other processes to finish')\n                return;\n            }\n\n            //Save the absolute time of when onLoad part of library was finished\n            serverCommDelay = window.requestAnimationFrame.now() - QRTE.getBlockData('QRTLib_previousEndTime'); //Calculate the remaining time based on the lib initialization + server delay times\n            remainingDelay = QRTE.getBlockData('QRTLib_intraTrialDelay') - serverCommDelay;\n\n\n            if (isNaN(remainingDelay)) {\n                remainingDelay = QRTE.getBlockData('QRTLib_intraTrialDelay') * 3;\n                //If this init call is the first one of the block (first trial), calculate the estimated refreshdelay during the pre-trial interval\n                onDisplayFn = function(ele, time) {\n                    QRTE.setTrialData('Init[OffsetTime]', ele.displayOnsetTime);\n                    QRTE.setTrialData('Init[CalculatedDuration]', ele.displayOnsetTime - QRTE.getTrialData('Init[OnsetTime]'));\n                    QRTE.refreshPeriodEstimationStack = [];\n                };\n                duringDisplayFn = function(ele, time) {\n                    //Get current time, required for \n                    QRTE.refreshPeriodEstimationStack.push(time);\n                };\n                onHideFn = function(ele, timestamp) {\n                    var diffs = [];\n\n                    for (i = 1; i < QRTE.refreshPeriodEstimationStack.length; i += 1) {\n                        diffs[i - 1] = QRTE.refreshPeriodEstimationStack[i] - QRTE.refreshPeriodEstimationStack[i - 1];\n                    }\n                    QRTE.refreshPeriod = QRTE.median(diffs);\n                    QRTE.log('Estimated refresh delay = ' + QRTE.refreshPeriod);\n                    QRTE.setBlockData('QRTE_refreshPeriod', QRTE.refreshPeriod);\n                    QRTE.referenceTime = timestamp;\n                    QRTE.framesSinceReference = 0;\n                };\n            } else {\n                onDisplayFn = function(ele, time) {\n                    QRTE.setTrialData('Init[OffsetTime]', ele.displayOnsetTime);\n                    QRTE.setTrialData('Init[CalculatedDuration]', ele.displayOnsetTime - QRTE.getTrialData('Init[OnsetTime]'));\n                };\n\n                QRTE.refreshPeriod = QRTE.getBlockData('QRTE_refreshPeriod');\n            }\n\n            //QRTE.setTrialData('ITI[Duration]', (remainingDelay > 0) ? remainingDelay : 0);\n            QRTE.initTime = window.requestAnimationFrame.now();\n\n            QRTE.postInitElement.onHideFn = onHideFn;\n            QRTE.postInitElement.onDisplayFn = onDisplayFn;\n            QRTE.postInitElement.duringDisplayFn = duringDisplayFn;\n            QRTE.setConfig('InitPost', 'duration', (remainingDelay > 0) ? remainingDelay : 0);\n            //UNCOMMENT\n            //QRTE.setConfig('InitPost', 'duration', (remainingDelay > 0) ? remainingDelay : Infinity);\n            QRTE.inited = true;\n\n            //Set initial trial data related to loading of this trial\n            QRTE.setTrialData('InitServerComm[Onset]', QRTE.getBlockData('ServerCommOnset'));\n            QRTE.setTrialData('InitServerComm[Offset]', QRTE.getBlockData('ServerCommOffset'));\n            QRTE.setTrialData('InitServerComm[CalculatedDuration]', QRTE.getBlockData('ServerCommOffset') - QRTE.getBlockData('ServerCommOnset'));\n\n            //<Load next trial here>\n            var currentLoops = '${lm://CurrentLoopNumber}',\n                totalLoops = '${lm://TotalLoops}';\n            //Check if last trial, currentloops === totalLoops;\n            QRTEController.requestNextTrial(currentLoops !== '' && currentLoops === totalLoops);\n\n            QRTE.proceed();\n        },\n\n\n\n        proceed: function() {\n            QRTE.log(\"proceed called after \" + window.requestAnimationFrame.now() - QRTE.initTime);\n            QRTE.hideAllElements();\n        },\n\n        proceedPage: function() {\n            var currentQ;\n            QRTE.log(\"Proceeding page..\");\n            while (QRTE.currentPageQuestions.length > 0) {\n                currentQ = QRTE.currentPageQuestions.shift();\n\n                //Disable\n                currentQ.questionElement.QRTLib_isActive = false;\n            }\n\n\n            //Go to next question\n            QRTE.showNextPage();\n        },\n\n        disableQuestion: function(disableQ) {},\n\n        /**\n         * Determine and show the next page/slide\n         * @private\n         * @method showNextPage\n         */\n        showNextPage: function() {\n            var continueSearch = true,\n                shownQ = false,\n                nextQ,\n                shown;\n            while (continueSearch === true) {\n                continueSearch = false;\n                nextQ = QRTE.questionQueue.shift();\n                if (nextQ !== undefined && (nextQ.type === 'Stimulus' || nextQ.type === 'Storage')) {\n                    QRTE.currentPageQuestions.push(nextQ);\n                    shown = QRTE.showStimulusQuestion.apply(nextQ.questionElement, [nextQ]);\n\n                    if (nextQ.stimContinue) {\n                        continueSearch = true;\n                        if (shown === true) {\n                            shownQ = true;\n                        }\n                    }\n                    QRTE.log('shown ' + nextQ.id + ': ' + shown);\n                    QRTE.log('continue ' + nextQ.id + ': ' + continueSearch);\n                    if (shown === false && shownQ === false) {\n                        continueSearch = true;\n                    }\n                }\n            }\n\n        },\n\n        /**\n         * Show Question\n         * Handles the activation of that question, which includes:\n         * The loading of the configuration (duration, allowable keys etc).\n         * Sets the event handler to respond to any key presses during the event.\n         * @private\n         * @method showStimulusQuestion\n         * @param question {Object} question to be shown.\n         *  @param id {String} Id of question.\n         *  @param onShowFunc {Function} Function to be called when showing question\n         *  @param loadConfig {Boolean} If true, config is loaded from the current block data (which has been defined elsewhere)\n         *  @param questionElement {Object} This Qualtrics question element\n         *  @param duringDisplayFn {Function} Function to be called each frame that the question is presented\n         */\n        showStimulusQuestion: function(question) {\n            //Save the loading start time\n            //QRTE.setTrialData(question.questionElement.QRTLibId + '[LoadStartTime]', window.requestAnimationFrame.now());\n            //Set mapping of the QID -> QRTE Id\n            QRTE.setId(this, question.id);\n\n            //Initialize variables\n            var stimulusShown = false,\n                questionScope = this,\n                dispEle;\n            QRTE.log(question);\n\n            //Check whether question should be shown or not, if not skip to the next question (implicitly)\n            if (question.conditional() === true) {\n                this.QRTLib_isActive = true;\n\n\n                if (question.loadConfig === true) {\n                    //Load the Configuration of the Question, important!\n                    QRTE.loadConfig(this);\n                }\n\n                //Check if KeyPress listener is required (one or more of the following fields are defined: onKeyPress, onCorrectKey or onAllowableKey)\n                //If so, add keypress listener.\n                if (question.onKeyPress !== undefined || question.questionElement.allowable !== '' || question.questionElement.cresp !== '') {\n                    //Initialize the fields used for storing data about RT timing.\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[RTTime]', '');\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[RT]', '');\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[RESP]', '');\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[ACC]', 0);\n\n                    //Add the key listener\n                    QRTE.addKeyListener(function(e) {\n\n                        //Get the Key of the response\n                        var RT, RESP = QRTE.keycode2string(e),\n                            RTTime = window.requestAnimationFrame.now();\n                        RT = RTTime - QRTE.getTrialData(question.questionElement.QRTLibId + '[OnsetTime]');\n\n                        //Store the Time of the Key Press and calculate the RT and ACC if correct\n\n                        if ((QRTE.isAllowableResponse(question.questionElement, RESP) || QRTE.isCorrectResponse(question.questionElement, RESP)) && QRTE.getTrialData(question.questionElement.QRTLibId + '[RTTime]') === '') {\n                            QRTE.setTrialData(question.questionElement.QRTLibId + '[RTTime]', RTTime);\n                            QRTE.setTrialData(question.questionElement.QRTLibId + '[RT]', RT);\n                            QRTE.setTrialData(question.questionElement.QRTLibId + '[RESP]', RESP);\n                            if (QRTE.isCorrectResponse(question.questionElement, RESP)) {\n                                QRTE.saveAcc(question.questionElement, 1);\n                            } else {\n                                QRTE.saveAcc(question.questionElement, 0);\n                            }\n                        }\n\n                        //Store the RT and the Response\n\n                        //Set Handling Key Press to true, this lets the engine know that a keypress is currently being handled. Necessary when there is a timer (response deadline)\n                        question.handlingKeyPress = true;\n\n                        if (question.onCorrectKey !== undefined && QRTE.isCorrectResponse(question.questionElement, RESP)) {\n                            question.onCorrectKey.apply(question.questionElement, [e, RESP]);\n                        } else if (question.onIncorrectKey !== undefined && QRTE.isAllowableResponse(question.questionElement, RESP)) {\n                            question.onIncorrectKey.apply(question.questionElement, [e, RESP]);\n                        }\n\n                        if (question.onAllowableKey !== undefined && QRTE.isAllowableResponse(question.questionElement, RESP)) {\n                            question.onAllowableKey.apply(question.questionElement, [e, RESP]);\n                        }\n\n                        if (question.onKeyPress !== undefined) {\n                            question.onKeyPress.apply(question.questionElement, [e, RESP]);\n                        }\n\n                        if (question.questionElement.endAction === 'TERMINATE') {\n                            //Proceed to the next Question Page if the response is allowable\n                            if (QRTE.isAllowableResponse(question.questionElement, RESP) && question.questionElement.QRTLib_isActive === true) {\n                                question.questionElement.proceed();\n                            }\n                        }\n                        question.handlingKeyPress = false;\n\n                    }, this);\n                }\n\n                //Build the display Element. Stimuli Questions have to take into account the possibility of being associated with a key press. \n                //OnDisplayFn therefore logs the displayOnsetTime, so that the RT can be calculated.\n                dispEle = {\n                    el: this.questionContainer,\n                    duration: this.duration,\n                    delay: this.offset,\n                    duringDisplayFn: question.duringDisplayFn,\n                    onDisplayFn: function(displayEl, timestamp) {\n                        if (question.onDisplayFn !== undefined) {\n                            question.onDisplayFn(displayEl, timestamp);\n                        }\n                        QRTE.setTrialData(questionScope.QRTLibId + '[OnsetTime]', displayEl.displayOnsetTime);\n                    },\n                    proceedOnHide: question.proceedOnHide,\n                    id: question.id\n                };\n\n                //Set the OnHide Function\n                dispEle.onHideFn = function(displayEl, timestamp) {\n                    if (question.onHideFn !== undefined) {\n                        question.onHideFn(displayEl, timestamp);\n                    }\n                    QRTE.setTrialData(questionScope.QRTLibId + '[OffsetTime]', displayEl.displayOffsetTime);\n                    QRTE.setTrialData(questionScope.QRTLibId + '[CalculatedDuration]', displayEl.displayDuration);\n                };\n\n\n                this.QRTLib_timer = QRTE.displayElement(dispEle);\n\n                question.onShowFunc.apply(this);\n\n                stimulusShown = true;\n            }\n\n            //QRTE.setTrialData(question.questionElement.QRTLibId + '[LoadEndTime]', window.requestAnimationFrame.now());\n            return stimulusShown;\n        },\n\n        setId: function(question, desc) {\n\n            this.idCache[question.questionId] = desc;\n            question.qId = desc;\n\n            Qualtrics.SurveyEngine.setEmbeddedData(QRTE.idField, Object.toJSON(this.idCache));\n        },\n\n        getOutputKey: function(key) {\n            var oldKey;\n            for (oldKey in this.idCache) {\n                if (this.idCache.hasOwnProperty(oldKey) && oldKey === key.substring(0, oldKey.length)) {\n\n                    return QRTE.getBlockData('QRTLib_currentBlock') + this.idCache[oldKey] + key.substring(oldKey.length, key.length);\n                }\n            }\n            return key;\n        },\n\n\n        OnKeyPress: function(fn, qScope) {\n\n            qScope = qScope || window;\n\n            var keyFn = function(e) {\n                QRTE.setTrialData(qScope.QRTLibId + '[RTTime]', window.requestAnimationFrame.now());\n                var RT = QRTE.getTrialData(qScope.QRTLibId + '[RTTime]') - QRTE.getTrialData(qScope.QRTLibId + '[OnsetTime]');\n                QRTE.setTrialData(qScope.QRTLibId + '[RT]', RT);\n                QRTE.setTrialData(qScope.QRTLibId + '[RESP]', QRTE.keycode2string(e));\n                QRTE.log(qScope);\n                fn.apply(qScope, [e]);\n            }\n\n            QRTE.addKeyListener(keyFn, qScope);\n        },\n\n        addKeyListener: function(fn, listenerScope) {\n            Event.observe(document, 'keypress', function(e) {\n                if (listenerScope.QRTLib_isActive === true) {\n                    fn.apply(listenerScope, [e]);\n                }\n            });\n        },\n\n        /*  \n         **************Methods below this line are support methods*******************\n         */\n\n        hideQuestions: function() {\n            qArray = $('Questions').getElementsByClassName('QuestionOuter');\n            for (var i = 0; i < qArray.length; i += 1) {\n                qArray[i].style.display = 'none';\n            }\n        },\n\n        unhideQuestions: function() {\n            //Redisplay outer questions\n            qArray = $('Questions').getElementsByClassName('QuestionOuter');\n            for (var i = 0; i < qArray.length; i += 1) {\n                qArray[i].style.display = 'block';\n            }\n            //Redisplay separators\n            qArray = $('Questions').getElementsByClassName('Separator');\n            for (var i = 0; i < qArray.length; i += 1) {\n                qArray[i].style.display = 'block';\n            }\n\n\n        },\n\n        _handleKeyPressEvent: function() {\n\n        },\n\n        _setConfig: function(QID, option, value, setterFunc) {\n            var qidString = QID;\n            if (typeof QID !== 'string') {\n                qidString = QID.questionId;\n            }\n            option = option.toLowerCase();\n\n            switch (option) {\n                case 'duration':\n                    if (value instanceof Array) {\n                        value = value[Math.floor(Math.random() * value.length)];\n                    }\n                    setterFunc.apply(this, [qidString, 'Duration', value]);\n                    break;\n                case 'allowable':\n                    setterFunc.apply(this, [qidString, 'Allowable', value]);\n                    break;\n                case 'cresp':\n                    setterFunc.apply(this, [qidString, 'CRESP', value]);\n                    break;\n                case 'delay':\n                    setterFunc.apply(this, [qidString, 'Offset', value]);\n                    break;\n                case 'endaction':\n                    setterFunc.apply(this, [qidString, 'EndAction', value]);\n                    break;\n                default:\n                    QRTE.log('No such configuration: ' + option);\n                    break;\n            }\n        },\n        getDuration: function(question) {\n            var duration = Infinity,\n                edDuration = this.getTrialData(question.QRTLib_configId + '[Duration]');\n            if (edDuration !== undefined && edDuration !== '' && !isNaN(edDuration)) {\n                duration = edDuration;\n            }\n            if (question._Duration !== undefined && question._Duration !== '' && !isNaN(question._Duration)) {\n                duration = question._Duration;\n            }\n\n            return duration;\n        },\n        getAllowable: function(question) {\n            var allowable = \"\",\n                edAllowable = this.getTrialData(question.QRTLib_configId + '[Allowable]');\n            if (edAllowable !== undefined) {\n                allowable = edAllowable;\n            }\n            if (question._Allowable !== undefined) {\n                allowable = question._Allowable;\n            }\n\n            if (allowable === '{ANY}') {\n                allowable = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890-=[]\\\\;',./`\";\n            }\n            //allowable = allowable.toUpperCase();\n            return allowable;\n        },\n        getCResp: function(question) {\n            var cresp = '',\n                edcresp = this.getTrialData(question.QRTLib_configId + '[CRESP]');\n            if (edcresp !== undefined) {\n                cresp = edcresp;\n            }\n            if (question._cresp !== undefined) {\n                cresp = question._CRESP;\n            }\n\n            if (cresp === '{ANY}') {\n                cresp = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890-=[]\\\\;',./`\";\n            }\n            //cresp = cresp.toUpperCase();\n\n            return cresp;\n        },\n\n        getOffset: function(question) {\n            var offset = 0,\n                edOffset = this.getTrialData(question.QRTLib_configId + '[Offset]');\n            if (edOffset !== undefined && edOffset !== '' && !isNaN(edOffset)) {\n                offset = edOffset;\n            }\n            if (question._Offset !== undefined && question._Offset !== '' && !isNaN(question._Offset)) {\n                offset = question._Offset;\n            }\n\n            return offset;\n\n        },\n\n        getEndAction: function(question) {\n            var endAction = 'NONE',\n                edEndAction = this.getTrialData(question.QRTLib_configId + '[EndAction]');\n            if (edEndAction !== undefined && edEndAction !== '') {\n                endAction = edEndAction;\n            }\n            if (question._EndAction !== undefined && question._EndAction !== '') {\n                endAction = question._EndAction;\n            }\n\n            return endAction;\n\n        },\n        evaluateConditional: function(conditional) {\n            QRTE.log('Conditional: ', conditional);\n            return conditional === '' || conditional();\n        },\n        log: function() {\n            if (QRTE.debug === true) {\n                for (var i = 0; i < arguments.length; i += 1) {\n                    console.log(arguments[i]);\n                }\n            }\n        },\n\n        median: function(values) {\n\n            values.sort(function(a, b) {\n                return a - b;\n            });\n\n            var half = Math.floor(values.length / 2);\n\n            if (values.length % 2) return values[half];\n            else return (values[half - 1] + values[half]) / 2.0;\n        },\n\n        waitForKey: function(question, keys) {\n            Event.observe(document, 'keypress', function(e) {\n                var resp = QRTE.keycode2string(e);\n                if (keys.indexOf(resp) >= 0) {\n                    question.clickNextButton();\n                }\n            });\n        },\n\n        validateParams: function(paramObj, validationArray) {\n            var valObj, val, index, typeCheck = true,\n                indexType;\n            //Loop over validationArray to check whether parameters suffice\n            for (index = 0; index < validationArray.length; index += 1) {\n                valObj = validationArray[index];\n                if (paramObj[valObj.name] === undefined && valObj.required === true) {\n                    alert('Required parameter: ' + valObj.name + ' seems to be missing');\n                    QRTE.log('Required parameter: ' + valObj.name + ' seems to be missing');\n                    break;\n                }\n\n                val = paramObj[valObj.name];\n\n                //Loop over type checkers\n                for (indexType = 0; indexType < valObj.type.length; indexType += 1) {\n                    typeCheck = QRTE.validateType(val, valObj.type[indexType]);\n                    if (typeCheck === true) {\n                        break;\n                    }\n                }\n                if (typeCheck === false && valObj.required === true) {\n                    alert('Parameter: ' + valObj.name + ' is of the wrong type, expected type: ' + valObj.type + ', type received: ' + (typeof val) + \"\\n\" + \"Please open the console for detailed error messages\");\n                    QRTE.log('Parameter: ' + valObj.name + ' is of the wrong type, expected type: ' + valObj.type + ', type received: ' + (typeof val));\n                    QRTE.log('Faulty parameter ' + valObj.name + ': ', val);\n                    QRTE.log('Proper functioning of QRTE is no longer guaranteed, please fix the above error');\n                }\n\n            }\n        },\n\n        validateType: function(val, type) {\n            switch (type) {\n                case 'JSON':\n                    return val.isJSON();\n                case 'String':\n                    return (typeof val === 'string' || val instanceof String);\n                case 'Number':\n                    return (!isNaN(parseFloat(val)) && isFinite(val));\n                case 'Array':\n                    return val instanceof Array;\n                case 'Object':\n                    return typeof val === 'object';\n                case 'Function':\n                    return typeof val === 'function';\n                case 'Boolean':\n                    return (val === true || val === false);\n                case 'Empty':\n                    return val === '';\n                default:\n                    return false;\n            }\n        },\n\n        fixSetEmbeddedDataBug: function() {\n            Qualtrics.SurveyEngine.setEmbeddedData = function(key, value) {\n                var fieldName = 'ED~' + key;\n                if ($(fieldName)) {\n                    $(fieldName).value = value;\n                } else {\n                    $('Header').appendChild(QBuilder('input', {\n                        type: 'hidden',\n                        id: fieldName,\n                        name: fieldName,\n                        value: value\n                    }));\n                    Qualtrics.SurveyEngine.setEmbeddedData(key, value);\n                }\n            }\n        },\n\n        //DisplayEngine part\n\n        //Since it's impossible to know when a screen refresh has happened, we assume that the first timestamp is the actual screen refresh.\n        //Based on the difference between the current timestamp Tn and the root timestamp Tn-1, we estimate the amount of frames that have passed since. \n        //Based on the amount of frames we estimate the previous screen refresh. Although not perfect, it's the best we can do.\n\n        refreshRate: 60, //hertz\n        refreshPeriod: 1000 / 60,\n        lastRefresh: 0,\n        currentRefresh: 0,\n        previousTimestamp: 0,\n        referenceTime: 0,\n        framesSinceReference: 0,\n        currentStack: [],\n        proceedOnFrameEnd: false,\n\n        init: function() {\n            window.requestAnimationFrame(QRTE.draw);\n        },\n\n        draw: function(timestamp) {\n            var curEle, newStack = [];\n            timestamp = window.requestAnimationFrame.now();\n\n\n            if (timestamp < 1e12) {\n                timestamp += window.performance.timing.navigationStart;\n            }\n\n            if (QRTE.referenceTime === 0) {\n                QRTE.referenceTime = timestamp;\n                QRTE.previousTimestamp = timestamp;\n                QRTE.framesSinceReference = 0;\n            } else {\n                //QRTE.framesSinceReference += QRTE.calcFrames(QRTE.referenceTime, timestamp);\n                QRTE.prevFrames = QRTE.framesSinceReference;\n                //frameDiff =  QRTE.calcFrames(QRTE.referenceTime, timestamp) - QRTE.prevFrames;\n                QRTE.framesSinceReference = QRTE.calcFrames(QRTE.referenceTime, timestamp);\n            }\n            QRTE.currentRefresh = (QRTE.framesSinceReference * QRTE.refreshPeriod) + QRTE.referenceTime;\n            QRTE.projectedRefresh = QRTE.currentRefresh + QRTE.refreshPeriod;\n            curEle = QRTE.currentStack.shift();\n\n            while (curEle) {\n                curEle.keep = true;\n\n                //Call duringDisplay callback function, with the current element and the timestamp as arguments.\n                if (curEle.shown === true && typeof curEle.duringDisplayFn === 'function') {\n                    curEle.duringDisplayFn(curEle, timestamp);\n                }\n\n                if (QRTE.proceedOnFrameEnd === true || curEle.hide === true || (curEle.shown === true && curEle.displayOnset !== undefined && (curEle.displayOnset + curEle.duration < QRTE.projectedRefresh))) {\n                    //If the next refresh makes it go beyond the duration, hide the element again!\n                    curEle = QRTE.hideSingleEle(curEle, timestamp);\n                } else if (curEle.shown === false && curEle.requestedAt + curEle.delay < QRTE.projectedRefresh) {\n                    curEle = QRTE.dispSingleEle(curEle, timestamp);\n                }\n\n                if (curEle.keep === false && curEle.proceedOnHide === true) {\n                    //Behold! We have found an element that commands us to proceed to the next page.\n                    QRTE.proceedOnFrameEnd = true;\n                    //Every element that has been processed so far needs to be re-processed (sadly), so that they properly hide.\n                    for (var ind = 0; ind < newStack.length; ind += 1) {\n                        if (newStack[ind].hide !== true) {\n                            newStack[ind].hide = true;\n                            QRTE.currentStack.push(newStack[ind]);\n                        }\n                    }\n                } else {\n                    //Push it to the newStack, for it to be processed next time.\n                    newStack.push(curEle);\n                }\n\n                curEle = QRTE.currentStack.shift();\n            }\n            QRTE.currentStack = newStack;\n            QRTE.lastRefresh = QRTE.currentRefresh;\n            QRTE.previousTimestamp = timestamp;\n            window.requestAnimationFrame(QRTE.draw);\n            if ((newStack.length === 0 || QRTE.proceedOnFrameEnd) && QRTE.inited === true) {\n                QRTE.proceedOnFrameEnd = false;\n                QRTE.proceedPage();\n            }\n\n\n        },\n\n        calcFrames: function(previous, current) {\n            var diff = current - previous,\n                frames = 0;\n\n            if (diff < QRTE.refreshPeriod) {\n                frames = 1;\n            } else {\n                frames = Math.floor(diff / QRTE.refreshPeriod);\n                if (diff % QRTE.refreshPeriod >= (QRTE.refreshPeriod * 0.9)) {\n                    frames += 1;\n                }\n            }\n\n            return frames;\n        },\n\n        /**\n         * Display an element for a specified duration with a specified delay. Vsyncs the display duration using requestAnimationFrame (if possible in the browser)\n         * and allows for high-precision control over its duration. Please start any custom attributes for the paramObj with the 'custom_' header, to avoid collisions.\n         * @private\n         * @method displayElement\n         * @param paramObj {Object}\n         *  @param el {Object} HTML element to be displayed\n         *  @param [onHideFn] {Function} Function to be called upon removing the element from display, is passed one argument containing all information about the display element.\n         *  @param [duration] {Number} Number of milliseconds (ms) the element should be displayed.\n         *  @param [delay] {Number} Number of milliseconds (ms) the Engine should wait before displaying the element.\n         *  @param [duringDisplayFn] {Function} Function to be called upon displaying the element for another screen refresh. Careful: Keep this function simple, could seriously hamper performance as it's called about every 16-17 ms.  is passed one argument containing all information about the display element.\n         *  @param [onDisplayfn] {Function} Function to be called upon starting to display the element. Is passed one argument containing all information about the display element.\n         */\n\n        //displayElement: function(el, callback, duration, offset, duringDisplaycb) {\n        displayElement: function(paramObj) {\n            var reqAt,\n                id = String(Math.random());\n            //QRTE.log(arguments);\n            if (paramObj.delay === undefined) {\n                paramObj.delay = 0;\n            }\n\n\n\n            if (paramObj.duration === undefined) {\n                paramObj = Infinity;\n            }\n\n            if (isNaN(QRTE.lastRefresh)) {\n                reqAt = window.requestAnimationFrame.now();\n            } else {\n                reqAt = QRTE.lastRefresh;\n            }\n            paramObj.userId = paramObj.id;\n            paramObj.id = id;\n            paramObj.shown = false;\n            paramObj.requestedAt = reqAt;\n            paramObj.hide = false;\n\n            QRTE.currentStack.push(paramObj);\n            if (paramObj.delay === 0) {\n                //This element needs to be displayed as soon as possible\n                QRTE.dispSingleEle(paramObj, QRTE.previousTimestamp);\n            }\n            QRTE.log('Added element to display stack:', paramObj);\n            //console.log('paramObj: ', paramObj.userId, ', duration: ', paramObj.duration);\n\n            return id;\n        },\n\n        hideElement: function(id) {\n            var found = false,\n                i;\n            for (i = 0; i < QRTE.currentStack.length; i += 1) {\n                if (QRTE.currentStack[i].id === id) {\n                    found = true;\n                    QRTE.currentStack[i].hide = true;\n                    this.log('Element to be hidden: ', QRTE.currentStack[i]);\n                }\n            }\n            return found;\n        },\n\n        hideAllElements: function() {\n            for (i = 0; i < QRTE.currentStack.length; i += 1) {\n                QRTE.currentStack[i].hide = true;\n            }\n            QRTE.proceedOnFrameEnd = true;\n        },\n\n        /**\n         * Hide a DrawEngine Element\n         * @private\n         * @method hideSingleEle\n         * @param curEle {Object}\n         */\n        hideSingleEle: function(curEle, timestamp) {\n            curEle.displayOffset = QRTE.projectedRefresh;\n            curEle.displayOffsetTime = window.requestAnimationFrame.now();\n            curEle.el.style.display = 'none';\n            curEle.keep = false;\n            curEle.hide = true;\n            //delete QRTE.currentStack[key];\n            curEle.displayDuration = curEle.displayOffsetTime - curEle.displayOnsetTime;\n            if (curEle.onHideFn !== undefined) {\n                curEle.onHideFn(curEle, timestamp);\n            }\n\n            return curEle;\n\n        },\n\n\n        /**\n         * Display a DrawEngine Element\n         * @private\n         * @method dispSingleEle\n         * @param curEle {Object}\n         */\n        dispSingleEle: function(curEle, timestamp) {\n            curEle.el.style.display = 'block';\n            curEle.displayOnset = QRTE.projectedRefresh;\n            curEle.displayOnsetTime = window.requestAnimationFrame.now();\n            curEle.shown = true;\n            if (curEle.onDisplayFn !== undefined) {\n                //Added try-catch block to catch the error that's causing the OnsetTime not to get saved.\n                try {\n                    curEle.onDisplayFn(curEle, timestamp);\n                } catch (e) {\n                    QRTE.setTrialData('Error[OnsetError]', JSON.stringify(e));\n                }\n            }\n            return curEle;\n        },\n\n        checkEngineCompatibility: function() {\n            return window.requestAnimationFrame.method === 'native-highres';\n        },\n    };\n\n    if (typeof QRTEController == 'undefined') {\n        //QRTE SurveySlider controller layer\n        //Takes care of progressing through the survey. Catches all qualtrics native ways of submitting the form and replaces that by\n        //its own asynchronous ajax stuff.\n        QRTEController = {\n\n\n            //This plug-in to QRTEngine has been developed under the name SurveySlider\n            // for general Qualtrics Surveys. It has been adapted to work with QRTEngine\n            nextTrialContainer: null,\n            nextTrialText: '',\n            currentForm: null,\n            previousForm: null,\n            handlingSubmit: false,\n            onSubmitStack: [],\n            inited: false,\n            childInputs: [],\n            loadUponCallback: false,\n            setEmbeddedData: function() {},\n            tempED: {},\n\n\n\n            //Initialize thecontroller\n            init: function() {\n                this.nextTrialContainer = new Element('div', {\n                    id: 'nextTrialContainer'\n                });\n                this.currentForm = $$('form')[0];\n\n                //Catch submits and change it with our own submit function (which does AJAX submissions)\n                //this.currentForm.observe('QRTE:submit', QRTE.handleSubmit);\n                this.currentElements = $$('.QuestionOuter');\n\n                //Initial SSload firing\n                Qualtrics.SurveyEngine.addOnload(function() {\n                    QRTEController.currentForm.fire('QRTE:load');\n                });\n                //Change SurveyEngine.OnLoad to trigger on SSload, rather than page load\n                Qualtrics.SurveyEngine.addOnload = function(f) {\n                        var questions = $$('.QuestionOuter'),\n                            currentCount = QRTEController.count(Qualtrics.SurveyEngine.QuestionInfo),\n                            id = questions[currentCount - 1].id;\n                        if ($('body') && $('body').hasClassName('EditSection')) return;\n                        try {\n                            var obj = new Qualtrics.SurveyEngine.QuestionData(id);\n                            obj.onload = f;\n\n                            QRTEController.currentForm.observe('QRTE:load', obj.onload.bind(obj));\n                            //Event.observe(this.currentForm, 'SSload', obj.onload.bind(obj));\n                        } catch (e) {\n                            console.error('SE API Error: ' + e);\n                        }\n                    }\n                    //Set the Qualtrics setEmbeddedData to inside the QRTEController\n                QRTEController.setEmbeddedData = Qualtrics.SurveyEngine.setEmbeddedData;\n                Qualtrics.SurveyEngine.setEmbeddedData = function(key, value) {\n                    QRTEController.tempED[key] = value;\n                }\n                this.submitPage = this.requestNextTrial;\n                this.inited = true;\n            },\n\n            /**\n             * Requests the next trial from the Qualtrics server.\n             *\n             *\n             */\n            requestNextTrial: function(isLastTrial) {\n\n                //If this is the last trial of a block, DON'T request the next page, let qualtrics handle it themselves\n                if (this.handlingSubmit === false && isLastTrial === false) {\n                    //Load next trial means that current page is a trial and has been inited\n                    //Need to remove relevant input elements from current form before submitting\n                    //After that add them back\n                    this.handlingSubmit = true\n                    var childs = $$('form input[type=text]'),\n                        childInputs = [];\n                    //remove current input elements from the form\n                    for (var i = 0; i < childs.length; i += 1) {\n                        childInputs[i] = {\n                            ele: childs[i],\n                            parent: childs[i].up()\n                        };\n                        childs[i].remove();\n                    }\n                    //add previous input elements to form\n                    //Text inputs\n                    for (var i = 0; i < this.childInputs.length; i += 1) {\n                        this.childInputs[i].ele.style.display = 'none';\n                        this.currentForm.insert(this.childInputs[i].ele);\n                    }\n\n\n                    //And embedded data\n                    for (var key in this.tempED) {\n                        if (this.tempED.hasOwnProperty(key)) {\n                            QRTEController.setEmbeddedData(key, this.tempED[key]);\n                        }\n                    }\n                    //Reset stored embedded data\n                    this.tempED = {};\n                    //set new childs\n                    this.childInputs = childInputs;\n\n                    //Loop over submit stack, or callbacks that need to be finished before submitting\n                    for (var i = 0; i < QRTEController.onSubmitStack.length; i += 1) {\n                        QRTE.onSubmitStack[i]();\n                    }\n                    QRTEController.onSubmitStack = [];\n                    debugger;\n                    this.currentForm.request({\n                        onComplete: this.requestNextTrialCallback\n                    });\n\n                    //Set server comm onset for the next trial\n                    QRTE.setBlockData('ServerCommOnset', window.requestAnimationFrame.now());\n\n                    QRTEController.betweenSubmits = true;\n\n                    for (var i = 0; i < this.childInputs.length; i += 1) {\n                        this.childInputs[i].parent.insert(this.childInputs[i].ele);\n                        this.childInputs[i].ele.style.display = 'none';\n                    }\n                } else if (isLastTrial === true) {\n                    //Just add the previous trial's childInputs to the form \n                    for (var i = 0; i < this.childInputs.length; i += 1) {\n\n                        this.currentForm.insert(this.childInputs[i].ele);\n                        this.childInputs[i].ele.style.display = 'none';\n                    }\n\n                    this.loadNextTrial = function() {\n                        //Directly submitting the form doesn't seem to work? Let's do it through NextButton click\n                        $('NextButton').click();\n                    };\n                }\n            },\n\n            loadNextTrial: function() {\n                if (this.handlingSubmit === true) {\n                    //The submit still hasn't returned..\n                    this.loadUponCallback = true;\n                    return;\n\n                }\n                //Set handling submit to false (as page has been returned)\n                //Save the previous form\n                this.previousForm = this.currentForm;\n                //Reset the QuestionInfo object, this is for Qualtrics to correctly initiate its own page\n                Qualtrics.SurveyEngine.QuestionInfo = {}\n                    //Parse the HTML that was returned earlier and set it as the current trial container's contents\n                this.nextTrialContainer = jQuery(this.nextTrialContainer).html(this.nextTrialText)[0];\n                //Filter out the 'form' field, and append it back.\n                this.currentForm = jQuery(this.nextTrialContainer).find('form')[0];\n                jQuery(this.previousForm).replaceWith(jQuery(this.currentForm));\n\n                jQuery(this.currentForm).show();\n\n                if (this.currentForm.select('.END_OF_SURVEY').length === 0) {\n                    this.currentForm.fire('QRTE:load');\n                    this.submitPage = this.requestNextTrial;\n                } else {\n                    this.submitPage = this.currentForm.submit;\n                }\n\n            },\n\n            requestNextTrialCallback: function(e) {\n                QRTEController.nextTrialText = e.responseText;\n                QRTEController.handlingSubmit = false;\n                QRTE.setBlockData('ServerCommOffset', window.requestAnimationFrame.now());\n\n                if (QRTEController.loadUponCallback === true) {\n                    QRTEController.loadUponCallback = false;\n                    QRTEController.loadNextTrial();\n                }\n            },\n\n            submitPage: function() {\n                console.log('Not yet initialised');\n            },\n\n            count: function(obj) {\n                var count = 0;\n\n                for (var prop in obj) {\n                    if (obj.hasOwnProperty(prop))\n                        ++count;\n                }\n\n                return count;\n            },\n\n            BDCache: {},\n            storeBlockData: function(blockData) {\n                this.BDCache = blockData;\n            },\n\n            loadBlockData: function() {\n                return this.BDCache;\n            }\n        };\n\n        document.observe('dom:loaded', QRTEController.init.bind(QRTEController));\n\n\n        (function() {\n            var lastFrame, method, now, queue, requestAnimationFrame, timer, vendor, _i, _len, _ref, _ref1;\n            method = 'native';\n            now = Date.now || function() {\n                return new Date().getTime();\n            };\n            requestAnimationFrame = window.requestAnimationFrame;\n            _ref = ['webkit', 'moz', 'o', 'ms'];\n            for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n                vendor = _ref[_i];\n                if (!(requestAnimationFrame != null)) {\n                    requestAnimationFrame = window[vendor + \"RequestAnimationFrame\"];\n                }\n            }\n            if (!(requestAnimationFrame != null)) {\n                method = 'timer';\n                lastFrame = 0;\n                queue = timer = null;\n                requestAnimationFrame = function(callback) {\n                    var fire, nextFrame, time;\n                    if (queue != null) {\n                        queue.push(callback);\n                        return;\n                    }\n                    time = now();\n                    nextFrame = Math.max(0, 16.66 - (time - lastFrame));\n                    queue = [callback];\n                    lastFrame = time + nextFrame;\n                    fire = function() {\n                        var cb, q, _j, _len1;\n                        q = queue;\n                        queue = null;\n                        for (_j = 0, _len1 = q.length; _j < _len1; _j++) {\n                            cb = q[_j];\n                            cb(lastFrame);\n                        }\n                    };\n                    timer = setTimeout(fire, nextFrame);\n                };\n            }\n            requestAnimationFrame(function(time) {\n                var _ref1;\n                if ((((_ref1 = window.performance) != null ? _ref1.now : void 0) != null) && time < 1e12) {\n                    requestAnimationFrame.now = function() {\n                        return window.performance.now() + window.performance.timing.navigationStart;\n                    };\n                    requestAnimationFrame.method = 'native-highres';\n                } else {\n                    requestAnimationFrame.now = now;\n                }\n            });\n            requestAnimationFrame.now = ((_ref1 = window.performance) != null ? _ref1.now : void 0) != null ? (function() {\n                return window.performance.now() + window.performance.timing.navigationStart;\n            }) : now;\n            requestAnimationFrame.method = method;\n            window.requestAnimationFrame = requestAnimationFrame;\n        })();\n\n        function loadScript(url, callback) {\n\n            var script = document.createElement(\"script\")\n            script.type = \"text/javascript\";\n\n            if (script.readyState) { //IE\n                script.onreadystatechange = function() {\n                    if (script.readyState == \"loaded\" || script.readyState == \"complete\") {\n                        script.onreadystatechange = null;\n                        callback();\n                    }\n\n                };\n            } else { //Others\n                script.onload = function() {\n                    callback();\n                };\n            }\n\n            script.src = url;\n            document.getElementsByTagName(\"head\")[0].appendChild(script);\n        }\n\n        (function() {\n\n            //jQuery is only required for the Fixation flash fix. prototypejs is unable to efficiently replace elements\n            //and introduces a 10 ms delay between loading element and firing off the scripts. Unacceptable\n            //First time jQuery should be used is the second trial\n\n            loadScript(\"https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js\", function() {\n\n                $.noConflict();\n\n            });\n\n        })();\n\n        //If preview mode is run (PreviewBanner element exists, add a QRTEngine plug with id QRTEPlug)\n\n        if ($('PreviewBanner')) {\n            var plug, row, banner = $('PreviewBanner');\n            //Go down to the first table row inside that banner\n            row = banner.children[0].children[0].children[0];\n            //Insert new cell    \n            plug = row.insertCell(2);\n            plug.id = \"QRTEPlug\";\n            plug.width = \"20%\";\n            plug.innerHTML = 'This survey is proudly and successfully powered by <a href=\"http://qrtengine.com\" target=\"_blank\"><i><b>QRTEngine</b></i></a>';\n            plug.style.textAlign = \"center\";\n        }\n    }\n</script>\n<script>\n    QRTE.debug = true;\n\n    QRTLib = QRTE;\n</script>\n<style type=\"text/css\">\n    #Plug {\n        display: none;\n    }\n    #NextButton {\n        display: none;\n    }\n    #PreviousButton {\n        display: none;\n    }\n    html {\n        height: 100%;\n    }\n    body {\n        height: 100%;\n        padding: 0;\n        padding-top: 0 !important;\n        margin: 0;\n    }\n    .Skin {\n        display: table;\n        margin: auto;\n        min-height: 100%;\n        height: 100%;\n    }\n    #Page {\n        height: 100%;\n        min-height: 100%;\n    }\n    .SkinInner {\n        min-height: 100%;\n        display: table-cell;\n        vertical-align: middle;\n    }\n    .QuestionText {\n        border: 0px !important;\n        border-bottom: 0px !important;\n    }\n    .QuestionOuter {\n        display: none;\n    }\n    .Separator {\n        display: none !important;\n    }\n    #SkinContent > #Buttons,\n    .SkinInner > #Header {\n        padding: 0 !important;\n    }\n</style>","\n    /* ==========================================================\n     * QRTEngine.js v16\n     * ==========================================================\n     * Copyright 2013-2014 Erwin Haasnoot\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     * http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     *\n     *\n     *\n     * ========================================================== */\n    /**\n     * Qualtrics Reaction Time Engine or QRTE is an add-on providing an interface\n     * for easy reaction time experiment creation in the Qualtrics survey research suite (tm).\n     * For instructions on how to use this add-on, see xxxx\n     *\n     * QRTE was developed by Erwin Haasnoot\n     * Email: erwinhaasnoot[at]gmail.com\n     * @class QRTE\n     *\n     */\n    var QRTE = {\n        version: 'v16',\n        columnsField: 'QRTE_columns',\n        blockDataField: 'QRTE_blockData',\n        idField: 'QRTE_idData',\n        exitQuestions: 'QRTE_exitQuestions',\n        inited: false,\n        /**\n         * TDCache contains the Trial-Level Data in an Object. DO NOT directly manipulate this Object. It might cause inconsistencies in the data file and cause unexpected once parsed.\n         * Use QRTE.setTrialData and QRTE.getTrialData instead.\n         *\n         * @property TDCache\n         * @private\n         * @type Object\n         */\n        TDCache: {},\n\n        /**\n         * ColumnCache contains all the mappings from QID to Columns\n         * @property columnCache\n         * @private\n         * @type Object\n         */\n        columnCache: {},\n\n        /**\n         * BDCache contains the BlockLevel Data in an Object. Directly manipulating this Object might cause inconsistencies\n         * @property BDCache\n         * @private\n         * @type Object\n         */\n        BDCache: {},\n\n        /**\n         * SDCache is a cache for speeding up retrieval of Survey level Data,\n         * All Survey data is saved to both Embedded Data and Survey Data\n         * @private\n         * @property SDCache\n         * @type Object\n         */\n        SDCache: {},\n\n        /**\n         * idCache is a cache for quickly retrieving the Qualtrics QID to QRTLib Id mappings.\n         * Saved in the idData embedded data field after every trial.\n         * @private\n         * @property idCache\n         * @type Object\n         */\n        idCache: {},\n\n        /**\n         * questionQueue contains Objects (stimuli) that are waiting to be presented\n         * @private\n         * @property questionQueue\n         * @type Array\n         */\n        questionQueue: [],\n\n        /**\n         * currentPageQuestions contains the Question Objects that are\n         * displayed at any given time.\n         * @private\n         * @property currentPageQuestions\n         * @type Array\n         */\n        currentPageQuestions: [],\n\n        /**\n         * Contains Trial Data Columns that were 'newly' added in this trial run.\n         * @private\n         * @property newlyAddedColumns\n         * @type Array\n         */\n        newlyAddedColumns: [],\n\n        /**\n         * Contains the Post-Initialization Element.\n         * @private\n         * @property postInitElement\n         * @type Object\n         */\n        postInitElement: {},\n\n        /**\n         * Setter function for Trial-Level Data.\n         * @method setTrialData\n         * @param key {String} Key\n         * @param value {Value} Value\n         */\n        setTrialData: function(key, value) {\n            //Store value in trial cache\n            this.TDCache[key] = value;\n            if (this.BDCache.QRTLib_trialColumns[key] === undefined) {\n                //Add column to overall trial data\n                this.BDCache.QRTLib_trialColumns[key] = '';\n                this.newlyAddedColumns.push(key);\n            }\n        },\n\n        /**\n         * Gets the value of Trial-Level Data field 'key\n         * @method getTrialData\n         * @param key {String} Key\n         */\n        getTrialData: function(key) {\n            return this.TDCache[key];\n        },\n\n        /**\n         * Setter function for Block-Level Data.\n         * @method setBlockData\n         * @param key {String} Key\n         * @param value {Value} Value\n         */\n        setBlockData: function(key, value) {\n            this.BDCache[key] = value;\n        },\n\n\n        /**\n         * Gets the value of Block-Level Data field 'key\n         * @method getBlockData\n         * @param key {String} Key\n         */\n        getBlockData: function(key) {\n            return this.BDCache[key];\n        },\n\n\n\n\n        /**\n         * Stringify the Block Data and store it in the Embedded Data Field. This preserves the values stored on Block Level for use in later trials\n         * @method saveBlockData\n         * @param key {String} Key\n         */\n        saveBlockData: function() {\n            //Store blockData in ED so that we can use it next trial\n            QRTEController.storeBlockData(QRTE.BDCache);\n            Qualtrics.SurveyEngine.setEmbeddedData(QRTE.blockDataField, Object.toJSON(QRTE.BDCache));\n        },\n\n\n\n        /**\n         * Setter function for Survey-Level Data (Embedded Data).\n         * @method setSurveyData\n         * @param key {String} Key\n         * @param value {Value} Value\n         */\n        setSurveyData: function(key, value) {\n            this.SDCache[key] = value;\n            Qualtrics.SurveyEngine.setEmbeddedData(key, value);\n        },\n\n\n\n        /**\n         * Gets the value of Survey-Level Data (Embedded Data) 'key'\n         * @method getSurveyData\n         * @param key {String} Key\n         */\n\n        getSurveyData: function(key) {\n            if (this.SDCache[key] !== undefined) {\n                return this.SDCache[key];\n            }\n            //This only works if the Survey Data has been set during the same trial due to a bug in Qualtrics.\n            return Qualtrics.SurveyEngine.getEmbeddedData(key);\n        },\n\n        /**\n         * Sets a configuration for a question\n         * @method setConfig\n         * @param QID {String} The QRTE Question Id of the Question you want the configuration to apply to\n         * @param option {String} The type of configuration you want to set, Allowed options: 'cresp', 'allowable', 'duration', 'endaction', 'delay'. Refer to website for documentation on these configs\n         * @param value {String} The value the configuration needs to be set to. Differs per option.\n         */\n        setConfig: function(QID, option, value) {\n            var setterFunc;\n            if (typeof QID === 'string') {\n                setterFunc = function(QID, option, value) {\n                    this.setTrialData(QID + \"[\" + option + \"]\", value);\n                };\n            } else {\n                setterFunc = function(QID, option, value) {\n                    this.setTrialData(QID.questionId + \"[\" + option + \"]\", value);\n                    QID['_' + option] = value;\n                };\n\n            }\n\n            this._setConfig(QID, option, value, setterFunc);\n        },\n\n\n        /**\n         * Loads the configuration for a question.\n         * @private\n         * @method loadConfig\n         * @param question {Object} Question for which the configuration needs to be loaded.\n         */\n        loadConfig: function(question) {\n            if (this.idCache[question.questionId] !== undefined) {\n                question.QRTLib_configId = this.idCache[question.questionId];\n            } else {\n                question.QRTLib_configId = question.question;\n            }\n            question.duration = this.getDuration(question);\n            question.allowable = this.getAllowable(question);\n            question.cresp = this.getCResp(question);\n            question.offset = this.getOffset(question);\n            question.endAction = this.getEndAction(question);\n        },\n\n        /**\n         * Stores the accuracy of a trial\n         * @private\n         * @method saveAcc\n         * @param question {Object} Question for which accuracy needs to be stored\n         * @param acc {Integer} Accuracy of question\n         */\n\n        saveAcc: function(question, acc) {\n            if (acc === 0 || acc === 1) {\n                this.setTrialData(question.QRTLibId + \"[ACC]\", acc);\n                this.setSurveyData(\"ACC\", acc);\n            }\n        },\n\n\n\n        /**\n         * Check whether the given response was a correct response\n         * @method isCorrectResponse\n         * @param question {Object} Question for which correct response needs to be checked\n         * @param resp {String} Given response\n         */\n        isCorrectResponse: function(question, resp) {\n            return question.cresp.indexOf(resp) >= 0;\n        },\n\n        /**\n         * Check whether the given response was an allowable response\n         * @method isAllowableResponse\n         * @param question {Object} Question for which allowable response needs to be checked\n         * @param resp {String} Given response\n         */\n        isAllowableResponse: function(question, resp) {\n            return question.allowable.indexOf(resp) >= 0;\n        },\n\n\n\n        /**\n         * Check whether the given response was an allowable response\n         * @private\n         * @method keycode2string\n         * @param e {Object} KeyPress event from which to retrieve the response\n         */\n        keycode2string: function(e) {\n            return String.fromCharCode(e.charCode);\n        },\n\n        /** \n         * Wait for images to load before starting trial.\n         * @property waitForImageLoad\n         * @private\n         * @type Boolean\n         */\n\n        waitForImageLoad: true,\n\n        /** \n         * Trial Start waiting list - initialised with waiting for TrialStart\n         * @property loadWaitingList\n         * @private\n         * @type Array\n         */\n\n        loadWaitingList: [false],\n\n        /**\n         * Initializes the Engine, called at the start of the 'Init' question.\n         * @private\n         * @method initLib\n         * @param blockDataString {String} JSON string containing information saved for this block (block-level data)\n         * @param blockId {String} Id of the current block\n         * @param columns {String} JSON string containing information about the columns that have been defined in this block\n         * @param idData {String} JSON string containing information about the mapping of the QID to the name of the question\n         * @param exitQuestions {String} String containing the currently defined QuestionTags of the Exit questions\n         * @param exitItemTag {String} String containing the Tag of this block's Exit question.\n         */\n\n\n        initLib: function(blockDataString, blockId, columns, idData, exitQuestions, exitItemTag) {\n            //var blockDataString = Qualtrics.SurveyEngine.getEmbeddedData(QRTE.blockDataField),\n            //columns = Qualtrics.SurveyEngine.getEmbeddedData(QRTE.columnsField),\n            //idData = Qualtrics.SurveyEngine.getEmbeddedData(QRTE.idField);\n            var glue;\n            QRTE.fixSetEmbeddedDataBug();\n            //Initialise block Data\n            if (blockDataString === undefined columnData || blockDataString === '') {\n                blockDataString = '{}';\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.blockDataField, blockDataString);\n            }\n\n            this.BDCache = QRTEController.loadBlockData(blockDataString);\n\n            if (this.BDCache.QRTLib_currentBlock !== blockId) {\n                //If this is a new block, initialise a new block\n                this.BDCache = {\n                    QRTLib_currentBlock: blockId,\n                    QRTLib_blockCounter: 1,\n                    QRTLib_trialColumns: {}\n                };\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.blockDataField, Object.toJSON(this.BDCache));\n                if (exitQuestions === null) {exitQuestions = '';}\n                glue = '';\n                if (exitQuestions !== '') {\n                    glue = ';';\n                }\n                //And update the exit questions\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.exitQuestions, exitQuestions + glue + exitItemTag);\n\n            }\n            QRTE.TDCache = Object.toJSON(QRTE.getBlockData('QRTLib_trialColumns')).evalJSON();\n            if (columns === undefined || columns === null || columns === '') {\n                columns = '{}';\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.columnsField, columns);\n            }\n            QRTE.SDCache[QRTE.columnsField] = columns.evalJSON();\n            if (idData === undefined || idData === null || idData === '') {\n                idData = '{}';\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.idField, idData);\n            }\n            QRTE.idCache = idData.evalJSON();\n        },\n\n        /**\n         * Init initializes the QRTEngine, expects are params object with possible fields defined with parameters.\n         * @method Init\n         * @param paramObj {Object} object containing parameters of Init function\n         *  @param paramObj.blockData {String} blockData string in json format (from embedded data)\n         *  @param paramObj.columnData {String} columnData string in json format (from embedded data)\n         *  @param paramObj.exitQuestions {String} exitQuestions string (from embedded data)\n         *  @param paramObj.exitItemTag {String} Tag of the Exit question of this block\n         *  @param paramObj.blockId {String} Identificaton of the block\n         *  @param [paramObj.onLoadFn] {Function} Function to be called when this Question is displayed\n         *  @param [paramObj.interTrialDelay] {Integer|Array} Specify millisecond delay between end of previous trial and beginning of new trial\n         *  @param [paramObj.preTrialDelay] {Integer|Array} Specify millisecond (ms) delay before the start of the first trial of the block. //NYI\n         *  @param [paramObj.initQuestionIndex] {Integer} Specify index of the Init question in the Question Block (defaults to 1)\n         *  @param [paramObj.waitForImages] {Boolean} Specify whether we should wait for images or not. Is on by default, but could be turned off if all images are pre-loaded in cache, or are very small in general.\n         */\n        Init: function(paramObj) {\n            var validationArray, qArray, initIndex;\n            //init the library\n            QRTE.init();\n\n            //set the initIndex (if the Init question is not the first question of the block)\n            QRTE.initIndex = paramObj.initQuestionIndex - 1 || 0;\n\n\n            validationArray = [{\n                name: 'blockData',\n                type: ['JSON', 'Empty'],\n                required: true\n            }, {\n                name: 'columnData',\n                type: ['JSON', 'Empty'],\n                required: true\n            }, {\n                name: 'idData',\n                type: ['JSON', 'Empty'],\n                required: true\n            }, {\n                name: 'blockId',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'onLoadFn',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'interTrialDelay',\n                type: ['Integer', 'Array'],\n                required: false\n            }, {\n                name: 'exitQuestions',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'exitItemTag',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'waitForImages',\n                type: ['Boolean'],\n                required: false\n            }];\n\n            //Validate Parameter Object, outputs stuff to console\n            QRTE.validateParams(paramObj, validationArray, 'Init');\n\n\n            //Initialize the library itself (necessary for each trial)\n            QRTE.initLib(paramObj.blockData, paramObj.blockId, paramObj.columnData, paramObj.idData, paramObj.exitQuestions, paramObj.exitItemTag);\n\n\n            if (paramObj.waitForImages !== undefined) {\n                QRTE.waitForImageLoad = paramObj.waitForImages;\n            }\n            //calculate server communication delay\n            QRTE.setTrialData('InitPre[OnsetTime]', QRTE.getBlockData('QRTLib_previousStorageDone'));\n\n            QRTE.setTrialData('InitPre[OffsetTime]', window.requestAnimationFrame.now());\n            QRTE.setTrialData('InitPre[CalculatedDuration]', QRTE.getTrialData('InitPre[OffsetTime]') - QRTE.getTrialData('InitPre[OnsetTime]'));\n            QRTE.setTrialData('Init[OnsetTime]', window.requestAnimationFrame.now());\n\n\n\n            Qualtrics.SurveyEngine.addOnload(function() {\n                this.qHTML = document.getElementById(this.questionId);\n                this.QRTLib_isActive = false;\n                this.hideChoices();\n                this.proceed = QRTE.proceed;\n                this.QRTLibId = 'InitPost';\n\n                paramObj.onLoadFn.apply(this);\n                var QuestionStackElement = {\n                    questionElement: this,\n                    onShowFunc: function() {},\n                    type: 'Stimulus',\n                    loadConfig: true,\n                    id: 'InitPost',\n                    conditional: function() {\n                        return true;\n                    },\n                    proceedOnHide: true\n\n                };\n                QRTE.setConfig(QuestionStackElement.id, 'duration', 0);\n                QRTE.postInitElement = QuestionStackElement;\n                QRTE.questionQueue.push(QuestionStackElement);\n            });\n\n            if (paramObj.interTrialDelay instanceof Array) {\n                paramObj.interTrialDelay = paramObj.interTrialDelay[Math.floor(Math.random() * paramObj.interTrialDelay.length)];\n            }\n            QRTE.setTrialData(paramObj.blockId + '[InterTrialDelay]', paramObj.interTrialDelay);\n            if (paramObj.interTrialDelay > 0) {\n                QRTE.setBlockData('QRTLib_intraTrialDelay', paramObj.interTrialDelay);\n            } else {\n                QRTE.setBlockData('QRTLib_intraTrialDelay', -1);\n            }\n        },\n\n        /**\n         * Create a Stimulus question\n         * @method Stimulus\n         * @param paramObj {Object}\n         *  @param paramObj.id {String} Id of the Question\n         *  @param paramObj.onShowFn {Function} Function to be called upon showing the question (not the same as upon loading)\n         *  @param [paramObj.conditional] {Function} Function to be called with which to decide whether to present this question or not, should return a boolean.\n         *  @param [paramObj.loadConfig] {Boolean} Load predefined config for this question (defaults to true)\n         *  @param [paramObj.stimContinue] {Boolean} Continue looking for stimuli after having seen this one, only if set to true (defaults to false)\n         *  @param [paramObj.onKeyPress] {Function} Function to be called upon receiving a key press while this Question is active (called next to onAllowableKey or onCorrectKey)\n         *  @param [paramObj.onAllowableKey] {Function} Function to be called upon receiving a key press on a key defined as 'allowable' \n         *  @param [paramObj.onCorrectKey] {Function} Function to be called upon receiving a key press on a key defined as 'correct'\n         *  @param [paramObj.onIncorrectKey] {Function} Function to be called upon receiving an allowable key that is not defined as correct (only if correct responses are defined)\n         *  @param [paramObj.proceedOnHide] {Boolean} Set whether all currently displayed elements should be removed on hide, or if only this should be removed from display (Defaults to True). This allows the user to decouple presentation of a stimulus from proceeding of a slide.\n         *  @param [paramObj.onHideFn] {Function} Function to be called upon Stimulus being hidden\n         *  @param [paramObj.duringDisplayFn] {Function} Function to be called during each frame that the Stimulus is being displayed\n         \n         */\n        Stimulus: function(paramObj) {\n            var validationArray = [{\n                name: 'id',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'onShowFn',\n                type: ['Function'],\n                required: true\n            }, {\n                name: 'conditional',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'loadConfig',\n                type: ['Boolean'],\n                required: false\n            }, {\n                name: 'duringDisplayFn',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'continue',\n                type: ['Boolean'],\n                required: false\n            }, {\n                name: 'onAllowableKey',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'onCorrectKey',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'onKeyPress',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'onIncorrectKey',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'proceedOnHide',\n                type: ['Boolean'],\n                required: false\n            }, {\n                name: 'onHideFn',\n                type: ['Function'],\n                required: false\n            }];\n\n            //Validate Parameter Object, outputs stuff to console\n            QRTE.validateParams(paramObj, validationArray, 'Stimulus');\n\n\n            if (paramObj.conditional === undefined) {\n                paramObj.conditional = function() {\n                    return true;\n                };\n            }\n            if (paramObj.loadConfig === undefined) {\n                paramObj.loadConfig = true;\n            }\n\n            if (paramObj.stimContinue === undefined) {\n                paramObj.stimContinue = false;\n            }\n\n            if (paramObj.proceedOnHide === undefined) {\n                paramObj.proceedOnHide = true;\n            }\n            Qualtrics.SurveyEngine.addOnload(function() {\n                this.QRTLib_isActive = false;\n                this.proceed = QRTE.proceed;\n                this.QRTLibId = paramObj.id;\n                var QuestionStackElement = {\n                    questionElement: this,\n                    onShowFunc: paramObj.onShowFn,\n                    duringDisplayFn: paramObj.duringDisplayFn,\n                    onHideFn: paramObj.onHideFn,\n                    type: 'Stimulus',\n                    loadConfig: paramObj.loadConfig,\n                    id: paramObj.id,\n                    conditional: paramObj.conditional,\n                    stimContinue: paramObj.stimContinue,\n                    onAllowableKey: paramObj.onAllowableKey,\n                    onCorrectKey: paramObj.onCorrectKey,\n                    onKeyPress: paramObj.onKeyPress,\n                    onIncorrectKey: paramObj.onIncorrectKey,\n                    proceedOnHide: paramObj.proceedOnHide\n                };\n                QRTE.questionQueue.push(QuestionStackElement);\n            });\n        },\n\n        /**\n         * Exit denotes the end of the block. Important for the initialization phase and the exit phase.\n         * Make the question a Form question with precisely 2 answer fields (more is unnecessary, those will get ignored)\n         * @method Exit\n         */\n        Exit: function() {\n\n\n            qArray = $('Questions').getElementsByClassName('QuestionOuter');\n            for (var i = 0; i < qArray.length && i < QRTE.initIndex + 1; i += 1) {\n                qArray[i].style.display = 'block';\n            }\n            Qualtrics.SurveyEngine.addOnload(function() {\n                //Hide all choice\n                this.hideChoices();\n                //display the question\n                //this.questionContainer.style.display = 'none';\n                var QuestionStackElement, onShowFn;\n                onShowFn = function() {\n\n                    //Create and/or store standard information about the trial\n                    var blockId = QRTE.getBlockData('QRTLib_currentBlock'),\n                        tempTD = {},\n                        key,\n                        i;\n\n                    QRTE.setBlockData('QRTLib_previousEndTime', window.requestAnimationFrame.now());\n                    QRTE.setTrialData(blockId + '[TrialNr]', QRTE.getBlockData('QRTLib_blockCounter'));\n                    QRTE.setTrialData(blockId + '[RefreshPeriod]', QRTE.refreshPeriod);\n                    QRTE.setTrialData('BlockId', blockId);\n                    QRTE.setTrialData('EngineType', window.requestAnimationFrame.method);\n                    QRTE.setTrialData('Exit[OnsetTime]', window.requestAnimationFrame.now());\n                    QRTE.setTrialData('QRTEngine[Version]', QRTE.version);\n\n                    //CHECK IF ATLEAST TWO FORM FIELDS HAVE BEEN DEFINED\n                    this.setChoiceValue(2, 'testtest');\n                    if (this.getChoiceValue(2) !== 'testtest') {\n                        //alert('You need to define two answer form fields in the Exit question!!');\n                    }\n\n                    for (key in QRTE.TDCache) {\n                        if (QRTE.TDCache.hasOwnProperty(key) && key !== '') {\n                            //Change QID thingies to entered ID's, also force every value to a string so that the Parser handles high numerical values correctly\n                            tempTD[QRTE.getOutputKey(key)] = String(QRTE.TDCache[key]);\n                        }\n                    }\n\n                    this.setChoiceValue(1, Object.toJSON(tempTD));\n                    this.setChoiceValue(2, blockId);\n                    if (QRTE.SDCache[QRTE.columnsField][blockId] === undefined) {\n                        QRTE.SDCache[QRTE.columnsField][blockId] = [];\n                    }\n                    for (i = 0; i < QRTE.newlyAddedColumns.length; i += 1) {\n                        QRTE.SDCache[QRTE.columnsField][blockId].push(QRTE.getOutputKey(QRTE.newlyAddedColumns[i]));\n                    }\n\n                    QRTE.setSurveyData(QRTE.columnsField, Object.toJSON(QRTE.SDCache[QRTE.columnsField]));\n                    QRTE.setBlockData('QRTLib_blockCounter', QRTE.getBlockData('QRTLib_blockCounter') + 1);\n                    QRTE.setBlockData('QRTLib_previousStorageDone', window.requestAnimationFrame.now());\n                    QRTE.saveBlockData();\n\n                    //If wanting to test, uncomment this line and comment the one after that to enforce manual nextbutton clicks\n                    //$('NextButton').style.display = 'block';\n                    //QRTE.submitPage();\n                    QRTEController.loadNextTrial();\n                };\n\n                QuestionStackElement = {\n                    questionElement: this,\n                    onShowFunc: onShowFn,\n                    type: 'Storage',\n                    loadConfig: true,\n                    conditional: function() {\n                        return true;\n                    }\n                };\n                QRTE.questionQueue.push(QuestionStackElement);\n\n                QRTE.startTrial(0);\n\n            });\n\n            QRTE.loadWaitingList = [false];\n            if (QRTE.waitForImageLoad === true) {\n                //set wait for image load queues.\n                var loadIndex = 1,\n                    images = $$('.QuestionOuter img'),\n                    i = 0;\n\n                var l = images.length;\n                for (; i < l; i += 1) {\n                    images[i].observe('load', function(e) {\n                        QRTE.startTrial(e.path[0].QRTELoadIndex);\n                    })\n                    images[i].QRTELoadIndex = i + 1;\n                    QRTE.loadWaitingList[i + 1] = false;\n                }\n\n            }\n\n        },\n\n        /**\n         * Remove the padding Qualtrics adds between Questions (causes question presentation to drift downwards if not called).\n         * DEPRECATED: Separators hidden through CSS now\n         * @method removeSeparators\n         * @private\n         */\n        removeSeparators: function() {\n            var questionElement = document.getElementById('Questions'),\n                index;\n            for (index = 0; index < questionElement.children.length; index += 1) {\n                if (questionElement.children[index].className === \"Separator\") {\n                    questionElement.children[index].parentNode.removeChild(questionElement.children[index]);\n                }\n            }\n        },\n        /**\n         * Notifies the engine the first trial is ready to be started. Called at the end of the 'exit' question\n         * @private\n         * @method startTrial\n         */\n        startTrial: function(startId) {\n            var duringDisplayFn, onHideFn, onDisplayFn, serverCommDelay, remainingDelay;\n            //All questions have been hidden, so display the parent block again\n            //$('Questions').style.display = 'block';\n\n            QRTE.loadWaitingList[startId] = true;\n            if (!QRTE.loadWaitingList.every()) {\n                QRTE.log('Process ' + startId + 'finished, waiting for other processes to finish')\n                return;\n            }\n\n            //Save the absolute time of when onLoad part of library was finished\n            serverCommDelay = window.requestAnimationFrame.now() - QRTE.getBlockData('QRTLib_previousEndTime'); //Calculate the remaining time based on the lib initialization + server delay times\n            remainingDelay = QRTE.getBlockData('QRTLib_intraTrialDelay') - serverCommDelay;\n\n\n            if (isNaN(remainingDelay)) {\n                remainingDelay = QRTE.getBlockData('QRTLib_intraTrialDelay') * 3;\n                //If this init call is the first one of the block (first trial), calculate the estimated refreshdelay during the pre-trial interval\n                onDisplayFn = function(ele, time) {\n                    QRTE.setTrialData('Init[OffsetTime]', ele.displayOnsetTime);\n                    QRTE.setTrialData('Init[CalculatedDuration]', ele.displayOnsetTime - QRTE.getTrialData('Init[OnsetTime]'));\n                    QRTE.refreshPeriodEstimationStack = [];\n                };\n                duringDisplayFn = function(ele, time) {\n                    //Get current time, required for \n                    QRTE.refreshPeriodEstimationStack.push(time);\n                };\n                onHideFn = function(ele, timestamp) {\n                    var diffs = [];\n\n                    for (i = 1; i < QRTE.refreshPeriodEstimationStack.length; i += 1) {\n                        diffs[i - 1] = QRTE.refreshPeriodEstimationStack[i] - QRTE.refreshPeriodEstimationStack[i - 1];\n                    }\n                    QRTE.refreshPeriod = QRTE.median(diffs);\n                    QRTE.log('Estimated refresh delay = ' + QRTE.refreshPeriod);\n                    QRTE.setBlockData('QRTE_refreshPeriod', QRTE.refreshPeriod);\n                    QRTE.referenceTime = timestamp;\n                    QRTE.framesSinceReference = 0;\n                };\n            } else {\n                onDisplayFn = function(ele, time) {\n                    QRTE.setTrialData('Init[OffsetTime]', ele.displayOnsetTime);\n                    QRTE.setTrialData('Init[CalculatedDuration]', ele.displayOnsetTime - QRTE.getTrialData('Init[OnsetTime]'));\n                };\n\n                QRTE.refreshPeriod = QRTE.getBlockData('QRTE_refreshPeriod');\n            }\n\n            //QRTE.setTrialData('ITI[Duration]', (remainingDelay > 0) ? remainingDelay : 0);\n            QRTE.initTime = window.requestAnimationFrame.now();\n\n            QRTE.postInitElement.onHideFn = onHideFn;\n            QRTE.postInitElement.onDisplayFn = onDisplayFn;\n            QRTE.postInitElement.duringDisplayFn = duringDisplayFn;\n            QRTE.setConfig('InitPost', 'duration', (remainingDelay > 0) ? remainingDelay : 0);\n            //UNCOMMENT\n            //QRTE.setConfig('InitPost', 'duration', (remainingDelay > 0) ? remainingDelay : Infinity);\n            QRTE.inited = true;\n\n            //Set initial trial data related to loading of this trial\n            QRTE.setTrialData('InitServerComm[Onset]', QRTE.getBlockData('ServerCommOnset'));\n            QRTE.setTrialData('InitServerComm[Offset]', QRTE.getBlockData('ServerCommOffset'));\n            QRTE.setTrialData('InitServerComm[CalculatedDuration]', QRTE.getBlockData('ServerCommOffset') - QRTE.getBlockData('ServerCommOnset'));\n\n            //<Load next trial here>\n            var currentLoops = '${lm://CurrentLoopNumber}',\n                totalLoops = '${lm://TotalLoops}';\n            //Check if last trial, currentloops === totalLoops;\n            QRTEController.requestNextTrial(currentLoops !== '' && currentLoops === totalLoops);\n\n            QRTE.proceed();\n        },\n\n\n\n        proceed: function() {\n            QRTE.log(\"proceed called after \" + window.requestAnimationFrame.now() - QRTE.initTime);\n            QRTE.hideAllElements();\n        },\n\n        proceedPage: function() {\n            var currentQ;\n            QRTE.log(\"Proceeding page..\");\n            while (QRTE.currentPageQuestions.length > 0) {\n                currentQ = QRTE.currentPageQuestions.shift();\n\n                //Disable\n                currentQ.questionElement.QRTLib_isActive = false;\n            }\n\n\n            //Go to next question\n            QRTE.showNextPage();\n        },\n\n        disableQuestion: function(disableQ) {},\n\n        /**\n         * Determine and show the next page/slide\n         * @private\n         * @method showNextPage\n         */\n        showNextPage: function() {\n            var continueSearch = true,\n                shownQ = false,\n                nextQ,\n                shown;\n            while (continueSearch === true) {\n                continueSearch = false;\n                nextQ = QRTE.questionQueue.shift();\n                if (nextQ !== undefined && (nextQ.type === 'Stimulus' || nextQ.type === 'Storage')) {\n                    QRTE.currentPageQuestions.push(nextQ);\n                    shown = QRTE.showStimulusQuestion.apply(nextQ.questionElement, [nextQ]);\n\n                    if (nextQ.stimContinue) {\n                        continueSearch = true;\n                        if (shown === true) {\n                            shownQ = true;\n                        }\n                    }\n                    QRTE.log('shown ' + nextQ.id + ': ' + shown);\n                    QRTE.log('continue ' + nextQ.id + ': ' + continueSearch);\n                    if (shown === false && shownQ === false) {\n                        continueSearch = true;\n                    }\n                }\n            }\n\n        },\n\n        /**\n         * Show Question\n         * Handles the activation of that question, which includes:\n         * The loading of the configuration (duration, allowable keys etc).\n         * Sets the event handler to respond to any key presses during the event.\n         * @private\n         * @method showStimulusQuestion\n         * @param question {Object} question to be shown.\n         *  @param id {String} Id of question.\n         *  @param onShowFunc {Function} Function to be called when showing question\n         *  @param loadConfig {Boolean} If true, config is loaded from the current block data (which has been defined elsewhere)\n         *  @param questionElement {Object} This Qualtrics question element\n         *  @param duringDisplayFn {Function} Function to be called each frame that the question is presented\n         */\n        showStimulusQuestion: function(question) {\n            //Save the loading start time\n            //QRTE.setTrialData(question.questionElement.QRTLibId + '[LoadStartTime]', window.requestAnimationFrame.now());\n            //Set mapping of the QID -> QRTE Id\n            QRTE.setId(this, question.id);\n\n            //Initialize variables\n            var stimulusShown = false,\n                questionScope = this,\n                dispEle;\n            QRTE.log(question);\n\n            //Check whether question should be shown or not, if not skip to the next question (implicitly)\n            if (question.conditional() === true) {\n                this.QRTLib_isActive = true;\n\n\n                if (question.loadConfig === true) {\n                    //Load the Configuration of the Question, important!\n                    QRTE.loadConfig(this);\n                }\n\n                //Check if KeyPress listener is required (one or more of the following fields are defined: onKeyPress, onCorrectKey or onAllowableKey)\n                //If so, add keypress listener.\n                if (question.onKeyPress !== undefined || question.questionElement.allowable !== '' || question.questionElement.cresp !== '') {\n                    //Initialize the fields used for storing data about RT timing.\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[RTTime]', '');\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[RT]', '');\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[RESP]', '');\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[ACC]', 0);\n\n                    //Add the key listener\n                    QRTE.addKeyListener(function(e) {\n\n                        //Get the Key of the response\n                        var RT, RESP = QRTE.keycode2string(e),\n                            RTTime = window.requestAnimationFrame.now();\n                        RT = RTTime - QRTE.getTrialData(question.questionElement.QRTLibId + '[OnsetTime]');\n\n                        //Store the Time of the Key Press and calculate the RT and ACC if correct\n\n                        if ((QRTE.isAllowableResponse(question.questionElement, RESP) || QRTE.isCorrectResponse(question.questionElement, RESP)) && QRTE.getTrialData(question.questionElement.QRTLibId + '[RTTime]') === '') {\n                            QRTE.setTrialData(question.questionElement.QRTLibId + '[RTTime]', RTTime);\n                            QRTE.setTrialData(question.questionElement.QRTLibId + '[RT]', RT);\n                            QRTE.setTrialData(question.questionElement.QRTLibId + '[RESP]', RESP);\n                            if (QRTE.isCorrectResponse(question.questionElement, RESP)) {\n                                QRTE.saveAcc(question.questionElement, 1);\n                            } else {\n                                QRTE.saveAcc(question.questionElement, 0);\n                            }\n                        }\n\n                        //Store the RT and the Response\n\n                        //Set Handling Key Press to true, this lets the engine know that a keypress is currently being handled. Necessary when there is a timer (response deadline)\n                        question.handlingKeyPress = true;\n\n                        if (question.onCorrectKey !== undefined && QRTE.isCorrectResponse(question.questionElement, RESP)) {\n                            question.onCorrectKey.apply(question.questionElement, [e, RESP]);\n                        } else if (question.onIncorrectKey !== undefined && QRTE.isAllowableResponse(question.questionElement, RESP)) {\n                            question.onIncorrectKey.apply(question.questionElement, [e, RESP]);\n                        }\n\n                        if (question.onAllowableKey !== undefined && QRTE.isAllowableResponse(question.questionElement, RESP)) {\n                            question.onAllowableKey.apply(question.questionElement, [e, RESP]);\n                        }\n\n                        if (question.onKeyPress !== undefined) {\n                            question.onKeyPress.apply(question.questionElement, [e, RESP]);\n                        }\n\n                        if (question.questionElement.endAction === 'TERMINATE') {\n                            //Proceed to the next Question Page if the response is allowable\n                            if (QRTE.isAllowableResponse(question.questionElement, RESP) && question.questionElement.QRTLib_isActive === true) {\n                                question.questionElement.proceed();\n                            }\n                        }\n                        question.handlingKeyPress = false;\n\n                    }, this);\n                }\n\n                //Build the display Element. Stimuli Questions have to take into account the possibility of being associated with a key press. \n                //OnDisplayFn therefore logs the displayOnsetTime, so that the RT can be calculated.\n                dispEle = {\n                    el: this.questionContainer,\n                    duration: this.duration,\n                    delay: this.offset,\n                    duringDisplayFn: question.duringDisplayFn,\n                    onDisplayFn: function(displayEl, timestamp) {\n                        if (question.onDisplayFn !== undefined) {\n                            question.onDisplayFn(displayEl, timestamp);\n                        }\n                        QRTE.setTrialData(questionScope.QRTLibId + '[OnsetTime]', displayEl.displayOnsetTime);\n                    },\n                    proceedOnHide: question.proceedOnHide,\n                    id: question.id\n                };\n\n                //Set the OnHide Function\n                dispEle.onHideFn = function(displayEl, timestamp) {\n                    if (question.onHideFn !== undefined) {\n                        question.onHideFn(displayEl, timestamp);\n                    }\n                    QRTE.setTrialData(questionScope.QRTLibId + '[OffsetTime]', displayEl.displayOffsetTime);\n                    QRTE.setTrialData(questionScope.QRTLibId + '[CalculatedDuration]', displayEl.displayDuration);\n                };\n\n\n                this.QRTLib_timer = QRTE.displayElement(dispEle);\n\n                question.onShowFunc.apply(this);\n\n                stimulusShown = true;\n            }\n\n            //QRTE.setTrialData(question.questionElement.QRTLibId + '[LoadEndTime]', window.requestAnimationFrame.now());\n            return stimulusShown;\n        },\n\n        setId: function(question, desc) {\n\n            this.idCache[question.questionId] = desc;\n            question.qId = desc;\n\n            Qualtrics.SurveyEngine.setEmbeddedData(QRTE.idField, Object.toJSON(this.idCache));\n        },\n\n        getOutputKey: function(key) {\n            var oldKey;\n            for (oldKey in this.idCache) {\n                if (this.idCache.hasOwnProperty(oldKey) && oldKey === key.substring(0, oldKey.length)) {\n\n                    return QRTE.getBlockData('QRTLib_currentBlock') + this.idCache[oldKey] + key.substring(oldKey.length, key.length);\n                }\n            }\n            return key;\n        },\n\n\n        OnKeyPress: function(fn, qScope) {\n\n            qScope = qScope || window;\n\n            var keyFn = function(e) {\n                QRTE.setTrialData(qScope.QRTLibId + '[RTTime]', window.requestAnimationFrame.now());\n                var RT = QRTE.getTrialData(qScope.QRTLibId + '[RTTime]') - QRTE.getTrialData(qScope.QRTLibId + '[OnsetTime]');\n                QRTE.setTrialData(qScope.QRTLibId + '[RT]', RT);\n                QRTE.setTrialData(qScope.QRTLibId + '[RESP]', QRTE.keycode2string(e));\n                QRTE.log(qScope);\n                fn.apply(qScope, [e]);\n            }\n\n            QRTE.addKeyListener(keyFn, qScope);\n        },\n\n        addKeyListener: function(fn, listenerScope) {\n            Event.observe(document, 'keypress', function(e) {\n                if (listenerScope.QRTLib_isActive === true) {\n                    fn.apply(listenerScope, [e]);\n                }\n            });\n        },\n\n        /*  \n         **************Methods below this line are support methods*******************\n         */\n\n        hideQuestions: function() {\n            qArray = $('Questions').getElementsByClassName('QuestionOuter');\n            for (var i = 0; i < qArray.length; i += 1) {\n                qArray[i].style.display = 'none';\n            }\n        },\n\n        unhideQuestions: function() {\n            //Redisplay outer questions\n            qArray = $('Questions').getElementsByClassName('QuestionOuter');\n            for (var i = 0; i < qArray.length; i += 1) {\n                qArray[i].style.display = 'block';\n            }\n            //Redisplay separators\n            qArray = $('Questions').getElementsByClassName('Separator');\n            for (var i = 0; i < qArray.length; i += 1) {\n                qArray[i].style.display = 'block';\n            }\n\n\n        },\n\n        _handleKeyPressEvent: function() {\n\n        },\n\n        _setConfig: function(QID, option, value, setterFunc) {\n            var qidString = QID;\n            if (typeof QID !== 'string') {\n                qidString = QID.questionId;\n            }\n            option = option.toLowerCase();\n\n            switch (option) {\n                case 'duration':\n                    if (value instanceof Array) {\n                        value = value[Math.floor(Math.random() * value.length)];\n                    }\n                    setterFunc.apply(this, [qidString, 'Duration', value]);\n                    break;\n                case 'allowable':\n                    setterFunc.apply(this, [qidString, 'Allowable', value]);\n                    break;\n                case 'cresp':\n                    setterFunc.apply(this, [qidString, 'CRESP', value]);\n                    break;\n                case 'delay':\n                    setterFunc.apply(this, [qidString, 'Offset', value]);\n                    break;\n                case 'endaction':\n                    setterFunc.apply(this, [qidString, 'EndAction', value]);\n                    break;\n                default:\n                    QRTE.log('No such configuration: ' + option);\n                    break;\n            }\n        },\n        getDuration: function(question) {\n            var duration = Infinity,\n                edDuration = this.getTrialData(question.QRTLib_configId + '[Duration]');\n            if (edDuration !== undefined && edDuration !== '' && !isNaN(edDuration)) {\n                duration = edDuration;\n            }\n            if (question._Duration !== undefined && question._Duration !== '' && !isNaN(question._Duration)) {\n                duration = question._Duration;\n            }\n\n            return duration;\n        },\n        getAllowable: function(question) {\n            var allowable = \"\",\n                edAllowable = this.getTrialData(question.QRTLib_configId + '[Allowable]');\n            if (edAllowable !== undefined) {\n                allowable = edAllowable;\n            }\n            if (question._Allowable !== undefined) {\n                allowable = question._Allowable;\n            }\n\n            if (allowable === '{ANY}') {\n                allowable = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890-=[]\\\\;',./`\";\n            }\n            //allowable = allowable.toUpperCase();\n            return allowable;\n        },\n        getCResp: function(question) {\n            var cresp = '',\n                edcresp = this.getTrialData(question.QRTLib_configId + '[CRESP]');\n            if (edcresp !== undefined) {\n                cresp = edcresp;\n            }\n            if (question._cresp !== undefined) {\n                cresp = question._CRESP;\n            }\n\n            if (cresp === '{ANY}') {\n                cresp = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890-=[]\\\\;',./`\";\n            }\n            //cresp = cresp.toUpperCase();\n\n            return cresp;\n        },\n\n        getOffset: function(question) {\n            var offset = 0,\n                edOffset = this.getTrialData(question.QRTLib_configId + '[Offset]');\n            if (edOffset !== undefined && edOffset !== '' && !isNaN(edOffset)) {\n                offset = edOffset;\n            }\n            if (question._Offset !== undefined && question._Offset !== '' && !isNaN(question._Offset)) {\n                offset = question._Offset;\n            }\n\n            return offset;\n\n        },\n\n        getEndAction: function(question) {\n            var endAction = 'NONE',\n                edEndAction = this.getTrialData(question.QRTLib_configId + '[EndAction]');\n            if (edEndAction !== undefined && edEndAction !== '') {\n                endAction = edEndAction;\n            }\n            if (question._EndAction !== undefined && question._EndAction !== '') {\n                endAction = question._EndAction;\n            }\n\n            return endAction;\n\n        },\n        evaluateConditional: function(conditional) {\n            QRTE.log('Conditional: ', conditional);\n            return conditional === '' || conditional();\n        },\n        log: function() {\n            if (QRTE.debug === true) {\n                for (var i = 0; i < arguments.length; i += 1) {\n                    console.log(arguments[i]);\n                }\n            }\n        },\n\n        median: function(values) {\n\n            values.sort(function(a, b) {\n                return a - b;\n            });\n\n            var half = Math.floor(values.length / 2);\n\n            if (values.length % 2) return values[half];\n            else return (values[half - 1] + values[half]) / 2.0;\n        },\n\n        waitForKey: function(question, keys) {\n            Event.observe(document, 'keypress', function(e) {\n                var resp = QRTE.keycode2string(e);\n                if (keys.indexOf(resp) >= 0) {\n                    question.clickNextButton();\n                }\n            });\n        },\n\n        validateParams: function(paramObj, validationArray) {\n            var valObj, val, index, typeCheck = true,\n                indexType;\n            //Loop over validationArray to check whether parameters suffice\n            for (index = 0; index < validationArray.length; index += 1) {\n                valObj = validationArray[index];\n                if (paramObj[valObj.name] === undefined && valObj.required === true) {\n                    alert('Required parameter: ' + valObj.name + ' seems to be missing');\n                    QRTE.log('Required parameter: ' + valObj.name + ' seems to be missing');\n                    break;\n                }\n\n                val = paramObj[valObj.name];\n\n                //Loop over type checkers\n                for (indexType = 0; indexType < valObj.type.length; indexType += 1) {\n                    typeCheck = QRTE.validateType(val, valObj.type[indexType]);\n                    if (typeCheck === true) {\n                        break;\n                    }\n                }\n                if (typeCheck === false && valObj.required === true) {\n                    alert('Parameter: ' + valObj.name + ' is of the wrong type, expected type: ' + valObj.type + ', type received: ' + (typeof val) + \"\\n\" + \"Please open the console for detailed error messages\");\n                    QRTE.log('Parameter: ' + valObj.name + ' is of the wrong type, expected type: ' + valObj.type + ', type received: ' + (typeof val));\n                    QRTE.log('Faulty parameter ' + valObj.name + ': ', val);\n                    QRTE.log('Proper functioning of QRTE is no longer guaranteed, please fix the above error');\n                }\n\n            }\n        },\n\n        validateType: function(val, type) {\n            switch (type) {\n                case 'JSON':\n                    return val.isJSON();\n                case 'String':\n                    return (typeof val === 'string' || val instanceof String);\n                case 'Number':\n                    return (!isNaN(parseFloat(val)) && isFinite(val));\n                case 'Array':\n                    return val instanceof Array;\n                case 'Object':\n                    return typeof val === 'object';\n                case 'Function':\n                    return typeof val === 'function';\n                case 'Boolean':\n                    return (val === true || val === false);\n                case 'Empty':\n                    return val === '';\n                default:\n                    return false;\n            }\n        },\n\n        fixSetEmbeddedDataBug: function() {\n            Qualtrics.SurveyEngine.setEmbeddedData = function(key, value) {\n                var fieldName = 'ED~' + key;\n                if ($(fieldName)) {\n                    $(fieldName).value = value;\n                } else {\n                    $('Header').appendChild(QBuilder('input', {\n                        type: 'hidden',\n                        id: fieldName,\n                        name: fieldName,\n                        value: value\n                    }));\n                    Qualtrics.SurveyEngine.setEmbeddedData(key, value);\n                }\n            }\n        },\n\n        //DisplayEngine part\n\n        //Since it's impossible to know when a screen refresh has happened, we assume that the first timestamp is the actual screen refresh.\n        //Based on the difference between the current timestamp Tn and the root timestamp Tn-1, we estimate the amount of frames that have passed since. \n        //Based on the amount of frames we estimate the previous screen refresh. Although not perfect, it's the best we can do.\n\n        refreshRate: 60, //hertz\n        refreshPeriod: 1000 / 60,\n        lastRefresh: 0,\n        currentRefresh: 0,\n        previousTimestamp: 0,\n        referenceTime: 0,\n        framesSinceReference: 0,\n        currentStack: [],\n        proceedOnFrameEnd: false,\n\n        init: function() {\n            window.requestAnimationFrame(QRTE.draw);\n        },\n\n        draw: function(timestamp) {\n            var curEle, newStack = [];\n            timestamp = window.requestAnimationFrame.now();\n\n\n            if (timestamp < 1e12) {\n                timestamp += window.performance.timing.navigationStart;\n            }\n\n            if (QRTE.referenceTime === 0) {\n                QRTE.referenceTime = timestamp;\n                QRTE.previousTimestamp = timestamp;\n                QRTE.framesSinceReference = 0;\n            } else {\n                //QRTE.framesSinceReference += QRTE.calcFrames(QRTE.referenceTime, timestamp);\n                QRTE.prevFrames = QRTE.framesSinceReference;\n                //frameDiff =  QRTE.calcFrames(QRTE.referenceTime, timestamp) - QRTE.prevFrames;\n                QRTE.framesSinceReference = QRTE.calcFrames(QRTE.referenceTime, timestamp);\n            }\n            QRTE.currentRefresh = (QRTE.framesSinceReference * QRTE.refreshPeriod) + QRTE.referenceTime;\n            QRTE.projectedRefresh = QRTE.currentRefresh + QRTE.refreshPeriod;\n            curEle = QRTE.currentStack.shift();\n\n            while (curEle) {\n                curEle.keep = true;\n\n                //Call duringDisplay callback function, with the current element and the timestamp as arguments.\n                if (curEle.shown === true && typeof curEle.duringDisplayFn === 'function') {\n                    curEle.duringDisplayFn(curEle, timestamp);\n                }\n\n                if (QRTE.proceedOnFrameEnd === true || curEle.hide === true || (curEle.shown === true && curEle.displayOnset !== undefined && (curEle.displayOnset + curEle.duration < QRTE.projectedRefresh))) {\n                    //If the next refresh makes it go beyond the duration, hide the element again!\n                    curEle = QRTE.hideSingleEle(curEle, timestamp);\n                } else if (curEle.shown === false && curEle.requestedAt + curEle.delay < QRTE.projectedRefresh) {\n                    curEle = QRTE.dispSingleEle(curEle, timestamp);\n                }\n\n                if (curEle.keep === false && curEle.proceedOnHide === true) {\n                    //Behold! We have found an element that commands us to proceed to the next page.\n                    QRTE.proceedOnFrameEnd = true;\n                    //Every element that has been processed so far needs to be re-processed (sadly), so that they properly hide.\n                    for (var ind = 0; ind < newStack.length; ind += 1) {\n                        if (newStack[ind].hide !== true) {\n                            newStack[ind].hide = true;\n                            QRTE.currentStack.push(newStack[ind]);\n                        }\n                    }\n                } else {\n                    //Push it to the newStack, for it to be processed next time.\n                    newStack.push(curEle);\n                }\n\n                curEle = QRTE.currentStack.shift();\n            }\n            QRTE.currentStack = newStack;\n            QRTE.lastRefresh = QRTE.currentRefresh;\n            QRTE.previousTimestamp = timestamp;\n            window.requestAnimationFrame(QRTE.draw);\n            if ((newStack.length === 0 || QRTE.proceedOnFrameEnd) && QRTE.inited === true) {\n                QRTE.proceedOnFrameEnd = false;\n                QRTE.proceedPage();\n            }\n\n\n        },\n\n        calcFrames: function(previous, current) {\n            var diff = current - previous,\n                frames = 0;\n\n            if (diff < QRTE.refreshPeriod) {\n                frames = 1;\n            } else {\n                frames = Math.floor(diff / QRTE.refreshPeriod);\n                if (diff % QRTE.refreshPeriod >= (QRTE.refreshPeriod * 0.9)) {\n                    frames += 1;\n                }\n            }\n\n            return frames;\n        },\n\n        /**\n         * Display an element for a specified duration with a specified delay. Vsyncs the display duration using requestAnimationFrame (if possible in the browser)\n         * and allows for high-precision control over its duration. Please start any custom attributes for the paramObj with the 'custom_' header, to avoid collisions.\n         * @private\n         * @method displayElement\n         * @param paramObj {Object}\n         *  @param el {Object} HTML element to be displayed\n         *  @param [onHideFn] {Function} Function to be called upon removing the element from display, is passed one argument containing all information about the display element.\n         *  @param [duration] {Number} Number of milliseconds (ms) the element should be displayed.\n         *  @param [delay] {Number} Number of milliseconds (ms) the Engine should wait before displaying the element.\n         *  @param [duringDisplayFn] {Function} Function to be called upon displaying the element for another screen refresh. Careful: Keep this function simple, could seriously hamper performance as it's called about every 16-17 ms.  is passed one argument containing all information about the display element.\n         *  @param [onDisplayfn] {Function} Function to be called upon starting to display the element. Is passed one argument containing all information about the display element.\n         */\n\n        //displayElement: function(el, callback, duration, offset, duringDisplaycb) {\n        displayElement: function(paramObj) {\n            var reqAt,\n                id = String(Math.random());\n            //QRTE.log(arguments);\n            if (paramObj.delay === undefined) {\n                paramObj.delay = 0;\n            }\n\n\n\n            if (paramObj.duration === undefined) {\n                paramObj = Infinity;\n            }\n\n            if (isNaN(QRTE.lastRefresh)) {\n                reqAt = window.requestAnimationFrame.now();\n            } else {\n                reqAt = QRTE.lastRefresh;\n            }\n            paramObj.userId = paramObj.id;\n            paramObj.id = id;\n            paramObj.shown = false;\n            paramObj.requestedAt = reqAt;\n            paramObj.hide = false;\n\n            QRTE.currentStack.push(paramObj);\n            if (paramObj.delay === 0) {\n                //This element needs to be displayed as soon as possible\n                QRTE.dispSingleEle(paramObj, QRTE.previousTimestamp);\n            }\n            QRTE.log('Added element to display stack:', paramObj);\n            //console.log('paramObj: ', paramObj.userId, ', duration: ', paramObj.duration);\n\n            return id;\n        },\n\n        hideElement: function(id) {\n            var found = false,\n                i;\n            for (i = 0; i < QRTE.currentStack.length; i += 1) {\n                if (QRTE.currentStack[i].id === id) {\n                    found = true;\n                    QRTE.currentStack[i].hide = true;\n                    this.log('Element to be hidden: ', QRTE.currentStack[i]);\n                }\n            }\n            return found;\n        },\n\n        hideAllElements: function() {\n            for (i = 0; i < QRTE.currentStack.length; i += 1) {\n                QRTE.currentStack[i].hide = true;\n            }\n            QRTE.proceedOnFrameEnd = true;\n        },\n\n        /**\n         * Hide a DrawEngine Element\n         * @private\n         * @method hideSingleEle\n         * @param curEle {Object}\n         */\n        hideSingleEle: function(curEle, timestamp) {\n            curEle.displayOffset = QRTE.projectedRefresh;\n            curEle.displayOffsetTime = window.requestAnimationFrame.now();\n            curEle.el.style.display = 'none';\n            curEle.keep = false;\n            curEle.hide = true;\n            //delete QRTE.currentStack[key];\n            curEle.displayDuration = curEle.displayOffsetTime - curEle.displayOnsetTime;\n            if (curEle.onHideFn !== undefined) {\n                curEle.onHideFn(curEle, timestamp);\n            }\n\n            return curEle;\n\n        },\n\n\n        /**\n         * Display a DrawEngine Element\n         * @private\n         * @method dispSingleEle\n         * @param curEle {Object}\n         */\n        dispSingleEle: function(curEle, timestamp) {\n            curEle.el.style.display = 'block';\n            curEle.displayOnset = QRTE.projectedRefresh;\n            curEle.displayOnsetTime = window.requestAnimationFrame.now();\n            curEle.shown = true;\n            if (curEle.onDisplayFn !== undefined) {\n                //Added try-catch block to catch the error that's causing the OnsetTime not to get saved.\n                try {\n                    curEle.onDisplayFn(curEle, timestamp);\n                } catch (e) {\n                    QRTE.setTrialData('Error[OnsetError]', JSON.stringify(e));\n                }\n            }\n            return curEle;\n        },\n\n        checkEngineCompatibility: function() {\n            return window.requestAnimationFrame.method === 'native-highres';\n        },\n    };","\n    /* ==========================================================\n     * QRTEngine.js v16\n     * =====================\n    /* ==========================================================\n     * QRTEngine.js v16\n     * ==========================================================\n     * Copyright 2013-2014 Erwin Haasnoot\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     * http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     *\n     *\n     *\n     * ========================================================== */\n    /**\n     * Qualtrics Reaction Time Engine or QRTE is an add-on providing an interface\n     * for easy reaction time experiment creation in the Qualtrics survey research suite (tm).\n     * For instructions on how to use this add-on, see xxxx\n     *\n     * QRTE was developed by Erwin Haasnoot\n     * Email: erwinhaasnoot[at]gmail.com\n     * @class QRTE\n     *\n     */\n    var QRTE = {\n        version: 'v16',\n        columnsField: 'QRTE_columns',\n        blockDataField: 'QRTE_blockData',\n        idField: 'QRTE_idData',\n        exitQuestions: 'QRTE_exitQuestions',\n        inited: false,\n        /**\n         * TDCache contains the Trial-Level Data in an Object. DO NOT directly manipulate this Object. It might cause inconsistencies in the data file and cause unexpected once parsed.\n         * Use QRTE.setTrialData and QRTE.getTrialData instead.\n         *\n         * @property TDCache\n         * @private\n         * @type Object\n         */\n        TDCache: {},\n\n        /**\n         * ColumnCache contains all the mappings from QID to Columns\n         * @property columnCache\n         * @private\n         * @type Object\n         */\n        columnCache: {},\n\n        /**\n         * BDCache contains the BlockLevel Data in an Object. Directly manipulating this Object might cause inconsistencies\n         * @property BDCache\n         * @private\n         * @type Object\n         */\n        BDCache: {},\n\n        /**\n         * SDCache is a cache for speeding up retrieval of Survey level Data,\n         * All Survey data is saved to both Embedded Data and Survey Data\n         * @private\n         * @property SDCache\n         * @type Object\n         */\n        SDCache: {},\n\n        /**\n         * idCache is a cache for quickly retrieving the Qualtrics QID to QRTLib Id mappings.\n         * Saved in the idData embedded data field after every trial.\n         * @private\n         * @property idCache\n         * @type Object\n         */\n        idCache: {},\n\n        /**\n         * questionQueue contains Objects (stimuli) that are waiting to be presented\n         * @private\n         * @property questionQueue\n         * @type Array\n         */\n        questionQueue: [],\n\n        /**\n         * currentPageQuestions contains the Question Objects that are\n         * displayed at any given time.\n         * @private\n         * @property currentPageQuestions\n         * @type Array\n         */\n        currentPageQuestions: [],\n\n        /**\n         * Contains Trial Data Columns that were 'newly' added in this trial run.\n         * @private\n         * @property newlyAddedColumns\n         * @type Array\n         */\n        newlyAddedColumns: [],\n\n        /**\n         * Contains the Post-Initialization Element.\n         * @private\n         * @property postInitElement\n         * @type Object\n         */\n        postInitElement: {},\n\n        /**\n         * Setter function for Trial-Level Data.\n         * @method setTrialData\n         * @param key {String} Key\n         * @param value {Value} Value\n         */\n        setTrialData: function(key, value) {\n            //Store value in trial cache\n            this.TDCache[key] = value;\n            if (this.BDCache.QRTLib_trialColumns[key] === undefined) {\n                //Add column to overall trial data\n                this.BDCache.QRTLib_trialColumns[key] = '';\n                this.newlyAddedColumns.push(key);\n            }\n        },\n\n        /**\n         * Gets the value of Trial-Level Data field 'key\n         * @method getTrialData\n         * @param key {String} Key\n         */\n        getTrialData: function(key) {\n            return this.TDCache[key];\n        },\n\n        /**\n         * Setter function for Block-Level Data.\n         * @method setBlockData\n         * @param key {String} Key\n         * @param value {Value} Value\n         */\n        setBlockData: function(key, value) {\n            this.BDCache[key] = value;\n        },\n\n\n        /**\n         * Gets the value of Block-Level Data field 'key\n         * @method getBlockData\n         * @param key {String} Key\n         */\n        getBlockData: function(key) {\n            return this.BDCache[key];\n        },\n\n\n\n\n        /**\n         * Stringify the Block Data and store it in the Embedded Data Field. This preserves the values stored on Block Level for use in later trials\n         * @method saveBlockData\n         * @param key {String} Key\n         */\n        saveBlockData: function() {\n            //Store blockData in ED so that we can use it next trial\n            QRTEController.storeBlockData(QRTE.BDCache);\n            Qualtrics.SurveyEngine.setEmbeddedData(QRTE.blockDataField, Object.toJSON(QRTE.BDCache));\n        },\n\n\n\n        /**\n         * Setter function for Survey-Level Data (Embedded Data).\n         * @method setSurveyData\n         * @param key {String} Key\n         * @param value {Value} Value\n         */\n        setSurveyData: function(key, value) {\n            this.SDCache[key] = value;\n            Qualtrics.SurveyEngine.setEmbeddedData(key, value);\n        },\n\n\n\n        /**\n         * Gets the value of Survey-Level Data (Embedded Data) 'key'\n         * @method getSurveyData\n         * @param key {String} Key\n         */\n\n        getSurveyData: function(key) {\n            if (this.SDCache[key] !== undefined) {\n                return this.SDCache[key];\n            }\n            //This only works if the Survey Data has been set during the same trial due to a bug in Qualtrics.\n            return Qualtrics.SurveyEngine.getEmbeddedData(key);\n        },\n\n        /**\n         * Sets a configuration for a question\n         * @method setConfig\n         * @param QID {String} The QRTE Question Id of the Question you want the configuration to apply to\n         * @param option {String} The type of configuration you want to set, Allowed options: 'cresp', 'allowable', 'duration', 'endaction', 'delay'. Refer to website for documentation on these configs\n         * @param value {String} The value the configuration needs to be set to. Differs per option.\n         */\n        setConfig: function(QID, option, value) {\n            var setterFunc;\n            if (typeof QID === 'string') {\n                setterFunc = function(QID, option, value) {\n                    this.setTrialData(QID + \"[\" + option + \"]\", value);\n                };\n            } else {\n                setterFunc = function(QID, option, value) {\n                    this.setTrialData(QID.questionId + \"[\" + option + \"]\", value);\n                    QID['_' + option] = value;\n                };\n\n            }\n\n            this._setConfig(QID, option, value, setterFunc);\n        },\n\n\n        /**\n         * Loads the configuration for a question.\n         * @private\n         * @method loadConfig\n         * @param question {Object} Question for which the configuration needs to be loaded.\n         */\n        loadConfig: function(question) {\n            if (this.idCache[question.questionId] !== undefined) {\n                question.QRTLib_configId = this.idCache[question.questionId];\n            } else {\n                question.QRTLib_configId = question.question;\n            }\n            question.duration = this.getDuration(question);\n            question.allowable = this.getAllowable(question);\n            question.cresp = this.getCResp(question);\n            question.offset = this.getOffset(question);\n            question.endAction = this.getEndAction(question);\n        },\n\n        /**\n         * Stores the accuracy of a trial\n         * @private\n         * @method saveAcc\n         * @param question {Object} Question for which accuracy needs to be stored\n         * @param acc {Integer} Accuracy of question\n         */\n\n        saveAcc: function(question, acc) {\n            if (acc === 0 || acc === 1) {\n                this.setTrialData(question.QRTLibId + \"[ACC]\", acc);\n                this.setSurveyData(\"ACC\", acc);\n            }\n        },\n\n\n\n        /**\n         * Check whether the given response was a correct response\n         * @method isCorrectResponse\n         * @param question {Object} Question for which correct response needs to be checked\n         * @param resp {String} Given response\n         */\n        isCorrectResponse: function(question, resp) {\n            return question.cresp.indexOf(resp) >= 0;\n        },\n\n        /**\n         * Check whether the given response was an allowable response\n         * @method isAllowableResponse\n         * @param question {Object} Question for which allowable response needs to be checked\n         * @param resp {String} Given response\n         */\n        isAllowableResponse: function(question, resp) {\n            return question.allowable.indexOf(resp) >= 0;\n        },\n\n\n\n        /**\n         * Check whether the given response was an allowable response\n         * @private\n         * @method keycode2string\n         * @param e {Object} KeyPress event from which to retrieve the response\n         */\n        keycode2string: function(e) {\n            return String.fromCharCode(e.charCode);\n        },\n\n        /** \n         * Wait for images to load before starting trial.\n         * @property waitForImageLoad\n         * @private\n         * @type Boolean\n         */\n\n        waitForImageLoad: true,\n\n        /** \n         * Trial Start waiting list - initialised with waiting for TrialStart\n         * @property loadWaitingList\n         * @private\n         * @type Array\n         */\n\n        loadWaitingList: [false],\n\n        /**\n         * Initializes the Engine, called at the start of the 'Init' question.\n         * @private\n         * @method initLib\n         * @param blockDataString {String} JSON string containing information saved for this block (block-level data)\n         * @param blockId {String} Id of the current block\n         * @param columns {String} JSON string containing information about the columns that have been defined in this block\n         * @param idData {String} JSON string containing information about the mapping of the QID to the name of the question\n         * @param exitQuestions {String} String containing the currently defined QuestionTags of the Exit questions\n         * @param exitItemTag {String} String containing the Tag of this block's Exit question.\n         */\n\n\n        initLib: function(blockDataString, blockId, columns, idData, exitQuestions, exitItemTag) {\n            //var blockDataString = Qualtrics.SurveyEngine.getEmbeddedData(QRTE.blockDataField),\n            //columns = Qualtrics.SurveyEngine.getEmbeddedData(QRTE.columnsField),\n            //idData = Qualtrics.SurveyEngine.getEmbeddedData(QRTE.idField);\n            var glue;\n            QRTE.fixSetEmbeddedDataBug();\n            //Initialise block Data\n            if (blockDataString === undefined columnData || blockDataString === '') {\n                blockDataString = '{}';\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.blockDataField, blockDataString);\n            }\n\n            this.BDCache = QRTEController.loadBlockData(blockDataString);\n\n            if (this.BDCache.QRTLib_currentBlock !== blockId) {\n                //If this is a new block, initialise a new block\n                this.BDCache = {\n                    QRTLib_currentBlock: blockId,\n                    QRTLib_blockCounter: 1,\n                    QRTLib_trialColumns: {}\n                };\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.blockDataField, Object.toJSON(this.BDCache));\n                if (exitQuestions === null) {exitQuestions = '';}\n                glue = '';\n                if (exitQuestions !== '') {\n                    glue = ';';\n                }\n                //And update the exit questions\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.exitQuestions, exitQuestions + glue + exitItemTag);\n\n            }\n            QRTE.TDCache = Object.toJSON(QRTE.getBlockData('QRTLib_trialColumns')).evalJSON();\n            if (columns === undefined || columns === null || columns === '') {\n                columns = '{}';\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.columnsField, columns);\n            }\n            QRTE.SDCache[QRTE.columnsField] = columns.evalJSON();\n            if (idData === undefined || idData === null || idData === '') {\n                idData = '{}';\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.idField, idData);\n            }\n            QRTE.idCache = idData.evalJSON();\n        },\n\n        /**\n         * Init initializes the QRTEngine, expects are params object with possible fields defined with parameters.\n         * @method Init\n         * @param paramObj {Object} object containing parameters of Init function\n         *  @param paramObj.blockData {String} blockData string in json format (from embedded data)\n         *  @param paramObj.columnData {String} columnData string in json format (from embedded data)\n         *  @param paramObj.exitQuestions {String} exitQuestions string (from embedded data)\n         *  @param paramObj.exitItemTag {String} Tag of the Exit question of this block\n         *  @param paramObj.blockId {String} Identificaton of the block\n         *  @param [paramObj.onLoadFn] {Function} Function to be called when this Question is displayed\n         *  @param [paramObj.interTrialDelay] {Integer|Array} Specify millisecond delay between end of previous trial and beginning of new trial\n         *  @param [paramObj.preTrialDelay] {Integer|Array} Specify millisecond (ms) delay before the start of the first trial of the block. //NYI\n         *  @param [paramObj.initQuestionIndex] {Integer} Specify index of the Init question in the Question Block (defaults to 1)\n         *  @param [paramObj.waitForImages] {Boolean} Specify whether we should wait for images or not. Is on by default, but could be turned off if all images are pre-loaded in cache, or are very small in general.\n         */\n        Init: function(paramObj) {\n            var validationArray, qArray, initIndex;\n            //init the library\n            QRTE.init();\n\n            //set the initIndex (if the Init question is not the first question of the block)\n            QRTE.initIndex = paramObj.initQuestionIndex - 1 || 0;\n\n\n            validationArray = [{\n                name: 'blockData',\n                type: ['JSON', 'Empty'],\n                required: true\n            }, {\n                name: 'columnData',\n                type: ['JSON', 'Empty'],\n                required: true\n            }, {\n                name: 'idData',\n                type: ['JSON', 'Empty'],\n                required: true\n            }, {\n                name: 'blockId',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'onLoadFn',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'interTrialDelay',\n                type: ['Integer', 'Array'],\n                required: false\n            }, {\n                name: 'exitQuestions',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'exitItemTag',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'waitForImages',\n                type: ['Boolean'],\n                required: false\n            }];\n\n            //Validate Parameter Object, outputs stuff to console\n            QRTE.validateParams(paramObj, validationArray, 'Init');\n\n\n            //Initialize the library itself (necessary for each trial)\n            QRTE.initLib(paramObj.blockData, paramObj.blockId, paramObj.columnData, paramObj.idData, paramObj.exitQuestions, paramObj.exitItemTag);\n\n\n            if (paramObj.waitForImages !== undefined) {\n                QRTE.waitForImageLoad = paramObj.waitForImages;\n            }\n            //calculate server communication delay\n            QRTE.setTrialData('InitPre[OnsetTime]', QRTE.getBlockData('QRTLib_previousStorageDone'));\n\n            QRTE.setTrialData('InitPre[OffsetTime]', window.requestAnimationFrame.now());\n            QRTE.setTrialData('InitPre[CalculatedDuration]', QRTE.getTrialData('InitPre[OffsetTime]') - QRTE.getTrialData('InitPre[OnsetTime]'));\n            QRTE.setTrialData('Init[OnsetTime]', window.requestAnimationFrame.now());\n\n\n\n            Qualtrics.SurveyEngine.addOnload(function() {\n                this.qHTML = document.getElementById(this.questionId);\n                this.QRTLib_isActive = false;\n                this.hideChoices();\n                this.proceed = QRTE.proceed;\n                this.QRTLibId = 'InitPost';\n\n                paramObj.onLoadFn.apply(this);\n                var QuestionStackElement = {\n                    questionElement: this,\n                    onShowFunc: function() {},\n                    type: 'Stimulus',\n                    loadConfig: true,\n                    id: 'InitPost',\n                    conditional: function() {\n                        return true;\n                    },\n                    proceedOnHide: true\n\n                };\n                QRTE.setConfig(QuestionStackElement.id, 'duration', 0);\n                QRTE.postInitElement = QuestionStackElement;\n                QRTE.questionQueue.push(QuestionStackElement);\n            });\n\n            if (paramObj.interTrialDelay instanceof Array) {\n                paramObj.interTrialDelay = paramObj.interTrialDelay[Math.floor(Math.random() * paramObj.interTrialDelay.length)];\n            }\n            QRTE.setTrialData(paramObj.blockId + '[InterTrialDelay]', paramObj.interTrialDelay);\n            if (paramObj.interTrialDelay > 0) {\n                QRTE.setBlockData('QRTLib_intraTrialDelay', paramObj.interTrialDelay);\n            } else {\n                QRTE.setBlockData('QRTLib_intraTrialDelay', -1);\n            }\n        },\n\n        /**\n         * Create a Stimulus question\n         * @method Stimulus\n         * @param paramObj {Object}\n         *  @param paramObj.id {String} Id of the Question\n         *  @param paramObj.onShowFn {Function} Function to be called upon showing the question (not the same as upon loading)\n         *  @param [paramObj.conditional] {Function} Function to be called with which to decide whether to present this question or not, should return a boolean.\n         *  @param [paramObj.loadConfig] {Boolean} Load predefined config for this question (defaults to true)\n         *  @param [paramObj.stimContinue] {Boolean} Continue looking for stimuli after having seen this one, only if set to true (defaults to false)\n         *  @param [paramObj.onKeyPress] {Function} Function to be called upon receiving a key press while this Question is active (called next to onAllowableKey or onCorrectKey)\n         *  @param [paramObj.onAllowableKey] {Function} Function to be called upon receiving a key press on a key defined as 'allowable' \n         *  @param [paramObj.onCorrectKey] {Function} Function to be called upon receiving a key press on a key defined as 'correct'\n         *  @param [paramObj.onIncorrectKey] {Function} Function to be called upon receiving an allowable key that is not defined as correct (only if correct responses are defined)\n         *  @param [paramObj.proceedOnHide] {Boolean} Set whether all currently displayed elements should be removed on hide, or if only this should be removed from display (Defaults to True). This allows the user to decouple presentation of a stimulus from proceeding of a slide.\n         *  @param [paramObj.onHideFn] {Function} Function to be called upon Stimulus being hidden\n         *  @param [paramObj.duringDisplayFn] {Function} Function to be called during each frame that the Stimulus is being displayed\n         \n         */\n        Stimulus: function(paramObj) {\n            var validationArray = [{\n                name: 'id',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'onShowFn',\n                type: ['Function'],\n                required: true\n            }, {\n                name: 'conditional',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'loadConfig',\n                type: ['Boolean'],\n                required: false\n            }, {\n                name: 'duringDisplayFn',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'continue',\n                type: ['Boolean'],\n                required: false\n            }, {\n                name: 'onAllowableKey',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'onCorrectKey',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'onKeyPress',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'onIncorrectKey',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'proceedOnHide',\n                type: ['Boolean'],\n                required: false\n            }, {\n                name: 'onHideFn',\n                type: ['Function'],\n                required: false\n            }];\n\n            //Validate Parameter Object, outputs stuff to console\n            QRTE.validateParams(paramObj, validationArray, 'Stimulus');\n\n\n            if (paramObj.conditional === undefined) {\n                paramObj.conditional = function() {\n                    return true;\n                };\n            }\n            if (paramObj.loadConfig === undefined) {\n                paramObj.loadConfig = true;\n            }\n\n            if (paramObj.stimContinue === undefined) {\n                paramObj.stimContinue = false;\n            }\n\n            if (paramObj.proceedOnHide === undefined) {\n                paramObj.proceedOnHide = true;\n            }\n            Qualtrics.SurveyEngine.addOnload(function() {\n                this.QRTLib_isActive = false;\n                this.proceed = QRTE.proceed;\n                this.QRTLibId = paramObj.id;\n                var QuestionStackElement = {\n                    questionElement: this,\n                    onShowFunc: paramObj.onShowFn,\n                    duringDisplayFn: paramObj.duringDisplayFn,\n                    onHideFn: paramObj.onHideFn,\n                    type: 'Stimulus',\n                    loadConfig: paramObj.loadConfig,\n                    id: paramObj.id,\n                    conditional: paramObj.conditional,\n                    stimContinue: paramObj.stimContinue,\n                    onAllowableKey: paramObj.onAllowableKey,\n                    onCorrectKey: paramObj.onCorrectKey,\n                    onKeyPress: paramObj.onKeyPress,\n                    onIncorrectKey: paramObj.onIncorrectKey,\n                    proceedOnHide: paramObj.proceedOnHide\n                };\n                QRTE.questionQueue.push(QuestionStackElement);\n            });\n        },\n\n        /**\n         * Exit denotes the end of the block. Important for the initialization phase and the exit phase.\n         * Make the question a Form question with precisely 2 answer fields (more is unnecessary, those will get ignored)\n         * @method Exit\n         */\n        Exit: function() {\n\n\n            qArray = $('Questions').getElementsByClassName('QuestionOuter');\n            for (var i = 0; i < qArray.length && i < QRTE.initIndex + 1; i += 1) {\n                qArray[i].style.display = 'block';\n            }\n            Qualtrics.SurveyEngine.addOnload(function() {\n                //Hide all choice\n                this.hideChoices();\n                //display the question\n                //this.questionContainer.style.display = 'none';\n                var QuestionStackElement, onShowFn;\n                onShowFn = function() {\n\n                    //Create and/or store standard information about the trial\n                    var blockId = QRTE.getBlockData('QRTLib_currentBlock'),\n                        tempTD = {},\n                        key,\n                        i;\n\n                    QRTE.setBlockData('QRTLib_previousEndTime', window.requestAnimationFrame.now());\n                    QRTE.setTrialData(blockId + '[TrialNr]', QRTE.getBlockData('QRTLib_blockCounter'));\n                    QRTE.setTrialData(blockId + '[RefreshPeriod]', QRTE.refreshPeriod);\n                    QRTE.setTrialData('BlockId', blockId);\n                    QRTE.setTrialData('EngineType', window.requestAnimationFrame.method);\n                    QRTE.setTrialData('Exit[OnsetTime]', window.requestAnimationFrame.now());\n                    QRTE.setTrialData('QRTEngine[Version]', QRTE.version);\n\n                    //CHECK IF ATLEAST TWO FORM FIELDS HAVE BEEN DEFINED\n                    this.setChoiceValue(2, 'testtest');\n                    if (this.getChoiceValue(2) !== 'testtest') {\n                        //alert('You need to define two answer form fields in the Exit question!!');\n                    }\n\n                    for (key in QRTE.TDCache) {\n                        if (QRTE.TDCache.hasOwnProperty(key) && key !== '') {\n                            //Change QID thingies to entered ID's, also force every value to a string so that the Parser handles high numerical values correctly\n                            tempTD[QRTE.getOutputKey(key)] = String(QRTE.TDCache[key]);\n                        }\n                    }\n\n                    this.setChoiceValue(1, Object.toJSON(tempTD));\n                    this.setChoiceValue(2, blockId);\n                    if (QRTE.SDCache[QRTE.columnsField][blockId] === undefined) {\n                        QRTE.SDCache[QRTE.columnsField][blockId] = [];\n                    }\n                    for (i = 0; i < QRTE.newlyAddedColumns.length; i += 1) {\n                        QRTE.SDCache[QRTE.columnsField][blockId].push(QRTE.getOutputKey(QRTE.newlyAddedColumns[i]));\n                    }\n\n                    QRTE.setSurveyData(QRTE.columnsField, Object.toJSON(QRTE.SDCache[QRTE.columnsField]));\n                    QRTE.setBlockData('QRTLib_blockCounter', QRTE.getBlockData('QRTLib_blockCounter') + 1);\n                    QRTE.setBlockData('QRTLib_previousStorageDone', window.requestAnimationFrame.now());\n                    QRTE.saveBlockData();\n\n                    //If wanting to test, uncomment this line and comment the one after that to enforce manual nextbutton clicks\n                    //$('NextButton').style.display = 'block';\n                    //QRTE.submitPage();\n                    QRTEController.loadNextTrial();\n                };\n\n                QuestionStackElement = {\n                    questionElement: this,\n                    onShowFunc: onShowFn,\n                    type: 'Storage',\n                    loadConfig: true,\n                    conditional: function() {\n                        return true;\n                    }\n                };\n                QRTE.questionQueue.push(QuestionStackElement);\n\n                QRTE.startTrial(0);\n\n            });\n\n            QRTE.loadWaitingList = [false];\n            if (QRTE.waitForImageLoad === true) {\n                //set wait for image load queues.\n                var loadIndex = 1,\n                    images = $$('.QuestionOuter img'),\n                    i = 0;\n\n                var l = images.length;\n                for (; i < l; i += 1) {\n                    images[i].observe('load', function(e) {\n                        QRTE.startTrial(e.path[0].QRTELoadIndex);\n                    })\n                    images[i].QRTELoadIndex = i + 1;\n                    QRTE.loadWaitingList[i + 1] = false;\n                }\n\n            }\n\n        },\n\n        /**\n         * Remove the padding Qualtrics adds between Questions (causes question presentation to drift downwards if not called).\n         * DEPRECATED: Separators hidden through CSS now\n         * @method removeSeparators\n         * @private\n         */\n        removeSeparators: function() {\n            var questionElement = document.getElementById('Questions'),\n                index;\n            for (index = 0; index < questionElement.children.length; index += 1) {\n                if (questionElement.children[index].className === \"Separator\") {\n                    questionElement.children[index].parentNode.removeChild(questionElement.children[index]);\n                }\n            }\n        },\n        /**\n         * Notifies the engine the first trial is ready to be started. Called at the end of the 'exit' question\n         * @private\n         * @method startTrial\n         */\n        startTrial: function(startId) {\n            var duringDisplayFn, onHideFn, onDisplayFn, serverCommDelay, remainingDelay;\n            //All questions have been hidden, so display the parent block again\n            //$('Questions').style.display = 'block';\n\n            QRTE.loadWaitingList[startId] = true;\n            if (!QRTE.loadWaitingList.every()) {\n                QRTE.log('Process ' + startId + 'finished, waiting for other processes to finish')\n                return;\n            }\n\n            //Save the absolute time of when onLoad part of library was finished\n            serverCommDelay = window.requestAnimationFrame.now() - QRTE.getBlockData('QRTLib_previousEndTime'); //Calculate the remaining time based on the lib initialization + server delay times\n            remainingDelay = QRTE.getBlockData('QRTLib_intraTrialDelay') - serverCommDelay;\n\n\n            if (isNaN(remainingDelay)) {\n                remainingDelay = QRTE.getBlockData('QRTLib_intraTrialDelay') * 3;\n                //If this init call is the first one of the block (first trial), calculate the estimated refreshdelay during the pre-trial interval\n                onDisplayFn = function(ele, time) {\n                    QRTE.setTrialData('Init[OffsetTime]', ele.displayOnsetTime);\n                    QRTE.setTrialData('Init[CalculatedDuration]', ele.displayOnsetTime - QRTE.getTrialData('Init[OnsetTime]'));\n                    QRTE.refreshPeriodEstimationStack = [];\n                };\n                duringDisplayFn = function(ele, time) {\n                    //Get current time, required for \n                    QRTE.refreshPeriodEstimationStack.push(time);\n                };\n                onHideFn = function(ele, timestamp) {\n                    var diffs = [];\n\n                    for (i = 1; i < QRTE.refreshPeriodEstimationStack.length; i += 1) {\n                        diffs[i - 1] = QRTE.refreshPeriodEstimationStack[i] - QRTE.refreshPeriodEstimationStack[i - 1];\n                    }\n                    QRTE.refreshPeriod = QRTE.median(diffs);\n                    QRTE.log('Estimated refresh delay = ' + QRTE.refreshPeriod);\n                    QRTE.setBlockData('QRTE_refreshPeriod', QRTE.refreshPeriod);\n                    QRTE.referenceTime = timestamp;\n                    QRTE.framesSinceReference = 0;\n                };\n            } else {\n                onDisplayFn = function(ele, time) {\n                    QRTE.setTrialData('Init[OffsetTime]', ele.displayOnsetTime);\n                    QRTE.setTrialData('Init[CalculatedDuration]', ele.displayOnsetTime - QRTE.getTrialData('Init[OnsetTime]'));\n                };\n\n                QRTE.refreshPeriod = QRTE.getBlockData('QRTE_refreshPeriod');\n            }\n\n            //QRTE.setTrialData('ITI[Duration]', (remainingDelay > 0) ? remainingDelay : 0);\n            QRTE.initTime = window.requestAnimationFrame.now();\n\n            QRTE.postInitElement.onHideFn = onHideFn;\n            QRTE.postInitElement.onDisplayFn = onDisplayFn;\n            QRTE.postInitElement.duringDisplayFn = duringDisplayFn;\n            QRTE.setConfig('InitPost', 'duration', (remainingDelay > 0) ? remainingDelay : 0);\n            //UNCOMMENT\n            //QRTE.setConfig('InitPost', 'duration', (remainingDelay > 0) ? remainingDelay : Infinity);\n            QRTE.inited = true;\n\n            //Set initial trial data related to loading of this trial\n            QRTE.setTrialData('InitServerComm[Onset]', QRTE.getBlockData('ServerCommOnset'));\n            QRTE.setTrialData('InitServerComm[Offset]', QRTE.getBlockData('ServerCommOffset'));\n            QRTE.setTrialData('InitServerComm[CalculatedDuration]', QRTE.getBlockData('ServerCommOffset') - QRTE.getBlockData('ServerCommOnset'));\n\n            //<Load next trial here>\n            var currentLoops = '${lm://CurrentLoopNumber}',\n                totalLoops = '${lm://TotalLoops}';\n            //Check if last trial, currentloops === totalLoops;\n            QRTEController.requestNextTrial(currentLoops !== '' && currentLoops === totalLoops);\n\n            QRTE.proceed();\n        },\n\n\n\n        proceed: function() {\n            QRTE.log(\"proceed called after \" + window.requestAnimationFrame.now() - QRTE.initTime);\n            QRTE.hideAllElements();\n        },\n\n        proceedPage: function() {\n            var currentQ;\n            QRTE.log(\"Proceeding page..\");\n            while (QRTE.currentPageQuestions.length > 0) {\n                currentQ = QRTE.currentPageQuestions.shift();\n\n                //Disable\n                currentQ.questionElement.QRTLib_isActive = false;\n            }\n\n\n            //Go to next question\n            QRTE.showNextPage();\n        },\n\n        disableQuestion: function(disableQ) {},\n\n        /**\n         * Determine and show the next page/slide\n         * @private\n         * @method showNextPage\n         */\n        showNextPage: function() {\n            var continueSearch = true,\n                shownQ = false,\n                nextQ,\n                shown;\n            while (continueSearch === true) {\n                continueSearch = false;\n                nextQ = QRTE.questionQueue.shift();\n                if (nextQ !== undefined && (nextQ.type === 'Stimulus' || nextQ.type === 'Storage')) {\n                    QRTE.currentPageQuestions.push(nextQ);\n                    shown = QRTE.showStimulusQuestion.apply(nextQ.questionElement, [nextQ]);\n\n                    if (nextQ.stimContinue) {\n                        continueSearch = true;\n                        if (shown === true) {\n                            shownQ = true;\n                        }\n                    }\n                    QRTE.log('shown ' + nextQ.id + ': ' + shown);\n                    QRTE.log('continue ' + nextQ.id + ': ' + continueSearch);\n                    if (shown === false && shownQ === false) {\n                        continueSearch = true;\n                    }\n                }\n            }\n\n        },\n\n        /**\n         * Show Question\n         * Handles the activation of that question, which includes:\n         * The loading of the configuration (duration, allowable keys etc).\n         * Sets the event handler to respond to any key presses during the event.\n         * @private\n         * @method showStimulusQuestion\n         * @param question {Object} question to be shown.\n         *  @param id {String} Id of question.\n         *  @param onShowFunc {Function} Function to be called when showing question\n         *  @param loadConfig {Boolean} If true, config is loaded from the current block data (which has been defined elsewhere)\n         *  @param questionElement {Object} This Qualtrics question element\n         *  @param duringDisplayFn {Function} Function to be called each frame that the question is presented\n         */\n        showStimulusQuestion: function(question) {\n            //Save the loading start time\n            //QRTE.setTrialData(question.questionElement.QRTLibId + '[LoadStartTime]', window.requestAnimationFrame.now());\n            //Set mapping of the QID -> QRTE Id\n            QRTE.setId(this, question.id);\n\n            //Initialize variables\n            var stimulusShown = false,\n                questionScope = this,\n                dispEle;\n            QRTE.log(question);\n\n            //Check whether question should be shown or not, if not skip to the next question (implicitly)\n            if (question.conditional() === true) {\n                this.QRTLib_isActive = true;\n\n\n                if (question.loadConfig === true) {\n                    //Load the Configuration of the Question, important!\n                    QRTE.loadConfig(this);\n                }\n\n                //Check if KeyPress listener is required (one or more of the following fields are defined: onKeyPress, onCorrectKey or onAllowableKey)\n                //If so, add keypress listener.\n                if (question.onKeyPress !== undefined || question.questionElement.allowable !== '' || question.questionElement.cresp !== '') {\n                    //Initialize the fields used for storing data about RT timing.\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[RTTime]', '');\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[RT]', '');\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[RESP]', '');\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[ACC]', 0);\n\n                    //Add the key listener\n                    QRTE.addKeyListener(function(e) {\n\n                        //Get the Key of the response\n                        var RT, RESP = QRTE.keycode2string(e),\n                            RTTime = window.requestAnimationFrame.now();\n                        RT = RTTime - QRTE.getTrialData(question.questionElement.QRTLibId + '[OnsetTime]');\n\n                        //Store the Time of the Key Press and calculate the RT and ACC if correct\n\n                        if ((QRTE.isAllowableResponse(question.questionElement, RESP) || QRTE.isCorrectResponse(question.questionElement, RESP)) && QRTE.getTrialData(question.questionElement.QRTLibId + '[RTTime]') === '') {\n                            QRTE.setTrialData(question.questionElement.QRTLibId + '[RTTime]', RTTime);\n                            QRTE.setTrialData(question.questionElement.QRTLibId + '[RT]', RT);\n                            QRTE.setTrialData(question.questionElement.QRTLibId + '[RESP]', RESP);\n                            if (QRTE.isCorrectResponse(question.questionElement, RESP)) {\n                                QRTE.saveAcc(question.questionElement, 1);\n                            } else {\n                                QRTE.saveAcc(question.questionElement, 0);\n                            }\n                        }\n\n                        //Store the RT and the Response\n\n                        //Set Handling Key Press to true, this lets the engine know that a keypress is currently being handled. Necessary when there is a timer (response deadline)\n                        question.handlingKeyPress = true;\n\n                        if (question.onCorrectKey !== undefined && QRTE.isCorrectResponse(question.questionElement, RESP)) {\n                            question.onCorrectKey.apply(question.questionElement, [e, RESP]);\n                        } else if (question.onIncorrectKey !== undefined && QRTE.isAllowableResponse(question.questionElement, RESP)) {\n                            question.onIncorrectKey.apply(question.questionElement, [e, RESP]);\n                        }\n\n                        if (question.onAllowableKey !== undefined && QRTE.isAllowableResponse(question.questionElement, RESP)) {\n                            question.onAllowableKey.apply(question.questionElement, [e, RESP]);\n                        }\n\n                        if (question.onKeyPress !== undefined) {\n                            question.onKeyPress.apply(question.questionElement, [e, RESP]);\n                        }\n\n                        if (question.questionElement.endAction === 'TERMINATE') {\n                            //Proceed to the next Question Page if the response is allowable\n                            if (QRTE.isAllowableResponse(question.questionElement, RESP) && question.questionElement.QRTLib_isActive === true) {\n                                question.questionElement.proceed();\n                            }\n                        }\n                        question.handlingKeyPress = false;\n\n                    }, this);\n                }\n\n                //Build the display Element. Stimuli Questions have to take into account the possibility of being associated with a key press. \n                //OnDisplayFn therefore logs the displayOnsetTime, so that the RT can be calculated.\n                dispEle = {\n                    el: this.questionContainer,\n                    duration: this.duration,\n                    delay: this.offset,\n                    duringDisplayFn: question.duringDisplayFn,\n                    onDisplayFn: function(displayEl, timestamp) {\n                        if (question.onDisplayFn !== undefined) {\n                            question.onDisplayFn(displayEl, timestamp);\n                        }\n                        QRTE.setTrialData(questionScope.QRTLibId + '[OnsetTime]', displayEl.displayOnsetTime);\n                    },\n                    proceedOnHide: question.proceedOnHide,\n                    id: question.id\n                };\n\n                //Set the OnHide Function\n                dispEle.onHideFn = function(displayEl, timestamp) {\n                    if (question.onHideFn !== undefined) {\n                        question.onHideFn(displayEl, timestamp);\n                    }\n                    QRTE.setTrialData(questionScope.QRTLibId + '[OffsetTime]', displayEl.displayOffsetTime);\n                    QRTE.setTrialData(questionScope.QRTLibId + '[CalculatedDuration]', displayEl.displayDuration);\n                };\n\n\n                this.QRTLib_timer = QRTE.displayElement(dispEle);\n\n                question.onShowFunc.apply(this);\n\n                stimulusShown = true;\n            }\n\n            //QRTE.setTrialData(question.questionElement.QRTLibId + '[LoadEndTime]', window.requestAnimationFrame.now());\n            return stimulusShown;\n        },\n\n        setId: function(question, desc) {\n\n            this.idCache[question.questionId] = desc;\n            question.qId = desc;\n\n            Qualtrics.SurveyEngine.setEmbeddedData(QRTE.idField, Object.toJSON(this.idCache));\n        },\n\n        getOutputKey: function(key) {\n            var oldKey;\n            for (oldKey in this.idCache) {\n                if (this.idCache.hasOwnProperty(oldKey) && oldKey === key.substring(0, oldKey.length)) {\n\n                    return QRTE.getBlockData('QRTLib_currentBlock') + this.idCache[oldKey] + key.substring(oldKey.length, key.length);\n                }\n            }\n            return key;\n        },\n\n\n        OnKeyPress: function(fn, qScope) {\n\n            qScope = qScope || window;\n\n            var keyFn = function(e) {\n                QRTE.setTrialData(qScope.QRTLibId + '[RTTime]', window.requestAnimationFrame.now());\n                var RT = QRTE.getTrialData(qScope.QRTLibId + '[RTTime]') - QRTE.getTrialData(qScope.QRTLibId + '[OnsetTime]');\n                QRTE.setTrialData(qScope.QRTLibId + '[RT]', RT);\n                QRTE.setTrialData(qScope.QRTLibId + '[RESP]', QRTE.keycode2string(e));\n                QRTE.log(qScope);\n                fn.apply(qScope, [e]);\n            }\n\n            QRTE.addKeyListener(keyFn, qScope);\n        },\n\n        addKeyListener: function(fn, listenerScope) {\n            Event.observe(document, 'keypress', function(e) {\n                if (listenerScope.QRTLib_isActive === true) {\n                    fn.apply(listenerScope, [e]);\n                }\n            });\n        },\n\n        /*  \n         **************Methods below this line are support methods*******************\n         */\n\n        hideQuestions: function() {\n            qArray = $('Questions').getElementsByClassName('QuestionOuter');\n            for (var i = 0; i < qArray.length; i += 1) {\n                qArray[i].style.display = 'none';\n            }\n        },\n\n        unhideQuestions: function() {\n            //Redisplay outer questions\n            qArray = $('Questions').getElementsByClassName('QuestionOuter');\n            for (var i = 0; i < qArray.length; i += 1) {\n                qArray[i].style.display = 'block';\n            }\n            //Redisplay separators\n            qArray = $('Questions').getElementsByClassName('Separator');\n            for (var i = 0; i < qArray.length; i += 1) {\n                qArray[i].style.display = 'block';\n            }\n\n\n        },\n\n        _handleKeyPressEvent: function() {\n\n        },\n\n        _setConfig: function(QID, option, value, setterFunc) {\n            var qidString = QID;\n            if (typeof QID !== 'string') {\n                qidString = QID.questionId;\n            }\n            option = option.toLowerCase();\n\n            switch (option) {\n                case 'duration':\n                    if (value instanceof Array) {\n                        value = value[Math.floor(Math.random() * value.length)];\n                    }\n                    setterFunc.apply(this, [qidString, 'Duration', value]);\n                    break;\n                case 'allowable':\n                    setterFunc.apply(this, [qidString, 'Allowable', value]);\n                    break;\n                case 'cresp':\n                    setterFunc.apply(this, [qidString, 'CRESP', value]);\n                    break;\n                case 'delay':\n                    setterFunc.apply(this, [qidString, 'Offset', value]);\n                    break;\n                case 'endaction':\n                    setterFunc.apply(this, [qidString, 'EndAction', value]);\n                    break;\n                default:\n                    QRTE.log('No such configuration: ' + option);\n                    break;\n            }\n        },\n        getDuration: function(question) {\n            var duration = Infinity,\n                edDuration = this.getTrialData(question.QRTLib_configId + '[Duration]');\n            if (edDuration !== undefined && edDuration !== '' && !isNaN(edDuration)) {\n                duration = edDuration;\n            }\n            if (question._Duration !== undefined && question._Duration !== '' && !isNaN(question._Duration)) {\n                duration = question._Duration;\n            }\n\n            return duration;\n        },\n        getAllowable: function(question) {\n            var allowable = \"\",\n                edAllowable = this.getTrialData(question.QRTLib_configId + '[Allowable]');\n            if (edAllowable !== undefined) {\n                allowable = edAllowable;\n            }\n            if (question._Allowable !== undefined) {\n                allowable = question._Allowable;\n            }\n\n            if (allowable === '{ANY}') {\n                allowable = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890-=[]\\\\;',./`\";\n            }\n            //allowable = allowable.toUpperCase();\n            return allowable;\n        },\n        getCResp: function(question) {\n            var cresp = '',\n                edcresp = this.getTrialData(question.QRTLib_configId + '[CRESP]');\n            if (edcresp !== undefined) {\n                cresp = edcresp;\n            }\n            if (question._cresp !== undefined) {\n                cresp = question._CRESP;\n            }\n\n            if (cresp === '{ANY}') {\n                cresp = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890-=[]\\\\;',./`\";\n            }\n            //cresp = cresp.toUpperCase();\n\n            return cresp;\n        },\n\n        getOffset: function(question) {\n            var offset = 0,\n                edOffset = this.getTrialData(question.QRTLib_configId + '[Offset]');\n            if (edOffset !== undefined && edOffset !== '' && !isNaN(edOffset)) {\n                offset = edOffset;\n            }\n            if (question._Offset !== undefined && question._Offset !== '' && !isNaN(question._Offset)) {\n                offset = question._Offset;\n            }\n\n            return offset;\n\n        },\n\n        getEndAction: function(question) {\n            var endAction = 'NONE',\n                edEndAction = this.getTrialData(question.QRTLib_configId + '[EndAction]');\n            if (edEndAction !== undefined && edEndAction !== '') {\n                endAction = edEndAction;\n            }\n            if (question._EndAction !== undefined && question._EndAction !== '') {\n                endAction = question._EndAction;\n            }\n\n            return endAction;\n\n        },\n        evaluateConditional: function(conditional) {\n            QRTE.log('Conditional: ', conditional);\n            return conditional === '' || conditional();\n        },\n        log: function() {\n            if (QRTE.debug === true) {\n                for (var i = 0; i < arguments.length; i += 1) {\n                    console.log(arguments[i]);\n                }\n            }\n        },\n\n        median: function(values) {\n\n            values.sort(function(a, b) {\n                return a - b;\n            });\n\n            var half = Math.floor(values.length / 2);\n\n            if (values.length % 2) return values[half];\n            else return (values[half - 1] + values[half]) / 2.0;\n        },\n\n        waitForKey: function(question, keys) {\n            Event.observe(document, 'keypress', function(e) {\n                var resp = QRTE.keycode2string(e);\n                if (keys.indexOf(resp) >= 0) {\n                    question.clickNextButton();\n                }\n            });\n        },\n\n        validateParams: function(paramObj, validationArray) {\n            var valObj, val, index, typeCheck = true,\n                indexType;\n            //Loop over validationArray to check whether parameters suffice\n            for (index = 0; index < validationArray.length; index += 1) {\n                valObj = validationArray[index];\n                if (paramObj[valObj.name] === undefined && valObj.required === true) {\n                    alert('Required parameter: ' + valObj.name + ' seems to be missing');\n                    QRTE.log('Required parameter: ' + valObj.name + ' seems to be missing');\n                    break;\n                }\n\n                val = paramObj[valObj.name];\n\n                //Loop over type checkers\n                for (indexType = 0; indexType < valObj.type.length; indexType += 1) {\n                    typeCheck = QRTE.validateType(val, valObj.type[indexType]);\n                    if (typeCheck === true) {\n                        break;\n                    }\n                }\n                if (typeCheck === false && valObj.required === true) {\n                    alert('Parameter: ' + valObj.name + ' is of the wrong type, expected type: ' + valObj.type + ', type received: ' + (typeof val) + \"\\n\" + \"Please open the console for detailed error messages\");\n                    QRTE.log('Parameter: ' + valObj.name + ' is of the wrong type, expected type: ' + valObj.type + ', type received: ' + (typeof val));\n                    QRTE.log('Faulty parameter ' + valObj.name + ': ', val);\n                    QRTE.log('Proper functioning of QRTE is no longer guaranteed, please fix the above error');\n                }\n\n            }\n        },\n\n        validateType: function(val, type) {\n            switch (type) {\n                case 'JSON':\n                    return val.isJSON();\n                case 'String':\n                    return (typeof val === 'string' || val instanceof String);\n                case 'Number':\n                    return (!isNaN(parseFloat(val)) && isFinite(val));\n                case 'Array':\n                    return val instanceof Array;\n                case 'Object':\n                    return typeof val === 'object';\n                case 'Function':\n                    return typeof val === 'function';\n                case 'Boolean':\n                    return (val === true || val === false);\n                case 'Empty':\n                    return val === '';\n                default:\n                    return false;\n            }\n        },\n\n        fixSetEmbeddedDataBug: function() {\n            Qualtrics.SurveyEngine.setEmbeddedData = function(key, value) {\n                var fieldName = 'ED~' + key;\n                if ($(fieldName)) {\n                    $(fieldName).value = value;\n                } else {\n                    $('Header').appendChild(QBuilder('input', {\n                        type: 'hidden',\n                        id: fieldName,\n                        name: fieldName,\n                        value: value\n                    }));\n                    Qualtrics.SurveyEngine.setEmbeddedData(key, value);\n                }\n            }\n        },\n\n        //DisplayEngine part\n\n        //Since it's impossible to know when a screen refresh has happened, we assume that the first timestamp is the actual screen refresh.\n        //Based on the difference between the current timestamp Tn and the root timestamp Tn-1, we estimate the amount of frames that have passed since. \n        //Based on the amount of frames we estimate the previous screen refresh. Although not perfect, it's the best we can do.\n\n        refreshRate: 60, //hertz\n        refreshPeriod: 1000 / 60,\n        lastRefresh: 0,\n        currentRefresh: 0,\n        previousTimestamp: 0,\n        referenceTime: 0,\n        framesSinceReference: 0,\n        currentStack: [],\n        proceedOnFrameEnd: false,\n\n        init: function() {\n            window.requestAnimationFrame(QRTE.draw);\n        },\n\n        draw: function(timestamp) {\n            var curEle, newStack = [];\n            timestamp = window.requestAnimationFrame.now();\n\n\n            if (timestamp < 1e12) {\n                timestamp += window.performance.timing.navigationStart;\n            }\n\n            if (QRTE.referenceTime === 0) {\n                QRTE.referenceTime = timestamp;\n                QRTE.previousTimestamp = timestamp;\n                QRTE.framesSinceReference = 0;\n            } else {\n                //QRTE.framesSinceReference += QRTE.calcFrames(QRTE.referenceTime, timestamp);\n                QRTE.prevFrames = QRTE.framesSinceReference;\n                //frameDiff =  QRTE.calcFrames(QRTE.referenceTime, timestamp) - QRTE.prevFrames;\n                QRTE.framesSinceReference = QRTE.calcFrames(QRTE.referenceTime, timestamp);\n            }\n            QRTE.currentRefresh = (QRTE.framesSinceReference * QRTE.refreshPeriod) + QRTE.referenceTime;\n            QRTE.projectedRefresh = QRTE.currentRefresh + QRTE.refreshPeriod;\n            curEle = QRTE.currentStack.shift();\n\n            while (curEle) {\n                curEle.keep = true;\n\n                //Call duringDisplay callback function, with the current element and the timestamp as arguments.\n                if (curEle.shown === true && typeof curEle.duringDisplayFn === 'function') {\n                    curEle.duringDisplayFn(curEle, timestamp);\n                }\n\n                if (QRTE.proceedOnFrameEnd === true || curEle.hide === true || (curEle.shown === true && curEle.displayOnset !== undefined && (curEle.displayOnset + curEle.duration < QRTE.projectedRefresh))) {\n                    //If the next refresh makes it go beyond the duration, hide the element again!\n                    curEle = QRTE.hideSingleEle(curEle, timestamp);\n                } else if (curEle.shown === false && curEle.requestedAt + curEle.delay < QRTE.projectedRefresh) {\n                    curEle = QRTE.dispSingleEle(curEle, timestamp);\n                }\n\n                if (curEle.keep === false && curEle.proceedOnHide === true) {\n                    //Behold! We have found an element that commands us to proceed to the next page.\n                    QRTE.proceedOnFrameEnd = true;\n                    //Every element that has been processed so far needs to be re-processed (sadly), so that they properly hide.\n                    for (var ind = 0; ind < newStack.length; ind += 1) {\n                        if (newStack[ind].hide !== true) {\n                            newStack[ind].hide = true;\n                            QRTE.currentStack.push(newStack[ind]);\n                        }\n                    }\n                } else {\n                    //Push it to the newStack, for it to be processed next time.\n                    newStack.push(curEle);\n                }\n\n                curEle = QRTE.currentStack.shift();\n            }\n            QRTE.currentStack = newStack;\n            QRTE.lastRefresh = QRTE.currentRefresh;\n            QRTE.previousTimestamp = timestamp;\n            window.requestAnimationFrame(QRTE.draw);\n            if ((newStack.length === 0 || QRTE.proceedOnFrameEnd) && QRTE.inited === true) {\n                QRTE.proceedOnFrameEnd = false;\n                QRTE.proceedPage();\n            }\n\n\n        },\n\n        calcFrames: function(previous, current) {\n            var diff = current - previous,\n                frames = 0;\n\n            if (diff < QRTE.refreshPeriod) {\n                frames = 1;\n            } else {\n                frames = Math.floor(diff / QRTE.refreshPeriod);\n                if (diff % QRTE.refreshPeriod >= (QRTE.refreshPeriod * 0.9)) {\n                    frames += 1;\n                }\n            }\n\n            return frames;\n        },\n\n        /**\n         * Display an element for a specified duration with a specified delay. Vsyncs the display duration using requestAnimationFrame (if possible in the browser)\n         * and allows for high-precision control over its duration. Please start any custom attributes for the paramObj with the 'custom_' header, to avoid collisions.\n         * @private\n         * @method displayElement\n         * @param paramObj {Object}\n         *  @param el {Object} HTML element to be displayed\n         *  @param [onHideFn] {Function} Function to be called upon removing the element from display, is passed one argument containing all information about the display element.\n         *  @param [duration] {Number} Number of milliseconds (ms) the element should be displayed.\n         *  @param [delay] {Number} Number of milliseconds (ms) the Engine should wait before displaying the element.\n         *  @param [duringDisplayFn] {Function} Function to be called upon displaying the element for another screen refresh. Careful: Keep this function simple, could seriously hamper performance as it's called about every 16-17 ms.  is passed one argument containing all information about the display element.\n         *  @param [onDisplayfn] {Function} Function to be called upon starting to display the element. Is passed one argument containing all information about the display element.\n         */\n\n        //displayElement: function(el, callback, duration, offset, duringDisplaycb) {\n        displayElement: function(paramObj) {\n            var reqAt,\n                id = String(Math.random());\n            //QRTE.log(arguments);\n            if (paramObj.delay === undefined) {\n                paramObj.delay = 0;\n            }\n\n\n\n            if (paramObj.duration === undefined) {\n                paramObj = Infinity;\n            }\n\n            if (isNaN(QRTE.lastRefresh)) {\n                reqAt = window.requestAnimationFrame.now();\n            } else {\n                reqAt = QRTE.lastRefresh;\n            }\n            paramObj.userId = paramObj.id;\n            paramObj.id = id;\n            paramObj.shown = false;\n            paramObj.requestedAt = reqAt;\n            paramObj.hide = false;\n\n            QRTE.currentStack.push(paramObj);\n            if (paramObj.delay === 0) {\n                //This element needs to be displayed as soon as possible\n                QRTE.dispSingleEle(paramObj, QRTE.previousTimestamp);\n            }\n            QRTE.log('Added element to display stack:', paramObj);\n            //console.log('paramObj: ', paramObj.userId, ', duration: ', paramObj.duration);\n\n            return id;\n        },\n\n        hideElement: function(id) {\n            var found = false,\n                i;\n            for (i = 0; i < QRTE.currentStack.length; i += 1) {\n                if (QRTE.currentStack[i].id === id) {\n                    found = true;\n                    QRTE.currentStack[i].hide = true;\n                    this.log('Element to be hidden: ', QRTE.currentStack[i]);\n                }\n            }\n            return found;\n        },\n\n        hideAllElements: function() {\n            for (i = 0; i < QRTE.currentStack.length; i += 1) {\n                QRTE.currentStack[i].hide = true;\n            }\n            QRTE.proceedOnFrameEnd = true;\n        },\n\n        /**\n         * Hide a DrawEngine Element\n         * @private\n         * @method hideSingleEle\n         * @param curEle {Object}\n         */\n        hideSingleEle: function(curEle, timestamp) {\n            curEle.displayOffset = QRTE.projectedRefresh;\n            curEle.displayOffsetTime = window.requestAnimationFrame.now();\n            curEle.el.style.display = 'none';\n            curEle.keep = false;\n            curEle.hide = true;\n            //delete QRTE.currentStack[key];\n            curEle.displayDuration = curEle.displayOffsetTime - curEle.displayOnsetTime;\n            if (curEle.onHideFn !== undefined) {\n                curEle.onHideFn(curEle, timestamp);\n            }\n\n            return curEle;\n\n        },\n\n\n        /**\n         * Display a DrawEngine Element\n         * @private\n         * @method dispSingleEle\n         * @param curEle {Object}\n         */\n        dispSingleEle: function(curEle, timestamp) {\n            curEle.el.style.display = 'block';\n            curEle.displayOnset = QRTE.projectedRefresh;\n            curEle.displayOnsetTime = window.requestAnimationFrame.now();\n            curEle.shown = true;\n            if (curEle.onDisplayFn !== undefined) {\n                //Added try-catch block to catch the error that's causing the OnsetTime not to get saved.\n                try {\n                    curEle.onDisplayFn(curEle, timestamp);\n                } catch (e) {\n                    QRTE.setTrialData('Error[OnsetError]', JSON.stringify(e));\n                }\n            }\n            return curEle;\n        },\n\n        checkEngineCompatibility: function() {\n            return window.requestAnimationFrame.method === 'native-highres';\n        },\n    };=====================================\n     * Copyright 2013-2014 Erwin Haasnoot\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     * http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     *\n     *\n     *\n     * ========================================================== */\n    /**\n     * Qualtrics Reaction Time Engine or QRTE is an add-on providing an interface\n     * for easy reaction time experiment creation in the Qualtrics survey research suite (tm).\n     * For instructions on how to use this add-on, see xxxx\n     *\n     * QRTE was developed by Erwin Haasnoot\n     * Email: erwinhaasnoot[at]gmail.com\n     * @class QRTE\n     *\n     */\n    var QRTE = {\n        version: 'v16',\n        columnsField: 'QRTE_columns',\n        blockDataField: 'QRTE_blockData',\n        idField: 'QRTE_idData',\n        exitQuestions: 'QRTE_exitQuestions',\n        inited: false,\n        /**\n         * TDCache contains the Trial-Level Data in an Object. DO NOT directly manipulate this Object. It might cause inconsistencies in the data file and cause unexpected once parsed.\n         * Use QRTE.setTrialData and QRTE.getTrialData instead.\n         *\n         * @property TDCache\n         * @private\n         * @type Object\n         */\n        TDCache: {},\n\n        /**\n         * ColumnCache contains all the mappings from QID to Columns\n         * @property columnCache\n         * @private\n         * @type Object\n         */\n        columnCache: {},\n\n        /**\n         * BDCache contains the BlockLevel Data in an Object. Directly manipulating this Object might cause inconsistencies\n         * @property BDCache\n         * @private\n         * @type Object\n         */\n        BDCache: {},\n\n        /**\n         * SDCache is a cache for speeding up retrieval of Survey level Data,\n         * All Survey data is saved to both Embedded Data and Survey Data\n         * @private\n         * @property SDCache\n         * @type Object\n         */\n        SDCache: {},\n\n        /**\n         * idCache is a cache for quickly retrieving the Qualtrics QID to QRTLib Id mappings.\n         * Saved in the idData embedded data field after every trial.\n         * @private\n         * @property idCache\n         * @type Object\n         */\n        idCache: {},\n\n        /**\n         * questionQueue contains Objects (stimuli) that are waiting to be presented\n         * @private\n         * @property questionQueue\n         * @type Array\n         */\n        questionQueue: [],\n\n        /**\n         * currentPageQuestions contains the Question Objects that are\n         * displayed at any given time.\n         * @private\n         * @property currentPageQuestions\n         * @type Array\n         */\n        currentPageQuestions: [],\n\n        /**\n         * Contains Trial Data Columns that were 'newly' added in this trial run.\n         * @private\n         * @property newlyAddedColumns\n         * @type Array\n         */\n        newlyAddedColumns: [],\n\n        /**\n         * Contains the Post-Initialization Element.\n         * @private\n         * @property postInitElement\n         * @type Object\n         */\n        postInitElement: {},\n\n        /**\n         * Setter function for Trial-Level Data.\n         * @method setTrialData\n         * @param key {String} Key\n         * @param value {Value} Value\n         */\n        setTrialData: function(key, value) {\n            //Store value in trial cache\n            this.TDCache[key] = value;\n            if (this.BDCache.QRTLib_trialColumns[key] === undefined) {\n                //Add column to overall trial data\n                this.BDCache.QRTLib_trialColumns[key] = '';\n                this.newlyAddedColumns.push(key);\n            }\n        },\n\n        /**\n         * Gets the value of Trial-Level Data field 'key\n         * @method getTrialData\n         * @param key {String} Key\n         */\n        getTrialData: function(key) {\n            return this.TDCache[key];\n        },\n\n        /**\n         * Setter function for Block-Level Data.\n         * @method setBlockData\n         * @param key {String} Key\n         * @param value {Value} Value\n         */\n        setBlockData: function(key, value) {\n            this.BDCache[key] = value;\n        },\n\n\n        /**\n         * Gets the value of Block-Level Data field 'key\n         * @method getBlockData\n         * @param key {String} Key\n         */\n        getBlockData: function(key) {\n            return this.BDCache[key];\n        },\n\n\n\n\n        /**\n         * Stringify the Block Data and store it in the Embedded Data Field. This preserves the values stored on Block Level for use in later trials\n         * @method saveBlockData\n         * @param key {String} Key\n         */\n        saveBlockData: function() {\n            //Store blockData in ED so that we can use it next trial\n            QRTEController.storeBlockData(QRTE.BDCache);\n            Qualtrics.SurveyEngine.setEmbeddedData(QRTE.blockDataField, Object.toJSON(QRTE.BDCache));\n        },\n\n\n\n        /**\n         * Setter function for Survey-Level Data (Embedded Data).\n         * @method setSurveyData\n         * @param key {String} Key\n         * @param value {Value} Value\n         */\n        setSurveyData: function(key, value) {\n            this.SDCache[key] = value;\n            Qualtrics.SurveyEngine.setEmbeddedData(key, value);\n        },\n\n\n\n        /**\n         * Gets the value of Survey-Level Data (Embedded Data) 'key'\n         * @method getSurveyData\n         * @param key {String} Key\n         */\n\n        getSurveyData: function(key) {\n            if (this.SDCache[key] !== undefined) {\n                return this.SDCache[key];\n            }\n            //This only works if the Survey Data has been set during the same trial due to a bug in Qualtrics.\n            return Qualtrics.SurveyEngine.getEmbeddedData(key);\n        },\n\n        /**\n         * Sets a configuration for a question\n         * @method setConfig\n         * @param QID {String} The QRTE Question Id of the Question you want the configuration to apply to\n         * @param option {String} The type of configuration you want to set, Allowed options: 'cresp', 'allowable', 'duration', 'endaction', 'delay'. Refer to website for documentation on these configs\n         * @param value {String} The value the configuration needs to be set to. Differs per option.\n         */\n        setConfig: function(QID, option, value) {\n            var setterFunc;\n            if (typeof QID === 'string') {\n                setterFunc = function(QID, option, value) {\n                    this.setTrialData(QID + \"[\" + option + \"]\", value);\n                };\n            } else {\n                setterFunc = function(QID, option, value) {\n                    this.setTrialData(QID.questionId + \"[\" + option + \"]\", value);\n                    QID['_' + option] = value;\n                };\n\n            }\n\n            this._setConfig(QID, option, value, setterFunc);\n        },\n\n\n        /**\n         * Loads the configuration for a question.\n         * @private\n         * @method loadConfig\n         * @param question {Object} Question for which the configuration needs to be loaded.\n         */\n        loadConfig: function(question) {\n            if (this.idCache[question.questionId] !== undefined) {\n                question.QRTLib_configId = this.idCache[question.questionId];\n            } else {\n                question.QRTLib_configId = question.question;\n            }\n            question.duration = this.getDuration(question);\n            question.allowable = this.getAllowable(question);\n            question.cresp = this.getCResp(question);\n            question.offset = this.getOffset(question);\n            question.endAction = this.getEndAction(question);\n        },\n\n        /**\n         * Stores the accuracy of a trial\n         * @private\n         * @method saveAcc\n         * @param question {Object} Question for which accuracy needs to be stored\n         * @param acc {Integer} Accuracy of question\n         */\n\n        saveAcc: function(question, acc) {\n            if (acc === 0 || acc === 1) {\n                this.setTrialData(question.QRTLibId + \"[ACC]\", acc);\n                this.setSurveyData(\"ACC\", acc);\n            }\n        },\n\n\n\n        /**\n         * Check whether the given response was a correct response\n         * @method isCorrectResponse\n         * @param question {Object} Question for which correct response needs to be checked\n         * @param resp {String} Given response\n         */\n        isCorrectResponse: function(question, resp) {\n            return question.cresp.indexOf(resp) >= 0;\n        },\n\n        /**\n         * Check whether the given response was an allowable response\n         * @method isAllowableResponse\n         * @param question {Object} Question for which allowable response needs to be checked\n         * @param resp {String} Given response\n         */\n        isAllowableResponse: function(question, resp) {\n            return question.allowable.indexOf(resp) >= 0;\n        },\n\n\n\n        /**\n         * Check whether the given response was an allowable response\n         * @private\n         * @method keycode2string\n         * @param e {Object} KeyPress event from which to retrieve the response\n         */\n        keycode2string: function(e) {\n            return String.fromCharCode(e.charCode);\n        },\n\n        /** \n         * Wait for images to load before starting trial.\n         * @property waitForImageLoad\n         * @private\n         * @type Boolean\n         */\n\n        waitForImageLoad: true,\n\n        /** \n         * Trial Start waiting list - initialised with waiting for TrialStart\n         * @property loadWaitingList\n         * @private\n         * @type Array\n         */\n\n        loadWaitingList: [false],\n\n        /**\n         * Initializes the Engine, called at the start of the 'Init' question.\n         * @private\n         * @method initLib\n         * @param blockDataString {String} JSON string containing information saved for this block (block-level data)\n         * @param blockId {String} Id of the current block\n         * @param columns {String} JSON string containing information about the columns that have been defined in this block\n         * @param idData {String} JSON string containing information about the mapping of the QID to the name of the question\n         * @param exitQuestions {String} String containing the currently defined QuestionTags of the Exit questions\n         * @param exitItemTag {String} String containing the Tag of this block's Exit question.\n         */\n\n\n        initLib: function(blockDataString, blockId, columns, idData, exitQuestions, exitItemTag) {\n            //var blockDataString = Qualtrics.SurveyEngine.getEmbeddedData(QRTE.blockDataField),\n            //columns = Qualtrics.SurveyEngine.getEmbeddedData(QRTE.columnsField),\n            //idData = Qualtrics.SurveyEngine.getEmbeddedData(QRTE.idField);\n            var glue;\n            QRTE.fixSetEmbeddedDataBug();\n            //Initialise block Data\n            if (blockDataString === undefined columnData || blockDataString === '') {\n                blockDataString = '{}';\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.blockDataField, blockDataString);\n            }\n\n            this.BDCache = QRTEController.loadBlockData(blockDataString);\n\n            if (this.BDCache.QRTLib_currentBlock !== blockId) {\n                //If this is a new block, initialise a new block\n                this.BDCache = {\n                    QRTLib_currentBlock: blockId,\n                    QRTLib_blockCounter: 1,\n                    QRTLib_trialColumns: {}\n                };\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.blockDataField, Object.toJSON(this.BDCache));\n                if (exitQuestions === null) {exitQuestions = '';}\n                glue = '';\n                if (exitQuestions !== '') {\n                    glue = ';';\n                }\n                //And update the exit questions\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.exitQuestions, exitQuestions + glue + exitItemTag);\n\n            }\n            QRTE.TDCache = Object.toJSON(QRTE.getBlockData('QRTLib_trialColumns')).evalJSON();\n            if (columns === undefined || columns === null || columns === '') {\n                columns = '{}';\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.columnsField, columns);\n            }\n            QRTE.SDCache[QRTE.columnsField] = columns.evalJSON();\n            if (idData === undefined || idData === null || idData === '') {\n                idData = '{}';\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.idField, idData);\n            }\n            QRTE.idCache = idData.evalJSON();\n        },\n\n        /**\n         * Init initializes the QRTEngine, expects are params object with possible fields defined with parameters.\n         * @method Init\n         * @param paramObj {Object} object containing parameters of Init function\n         *  @param paramObj.blockData {String} blockData string in json format (from embedded data)\n         *  @param paramObj.columnData {String} columnData string in json format (from embedded data)\n         *  @param paramObj.exitQuestions {String} exitQuestions string (from embedded data)\n         *  @param paramObj.exitItemTag {String} Tag of the Exit question of this block\n         *  @param paramObj.blockId {String} Identificaton of the block\n         *  @param [paramObj.onLoadFn] {Function} Function to be called when this Question is displayed\n         *  @param [paramObj.interTrialDelay] {Integer|Array} Specify millisecond delay between end of previous trial and beginning of new trial\n         *  @param [paramObj.preTrialDelay] {Integer|Array} Specify millisecond (ms) delay before the start of the first trial of the block. //NYI\n         *  @param [paramObj.initQuestionIndex] {Integer} Specify index of the Init question in the Question Block (defaults to 1)\n         *  @param [paramObj.waitForImages] {Boolean} Specify whether we should wait for images or not. Is on by default, but could be turned off if all images are pre-loaded in cache, or are very small in general.\n         */\n        Init: function(paramObj) {\n            var validationArray, qArray, initIndex;\n            //init the library\n            QRTE.init();\n\n            //set the initIndex (if the Init question is not the first question of the block)\n            QRTE.initIndex = paramObj.initQuestionIndex - 1 || 0;\n\n\n            validationArray = [{\n                name: 'blockData',\n                type: ['JSON', 'Empty'],\n                required: true\n            }, {\n                name: 'columnData',\n                type: ['JSON', 'Empty'],\n                required: true\n            }, {\n                name: 'idData',\n                type: ['JSON', 'Empty'],\n                required: true\n            }, {\n                name: 'blockId',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'onLoadFn',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'interTrialDelay',\n                type: ['Integer', 'Array'],\n                required: false\n            }, {\n                name: 'exitQuestions',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'exitItemTag',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'waitForImages',\n                type: ['Boolean'],\n                required: false\n            }];\n\n            //Validate Parameter Object, outputs stuff to console\n            QRTE.validateParams(paramObj, validationArray, 'Init');\n\n\n            //Initialize the library itself (necessary for each trial)\n            QRTE.initLib(paramObj.blockData, paramObj.blockId, paramObj.columnData, paramObj.idData, paramObj.exitQuestions, paramObj.exitItemTag);\n\n\n            if (paramObj.waitForImages !== undefined) {\n                QRTE.waitForImageLoad = paramObj.waitForImages;\n            }\n            //calculate server communication delay\n            QRTE.setTrialData('InitPre[OnsetTime]', QRTE.getBlockData('QRTLib_previousStorageDone'));\n\n            QRTE.setTrialData('InitPre[OffsetTime]', window.requestAnimationFrame.now());\n            QRTE.setTrialData('InitPre[CalculatedDuration]', QRTE.getTrialData('InitPre[OffsetTime]') - QRTE.getTrialData('InitPre[OnsetTime]'));\n            QRTE.setTrialData('Init[OnsetTime]', window.requestAnimationFrame.now());\n\n\n\n            Qualtrics.SurveyEngine.addOnload(function() {\n                this.qHTML = document.getElementById(this.questionId);\n                this.QRTLib_isActive = false;\n                this.hideChoices();\n                this.proceed = QRTE.proceed;\n                this.QRTLibId = 'InitPost';\n\n                paramObj.onLoadFn.apply(this);\n                var QuestionStackElement = {\n                    questionElement: this,\n                    onShowFunc: function() {},\n                    type: 'Stimulus',\n                    loadConfig: true,\n                    id: 'InitPost',\n                    conditional: function() {\n                        return true;\n                    },\n                    proceedOnHide: true\n\n                };\n                QRTE.setConfig(QuestionStackElement.id, 'duration', 0);\n                QRTE.postInitElement = QuestionStackElement;\n                QRTE.questionQueue.push(QuestionStackElement);\n            });\n\n            if (paramObj.interTrialDelay instanceof Array) {\n                paramObj.interTrialDelay = paramObj.interTrialDelay[Math.floor(Math.random() * paramObj.interTrialDelay.length)];\n            }\n            QRTE.setTrialData(paramObj.blockId + '[InterTrialDelay]', paramObj.interTrialDelay);\n            if (paramObj.interTrialDelay > 0) {\n                QRTE.setBlockData('QRTLib_intraTrialDelay', paramObj.interTrialDelay);\n            } else {\n                QRTE.setBlockData('QRTLib_intraTrialDelay', -1);\n            }\n        },\n\n        /**\n         * Create a Stimulus question\n         * @method Stimulus\n         * @param paramObj {Object}\n         *  @param paramObj.id {String} Id of the Question\n         *  @param paramObj.onShowFn {Function} Function to be called upon showing the question (not the same as upon loading)\n         *  @param [paramObj.conditional] {Function} Function to be called with which to decide whether to present this question or not, should return a boolean.\n         *  @param [paramObj.loadConfig] {Boolean} Load predefined config for this question (defaults to true)\n         *  @param [paramObj.stimContinue] {Boolean} Continue looking for stimuli after having seen this one, only if set to true (defaults to false)\n         *  @param [paramObj.onKeyPress] {Function} Function to be called upon receiving a key press while this Question is active (called next to onAllowableKey or onCorrectKey)\n         *  @param [paramObj.onAllowableKey] {Function} Function to be called upon receiving a key press on a key defined as 'allowable' \n         *  @param [paramObj.onCorrectKey] {Function} Function to be called upon receiving a key press on a key defined as 'correct'\n         *  @param [paramObj.onIncorrectKey] {Function} Function to be called upon receiving an allowable key that is not defined as correct (only if correct responses are defined)\n         *  @param [paramObj.proceedOnHide] {Boolean} Set whether all currently displayed elements should be removed on hide, or if only this should be removed from display (Defaults to True). This allows the user to decouple presentation of a stimulus from proceeding of a slide.\n         *  @param [paramObj.onHideFn] {Function} Function to be called upon Stimulus being hidden\n         *  @param [paramObj.duringDisplayFn] {Function} Function to be called during each frame that the Stimulus is being displayed\n         \n         */\n        Stimulus: function(paramObj) {\n            var validationArray = [{\n                name: 'id',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'onShowFn',\n                type: ['Function'],\n                required: true\n            }, {\n                name: 'conditional',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'loadConfig',\n                type: ['Boolean'],\n                required: false\n            }, {\n                name: 'duringDisplayFn',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'continue',\n                type: ['Boolean'],\n                required: false\n            }, {\n                name: 'onAllowableKey',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'onCorrectKey',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'onKeyPress',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'onIncorrectKey',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'proceedOnHide',\n                type: ['Boolean'],\n                required: false\n            }, {\n                name: 'onHideFn',\n                type: ['Function'],\n                required: false\n            }];\n\n            //Validate Parameter Object, outputs stuff to console\n            QRTE.validateParams(paramObj, validationArray, 'Stimulus');\n\n\n            if (paramObj.conditional === undefined) {\n                paramObj.conditional = function() {\n                    return true;\n                };\n            }\n            if (paramObj.loadConfig === undefined) {\n                paramObj.loadConfig = true;\n            }\n\n            if (paramObj.stimContinue === undefined) {\n                paramObj.stimContinue = false;\n            }\n\n            if (paramObj.proceedOnHide === undefined) {\n                paramObj.proceedOnHide = true;\n            }\n            Qualtrics.SurveyEngine.addOnload(function() {\n                this.QRTLib_isActive = false;\n                this.proceed = QRTE.proceed;\n                this.QRTLibId = paramObj.id;\n                var QuestionStackElement = {\n                    questionElement: this,\n                    onShowFunc: paramObj.onShowFn,\n                    duringDisplayFn: paramObj.duringDisplayFn,\n                    onHideFn: paramObj.onHideFn,\n                    type: 'Stimulus',\n                    loadConfig: paramObj.loadConfig,\n                    id: paramObj.id,\n                    conditional: paramObj.conditional,\n                    stimContinue: paramObj.stimContinue,\n                    onAllowableKey: paramObj.onAllowableKey,\n                    onCorrectKey: paramObj.onCorrectKey,\n                    onKeyPress: paramObj.onKeyPress,\n                    onIncorrectKey: paramObj.onIncorrectKey,\n                    proceedOnHide: paramObj.proceedOnHide\n                };\n                QRTE.questionQueue.push(QuestionStackElement);\n            });\n        },\n\n        /**\n         * Exit denotes the end of the block. Important for the initialization phase and the exit phase.\n         * Make the question a Form question with precisely 2 answer fields (more is unnecessary, those will get ignored)\n         * @method Exit\n         */\n        Exit: function() {\n\n\n            qArray = $('Questions').getElementsByClassName('QuestionOuter');\n            for (var i = 0; i < qArray.length && i < QRTE.initIndex + 1; i += 1) {\n                qArray[i].style.display = 'block';\n            }\n            Qualtrics.SurveyEngine.addOnload(function() {\n                //Hide all choice\n                this.hideChoices();\n                //display the question\n                //this.questionContainer.style.display = 'none';\n                var QuestionStackElement, onShowFn;\n                onShowFn = function() {\n\n                    //Create and/or store standard information about the trial\n                    var blockId = QRTE.getBlockData('QRTLib_currentBlock'),\n                        tempTD = {},\n                        key,\n                        i;\n\n                    QRTE.setBlockData('QRTLib_previousEndTime', window.requestAnimationFrame.now());\n                    QRTE.setTrialData(blockId + '[TrialNr]', QRTE.getBlockData('QRTLib_blockCounter'));\n                    QRTE.setTrialData(blockId + '[RefreshPeriod]', QRTE.refreshPeriod);\n                    QRTE.setTrialData('BlockId', blockId);\n                    QRTE.setTrialData('EngineType', window.requestAnimationFrame.method);\n                    QRTE.setTrialData('Exit[OnsetTime]', window.requestAnimationFrame.now());\n                    QRTE.setTrialData('QRTEngine[Version]', QRTE.version);\n\n                    //CHECK IF ATLEAST TWO FORM FIELDS HAVE BEEN DEFINED\n                    this.setChoiceValue(2, 'testtest');\n                    if (this.getChoiceValue(2) !== 'testtest') {\n                        //alert('You need to define two answer form fields in the Exit question!!');\n                    }\n\n                    for (key in QRTE.TDCache) {\n                        if (QRTE.TDCache.hasOwnProperty(key) && key !== '') {\n                            //Change QID thingies to entered ID's, also force every value to a string so that the Parser handles high numerical values correctly\n                            tempTD[QRTE.getOutputKey(key)] = String(QRTE.TDCache[key]);\n                        }\n                    }\n\n                    this.setChoiceValue(1, Object.toJSON(tempTD));\n                    this.setChoiceValue(2, blockId);\n                    if (QRTE.SDCache[QRTE.columnsField][blockId] === undefined) {\n                        QRTE.SDCache[QRTE.columnsField][blockId] = [];\n                    }\n                    for (i = 0; i < QRTE.newlyAddedColumns.length; i += 1) {\n                        QRTE.SDCache[QRTE.columnsField][blockId].push(QRTE.getOutputKey(QRTE.newlyAddedColumns[i]));\n                    }\n\n                    QRTE.setSurveyData(QRTE.columnsField, Object.toJSON(QRTE.SDCache[QRTE.columnsField]));\n                    QRTE.setBlockData('QRTLib_blockCounter', QRTE.getBlockData('QRTLib_blockCounter') + 1);\n                    QRTE.setBlockData('QRTLib_previousStorageDone', window.requestAnimationFrame.now());\n                    QRTE.saveBlockData();\n\n                    //If wanting to test, uncomment this line and comment the one after that to enforce manual nextbutton clicks\n                    //$('NextButton').style.display = 'block';\n                    //QRTE.submitPage();\n                    QRTEController.loadNextTrial();\n                };\n\n                QuestionStackElement = {\n                    questionElement: this,\n                    onShowFunc: onShowFn,\n                    type: 'Storage',\n                    loadConfig: true,\n                    conditional: function() {\n                        return true;\n                    }\n                };\n                QRTE.questionQueue.push(QuestionStackElement);\n\n                QRTE.startTrial(0);\n\n            });\n\n            QRTE.loadWaitingList = [false];\n            if (QRTE.waitForImageLoad === true) {\n                //set wait for image load queues.\n                var loadIndex = 1,\n                    images = $$('.QuestionOuter img'),\n                    i = 0;\n\n                var l = images.length;\n                for (; i < l; i += 1) {\n                    images[i].observe('load', function(e) {\n                        QRTE.startTrial(e.path[0].QRTELoadIndex);\n                    })\n                    images[i].QRTELoadIndex = i + 1;\n                    QRTE.loadWaitingList[i + 1] = false;\n                }\n\n            }\n\n        },\n\n        /**\n         * Remove the padding Qualtrics adds between Questions (causes question presentation to drift downwards if not called).\n         * DEPRECATED: Separators hidden through CSS now\n         * @method removeSeparators\n         * @private\n         */\n        removeSeparators: function() {\n            var questionElement = document.getElementById('Questions'),\n                index;\n            for (index = 0; index < questionElement.children.length; index += 1) {\n                if (questionElement.children[index].className === \"Separator\") {\n                    questionElement.children[index].parentNode.removeChild(questionElement.children[index]);\n                }\n            }\n        },\n        /**\n         * Notifies the engine the first trial is ready to be started. Called at the end of the 'exit' question\n         * @private\n         * @method startTrial\n         */\n        startTrial: function(startId) {\n            var duringDisplayFn, onHideFn, onDisplayFn, serverCommDelay, remainingDelay;\n            //All questions have been hidden, so display the parent block again\n            //$('Questions').style.display = 'block';\n\n            QRTE.loadWaitingList[startId] = true;\n            if (!QRTE.loadWaitingList.every()) {\n                QRTE.log('Process ' + startId + 'finished, waiting for other processes to finish')\n                return;\n            }\n\n            //Save the absolute time of when onLoad part of library was finished\n            serverCommDelay = window.requestAnimationFrame.now() - QRTE.getBlockData('QRTLib_previousEndTime'); //Calculate the remaining time based on the lib initialization + server delay times\n            remainingDelay = QRTE.getBlockData('QRTLib_intraTrialDelay') - serverCommDelay;\n\n\n            if (isNaN(remainingDelay)) {\n                remainingDelay = QRTE.getBlockData('QRTLib_intraTrialDelay') * 3;\n                //If this init call is the first one of the block (first trial), calculate the estimated refreshdelay during the pre-trial interval\n                onDisplayFn = function(ele, time) {\n                    QRTE.setTrialData('Init[OffsetTime]', ele.displayOnsetTime);\n                    QRTE.setTrialData('Init[CalculatedDuration]', ele.displayOnsetTime - QRTE.getTrialData('Init[OnsetTime]'));\n                    QRTE.refreshPeriodEstimationStack = [];\n                };\n                duringDisplayFn = function(ele, time) {\n                    //Get current time, required for \n                    QRTE.refreshPeriodEstimationStack.push(time);\n                };\n                onHideFn = function(ele, timestamp) {\n                    var diffs = [];\n\n                    for (i = 1; i < QRTE.refreshPeriodEstimationStack.length; i += 1) {\n                        diffs[i - 1] = QRTE.refreshPeriodEstimationStack[i] - QRTE.refreshPeriodEstimationStack[i - 1];\n                    }\n                    QRTE.refreshPeriod = QRTE.median(diffs);\n                    QRTE.log('Estimated refresh delay = ' + QRTE.refreshPeriod);\n                    QRTE.setBlockData('QRTE_refreshPeriod', QRTE.refreshPeriod);\n                    QRTE.referenceTime = timestamp;\n                    QRTE.framesSinceReference = 0;\n                };\n            } else {\n                onDisplayFn = function(ele, time) {\n                    QRTE.setTrialData('Init[OffsetTime]', ele.displayOnsetTime);\n                    QRTE.setTrialData('Init[CalculatedDuration]', ele.displayOnsetTime - QRTE.getTrialData('Init[OnsetTime]'));\n                };\n\n                QRTE.refreshPeriod = QRTE.getBlockData('QRTE_refreshPeriod');\n            }\n\n            //QRTE.setTrialData('ITI[Duration]', (remainingDelay > 0) ? remainingDelay : 0);\n            QRTE.initTime = window.requestAnimationFrame.now();\n\n            QRTE.postInitElement.onHideFn = onHideFn;\n            QRTE.postInitElement.onDisplayFn = onDisplayFn;\n            QRTE.postInitElement.duringDisplayFn = duringDisplayFn;\n            QRTE.setConfig('InitPost', 'duration', (remainingDelay > 0) ? remainingDelay : 0);\n            //UNCOMMENT\n            //QRTE.setConfig('InitPost', 'duration', (remainingDelay > 0) ? remainingDelay : Infinity);\n            QRTE.inited = true;\n\n            //Set initial trial data related to loading of this trial\n            QRTE.setTrialData('InitServerComm[Onset]', QRTE.getBlockData('ServerCommOnset'));\n            QRTE.setTrialData('InitServerComm[Offset]', QRTE.getBlockData('ServerCommOffset'));\n            QRTE.setTrialData('InitServerComm[CalculatedDuration]', QRTE.getBlockData('ServerCommOffset') - QRTE.getBlockData('ServerCommOnset'));\n\n            //<Load next trial here>\n            var currentLoops = '${lm://CurrentLoopNumber}',\n                totalLoops = '${lm://TotalLoops}';\n            //Check if last trial, currentloops === totalLoops;\n            QRTEController.requestNextTrial(currentLoops !== '' && currentLoops === totalLoops);\n\n            QRTE.proceed();\n        },\n\n\n\n        proceed: function() {\n            QRTE.log(\"proceed called after \" + window.requestAnimationFrame.now() - QRTE.initTime);\n            QRTE.hideAllElements();\n        },\n\n        proceedPage: function() {\n            var currentQ;\n            QRTE.log(\"Proceeding page..\");\n            while (QRTE.currentPageQuestions.length > 0) {\n                currentQ = QRTE.currentPageQuestions.shift();\n\n                //Disable\n                currentQ.questionElement.QRTLib_isActive = false;\n            }\n\n\n            //Go to next question\n            QRTE.showNextPage();\n        },\n\n        disableQuestion: function(disableQ) {},\n\n        /**\n         * Determine and show the next page/slide\n         * @private\n         * @method showNextPage\n         */\n        showNextPage: function() {\n            var continueSearch = true,\n                shownQ = false,\n                nextQ,\n                shown;\n            while (continueSearch === true) {\n                continueSearch = false;\n                nextQ = QRTE.questionQueue.shift();\n                if (nextQ !== undefined && (nextQ.type === 'Stimulus' || nextQ.type === 'Storage')) {\n                    QRTE.currentPageQuestions.push(nextQ);\n                    shown = QRTE.showStimulusQuestion.apply(nextQ.questionElement, [nextQ]);\n\n                    if (nextQ.stimContinue) {\n                        continueSearch = true;\n                        if (shown === true) {\n                            shownQ = true;\n                        }\n                    }\n                    QRTE.log('shown ' + nextQ.id + ': ' + shown);\n                    QRTE.log('continue ' + nextQ.id + ': ' + continueSearch);\n                    if (shown === false && shownQ === false) {\n                        continueSearch = true;\n                    }\n                }\n            }\n\n        },\n\n        /**\n         * Show Question\n         * Handles the activation of that question, which includes:\n         * The loading of the configuration (duration, allowable keys etc).\n         * Sets the event handler to respond to any key presses during the event.\n         * @private\n         * @method showStimulusQuestion\n         * @param question {Object} question to be shown.\n         *  @param id {String} Id of question.\n         *  @param onShowFunc {Function} Function to be called when showing question\n         *  @param loadConfig {Boolean} If true, config is loaded from the current block data (which has been defined elsewhere)\n         *  @param questionElement {Object} This Qualtrics question element\n         *  @param duringDisplayFn {Function} Function to be called each frame that the question is presented\n         */\n        showStimulusQuestion: function(question) {\n            //Save the loading start time\n            //QRTE.setTrialData(question.questionElement.QRTLibId + '[LoadStartTime]', window.requestAnimationFrame.now());\n            //Set mapping of the QID -> QRTE Id\n            QRTE.setId(this, question.id);\n\n            //Initialize variables\n            var stimulusShown = false,\n                questionScope = this,\n                dispEle;\n            QRTE.log(question);\n\n            //Check whether question should be shown or not, if not skip to the next question (implicitly)\n            if (question.conditional() === true) {\n                this.QRTLib_isActive = true;\n\n\n                if (question.loadConfig === true) {\n                    //Load the Configuration of the Question, important!\n                    QRTE.loadConfig(this);\n                }\n\n                //Check if KeyPress listener is required (one or more of the following fields are defined: onKeyPress, onCorrectKey or onAllowableKey)\n                //If so, add keypress listener.\n                if (question.onKeyPress !== undefined || question.questionElement.allowable !== '' || question.questionElement.cresp !== '') {\n                    //Initialize the fields used for storing data about RT timing.\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[RTTime]', '');\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[RT]', '');\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[RESP]', '');\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[ACC]', 0);\n\n                    //Add the key listener\n                    QRTE.addKeyListener(function(e) {\n\n                        //Get the Key of the response\n                        var RT, RESP = QRTE.keycode2string(e),\n                            RTTime = window.requestAnimationFrame.now();\n                        RT = RTTime - QRTE.getTrialData(question.questionElement.QRTLibId + '[OnsetTime]');\n\n                        //Store the Time of the Key Press and calculate the RT and ACC if correct\n\n                        if ((QRTE.isAllowableResponse(question.questionElement, RESP) || QRTE.isCorrectResponse(question.questionElement, RESP)) && QRTE.getTrialData(question.questionElement.QRTLibId + '[RTTime]') === '') {\n                            QRTE.setTrialData(question.questionElement.QRTLibId + '[RTTime]', RTTime);\n                            QRTE.setTrialData(question.questionElement.QRTLibId + '[RT]', RT);\n                            QRTE.setTrialData(question.questionElement.QRTLibId + '[RESP]', RESP);\n                            if (QRTE.isCorrectResponse(question.questionElement, RESP)) {\n                                QRTE.saveAcc(question.questionElement, 1);\n                            } else {\n                                QRTE.saveAcc(question.questionElement, 0);\n                            }\n                        }\n\n                        //Store the RT and the Response\n\n                        //Set Handling Key Press to true, this lets the engine know that a keypress is currently being handled. Necessary when there is a timer (response deadline)\n                        question.handlingKeyPress = true;\n\n                        if (question.onCorrectKey !== undefined && QRTE.isCorrectResponse(question.questionElement, RESP)) {\n                            question.onCorrectKey.apply(question.questionElement, [e, RESP]);\n                        } else if (question.onIncorrectKey !== undefined && QRTE.isAllowableResponse(question.questionElement, RESP)) {\n                            question.onIncorrectKey.apply(question.questionElement, [e, RESP]);\n                        }\n\n                        if (question.onAllowableKey !== undefined && QRTE.isAllowableResponse(question.questionElement, RESP)) {\n                            question.onAllowableKey.apply(question.questionElement, [e, RESP]);\n                        }\n\n                        if (question.onKeyPress !== undefined) {\n                            question.onKeyPress.apply(question.questionElement, [e, RESP]);\n                        }\n\n                        if (question.questionElement.endAction === 'TERMINATE') {\n                            //Proceed to the next Question Page if the response is allowable\n                            if (QRTE.isAllowableResponse(question.questionElement, RESP) && question.questionElement.QRTLib_isActive === true) {\n                                question.questionElement.proceed();\n                            }\n                        }\n                        question.handlingKeyPress = false;\n\n                    }, this);\n                }\n\n                //Build the display Element. Stimuli Questions have to take into account the possibility of being associated with a key press. \n                //OnDisplayFn therefore logs the displayOnsetTime, so that the RT can be calculated.\n                dispEle = {\n                    el: this.questionContainer,\n                    duration: this.duration,\n                    delay: this.offset,\n                    duringDisplayFn: question.duringDisplayFn,\n                    onDisplayFn: function(displayEl, timestamp) {\n                        if (question.onDisplayFn !== undefined) {\n                            question.onDisplayFn(displayEl, timestamp);\n                        }\n                        QRTE.setTrialData(questionScope.QRTLibId + '[OnsetTime]', displayEl.displayOnsetTime);\n                    },\n                    proceedOnHide: question.proceedOnHide,\n                    id: question.id\n                };\n\n                //Set the OnHide Function\n                dispEle.onHideFn = function(displayEl, timestamp) {\n                    if (question.onHideFn !== undefined) {\n                        question.onHideFn(displayEl, timestamp);\n                    }\n                    QRTE.setTrialData(questionScope.QRTLibId + '[OffsetTime]', displayEl.displayOffsetTime);\n                    QRTE.setTrialData(questionScope.QRTLibId + '[CalculatedDuration]', displayEl.displayDuration);\n                };\n\n\n                this.QRTLib_timer = QRTE.displayElement(dispEle);\n\n                question.onShowFunc.apply(this);\n\n                stimulusShown = true;\n            }\n\n            //QRTE.setTrialData(question.questionElement.QRTLibId + '[LoadEndTime]', window.requestAnimationFrame.now());\n            return stimulusShown;\n        },\n\n        setId: function(question, desc) {\n\n            this.idCache[question.questionId] = desc;\n            question.qId = desc;\n\n            Qualtrics.SurveyEngine.setEmbeddedData(QRTE.idField, Object.toJSON(this.idCache));\n        },\n\n        getOutputKey: function(key) {\n            var oldKey;\n            for (oldKey in this.idCache) {\n                if (this.idCache.hasOwnProperty(oldKey) && oldKey === key.substring(0, oldKey.length)) {\n\n                    return QRTE.getBlockData('QRTLib_currentBlock') + this.idCache[oldKey] + key.substring(oldKey.length, key.length);\n                }\n            }\n            return key;\n        },\n\n\n        OnKeyPress: function(fn, qScope) {\n\n            qScope = qScope || window;\n\n            var keyFn = function(e) {\n                QRTE.setTrialData(qScope.QRTLibId + '[RTTime]', window.requestAnimationFrame.now());\n                var RT = QRTE.getTrialData(qScope.QRTLibId + '[RTTime]') - QRTE.getTrialData(qScope.QRTLibId + '[OnsetTime]');\n                QRTE.setTrialData(qScope.QRTLibId + '[RT]', RT);\n                QRTE.setTrialData(qScope.QRTLibId + '[RESP]', QRTE.keycode2string(e));\n                QRTE.log(qScope);\n                fn.apply(qScope, [e]);\n            }\n\n            QRTE.addKeyListener(keyFn, qScope);\n        },\n\n        addKeyListener: function(fn, listenerScope) {\n            Event.observe(document, 'keypress', function(e) {\n                if (listenerScope.QRTLib_isActive === true) {\n                    fn.apply(listenerScope, [e]);\n                }\n            });\n        },\n\n        /*  \n         **************Methods below this line are support methods*******************\n         */\n\n        hideQuestions: function() {\n            qArray = $('Questions').getElementsByClassName('QuestionOuter');\n            for (var i = 0; i < qArray.length; i += 1) {\n                qArray[i].style.display = 'none';\n            }\n        },\n\n        unhideQuestions: function() {\n            //Redisplay outer questions\n            qArray = $('Questions').getElementsByClassName('QuestionOuter');\n            for (var i = 0; i < qArray.length; i += 1) {\n                qArray[i].style.display = 'block';\n            }\n            //Redisplay separators\n            qArray = $('Questions').getElementsByClassName('Separator');\n            for (var i = 0; i < qArray.length; i += 1) {\n                qArray[i].style.display = 'block';\n            }\n\n\n        },\n\n        _handleKeyPressEvent: function() {\n\n        },\n\n        _setConfig: function(QID, option, value, setterFunc) {\n            var qidString = QID;\n            if (typeof QID !== 'string') {\n                qidString = QID.questionId;\n            }\n            option = option.toLowerCase();\n\n            switch (option) {\n                case 'duration':\n                    if (value instanceof Array) {\n                        value = value[Math.floor(Math.random() * value.length)];\n                    }\n                    setterFunc.apply(this, [qidString, 'Duration', value]);\n                    break;\n                case 'allowable':\n                    setterFunc.apply(this, [qidString, 'Allowable', value]);\n                    break;\n                case 'cresp':\n                    setterFunc.apply(this, [qidString, 'CRESP', value]);\n                    break;\n                case 'delay':\n                    setterFunc.apply(this, [qidString, 'Offset', value]);\n                    break;\n                case 'endaction':\n                    setterFunc.apply(this, [qidString, 'EndAction', value]);\n                    break;\n                default:\n                    QRTE.log('No such configuration: ' + option);\n                    break;\n            }\n        },\n        getDuration: function(question) {\n            var duration = Infinity,\n                edDuration = this.getTrialData(question.QRTLib_configId + '[Duration]');\n            if (edDuration !== undefined && edDuration !== '' && !isNaN(edDuration)) {\n                duration = edDuration;\n            }\n            if (question._Duration !== undefined && question._Duration !== '' && !isNaN(question._Duration)) {\n                duration = question._Duration;\n            }\n\n            return duration;\n        },\n        getAllowable: function(question) {\n            var allowable = \"\",\n                edAllowable = this.getTrialData(question.QRTLib_configId + '[Allowable]');\n            if (edAllowable !== undefined) {\n                allowable = edAllowable;\n            }\n            if (question._Allowable !== undefined) {\n                allowable = question._Allowable;\n            }\n\n            if (allowable === '{ANY}') {\n                allowable = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890-=[]\\\\;',./`\";\n            }\n            //allowable = allowable.toUpperCase();\n            return allowable;\n        },\n        getCResp: function(question) {\n            var cresp = '',\n                edcresp = this.getTrialData(question.QRTLib_configId + '[CRESP]');\n            if (edcresp !== undefined) {\n                cresp = edcresp;\n            }\n            if (question._cresp !== undefined) {\n                cresp = question._CRESP;\n            }\n\n            if (cresp === '{ANY}') {\n                cresp = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890-=[]\\\\;',./`\";\n            }\n            //cresp = cresp.toUpperCase();\n\n            return cresp;\n        },\n\n        getOffset: function(question) {\n            var offset = 0,\n                edOffset = this.getTrialData(question.QRTLib_configId + '[Offset]');\n            if (edOffset !== undefined && edOffset !== '' && !isNaN(edOffset)) {\n                offset = edOffset;\n            }\n            if (question._Offset !== undefined && question._Offset !== '' && !isNaN(question._Offset)) {\n                offset = question._Offset;\n            }\n\n            return offset;\n\n        },\n\n        getEndAction: function(question) {\n            var endAction = 'NONE',\n                edEndAction = this.getTrialData(question.QRTLib_configId + '[EndAction]');\n            if (edEndAction !== undefined && edEndAction !== '') {\n                endAction = edEndAction;\n            }\n            if (question._EndAction !== undefined && question._EndAction !== '') {\n                endAction = question._EndAction;\n            }\n\n            return endAction;\n\n        },\n        evaluateConditional: function(conditional) {\n            QRTE.log('Conditional: ', conditional);\n            return conditional === '' || conditional();\n        },\n        log: function() {\n            if (QRTE.debug === true) {\n                for (var i = 0; i < arguments.length; i += 1) {\n                    console.log(arguments[i]);\n                }\n            }\n        },\n\n        median: function(values) {\n\n            values.sort(function(a, b) {\n                return a - b;\n            });\n\n            var half = Math.floor(values.length / 2);\n\n            if (values.length % 2) return values[half];\n            else return (values[half - 1] + values[half]) / 2.0;\n        },\n\n        waitForKey: function(question, keys) {\n            Event.observe(document, 'keypress', function(e) {\n                var resp = QRTE.keycode2string(e);\n                if (keys.indexOf(resp) >= 0) {\n                    question.clickNextButton();\n                }\n            });\n        },\n\n        validateParams: function(paramObj, validationArray) {\n            var valObj, val, index, typeCheck = true,\n                indexType;\n            //Loop over validationArray to check whether parameters suffice\n            for (index = 0; index < validationArray.length; index += 1) {\n                valObj = validationArray[index];\n                if (paramObj[valObj.name] === undefined && valObj.required === true) {\n                    alert('Required parameter: ' + valObj.name + ' seems to be missing');\n                    QRTE.log('Required parameter: ' + valObj.name + ' seems to be missing');\n                    break;\n                }\n\n                val = paramObj[valObj.name];\n\n                //Loop over type checkers\n                for (indexType = 0; indexType < valObj.type.length; indexType += 1) {\n                    typeCheck = QRTE.validateType(val, valObj.type[indexType]);\n                    if (typeCheck === true) {\n                        break;\n                    }\n                }\n                if (typeCheck === false && valObj.required === true) {\n                    alert('Parameter: ' + valObj.name + ' is of the wrong type, expected type: ' + valObj.type + ', type received: ' + (typeof val) + \"\\n\" + \"Please open the console for detailed error messages\");\n                    QRTE.log('Parameter: ' + valObj.name + ' is of the wrong type, expected type: ' + valObj.type + ', type received: ' + (typeof val));\n                    QRTE.log('Faulty parameter ' + valObj.name + ': ', val);\n                    QRTE.log('Proper functioning of QRTE is no longer guaranteed, please fix the above error');\n                }\n\n            }\n        },\n\n        validateType: function(val, type) {\n            switch (type) {\n                case 'JSON':\n                    return val.isJSON();\n                case 'String':\n                    return (typeof val === 'string' || val instanceof String);\n                case 'Number':\n                    return (!isNaN(parseFloat(val)) && isFinite(val));\n                case 'Array':\n                    return val instanceof Array;\n                case 'Object':\n                    return typeof val === 'object';\n                case 'Function':\n                    return typeof val === 'function';\n                case 'Boolean':\n                    return (val === true || val === false);\n                case 'Empty':\n                    return val === '';\n                default:\n                    return false;\n            }\n        },\n\n        fixSetEmbeddedDataBug: function() {\n            Qualtrics.SurveyEngine.setEmbeddedData = function(key, value) {\n                var fieldName = 'ED~' + key;\n                if ($(fieldName)) {\n                    $(fieldName).value = value;\n                } else {\n                    $('Header').appendChild(QBuilder('input', {\n                        type: 'hidden',\n                        id: fieldName,\n                        name: fieldName,\n                        value: value\n                    }));\n                    Qualtrics.SurveyEngine.setEmbeddedData(key, value);\n                }\n            }\n        },\n\n        //DisplayEngine part\n\n        //Since it's impossible to know when a screen refresh has happened, we assume that the first timestamp is the actual screen refresh.\n        //Based on the difference between the current timestamp Tn and the root timestamp Tn-1, we estimate the amount of frames that have passed since. \n        //Based on the amount of frames we estimate the previous screen refresh. Although not perfect, it's the best we can do.\n\n        refreshRate: 60, //hertz\n        refreshPeriod: 1000 / 60,\n        lastRefresh: 0,\n        currentRefresh: 0,\n        previousTimestamp: 0,\n        referenceTime: 0,\n        framesSinceReference: 0,\n        currentStack: [],\n        proceedOnFrameEnd: false,\n\n        init: function() {\n            window.requestAnimationFrame(QRTE.draw);\n        },\n\n        draw: function(timestamp) {\n            var curEle, newStack = [];\n            timestamp = window.requestAnimationFrame.now();\n\n\n            if (timestamp < 1e12) {\n                timestamp += window.performance.timing.navigationStart;\n            }\n\n            if (QRTE.referenceTime === 0) {\n                QRTE.referenceTime = timestamp;\n                QRTE.previousTimestamp = timestamp;\n                QRTE.framesSinceReference = 0;\n            } else {\n                //QRTE.framesSinceReference += QRTE.calcFrames(QRTE.referenceTime, timestamp);\n                QRTE.prevFrames = QRTE.framesSinceReference;\n                //frameDiff =  QRTE.calcFrames(QRTE.referenceTime, timestamp) - QRTE.prevFrames;\n                QRTE.framesSinceReference = QRTE.calcFrames(QRTE.referenceTime, timestamp);\n            }\n            QRTE.currentRefresh = (QRTE.framesSinceReference * QRTE.refreshPeriod) + QRTE.referenceTime;\n            QRTE.projectedRefresh = QRTE.currentRefresh + QRTE.refreshPeriod;\n            curEle = QRTE.currentStack.shift();\n\n            while (curEle) {\n                curEle.keep = true;\n\n                //Call duringDisplay callback function, with the current element and the timestamp as arguments.\n                if (curEle.shown === true && typeof curEle.duringDisplayFn === 'function') {\n                    curEle.duringDisplayFn(curEle, timestamp);\n                }\n\n                if (QRTE.proceedOnFrameEnd === true || curEle.hide === true || (curEle.shown === true && curEle.displayOnset !== undefined && (curEle.displayOnset + curEle.duration < QRTE.projectedRefresh))) {\n                    //If the next refresh makes it go beyond the duration, hide the element again!\n                    curEle = QRTE.hideSingleEle(curEle, timestamp);\n                } else if (curEle.shown === false && curEle.requestedAt + curEle.delay < QRTE.projectedRefresh) {\n                    curEle = QRTE.dispSingleEle(curEle, timestamp);\n                }\n\n                if (curEle.keep === false && curEle.proceedOnHide === true) {\n                    //Behold! We have found an element that commands us to proceed to the next page.\n                    QRTE.proceedOnFrameEnd = true;\n                    //Every element that has been processed so far needs to be re-processed (sadly), so that they properly hide.\n                    for (var ind = 0; ind < newStack.length; ind += 1) {\n                        if (newStack[ind].hide !== true) {\n                            newStack[ind].hide = true;\n                            QRTE.currentStack.push(newStack[ind]);\n                        }\n                    }\n                } else {\n                    //Push it to the newStack, for it to be processed next time.\n                    newStack.push(curEle);\n                }\n\n                curEle = QRTE.currentStack.shift();\n            }\n            QRTE.currentStack = newStack;\n            QRTE.lastRefresh = QRTE.currentRefresh;\n            QRTE.previousTimestamp = timestamp;\n            window.requestAnimationFrame(QRTE.draw);\n            if ((newStack.length === 0 || QRTE.proceedOnFrameEnd) && QRTE.inited === true) {\n                QRTE.proceedOnFrameEnd = false;\n                QRTE.proceedPage();\n            }\n\n\n        },\n\n        calcFrames: function(previous, current) {\n            var diff = current - previous,\n                frames = 0;\n\n            if (diff < QRTE.refreshPeriod) {\n                frames = 1;\n            } else {\n                frames = Math.floor(diff / QRTE.refreshPeriod);\n                if (diff % QRTE.refreshPeriod >= (QRTE.refreshPeriod * 0.9)) {\n                    frames += 1;\n                }\n            }\n\n            return frames;\n        },\n\n        /**\n         * Display an element for a specified duration with a specified delay. Vsyncs the display duration using requestAnimationFrame (if possible in the browser)\n         * and allows for high-precision control over its duration. Please start any custom attributes for the paramObj with the 'custom_' header, to avoid collisions.\n         * @private\n         * @method displayElement\n         * @param paramObj {Object}\n         *  @param el {Object} HTML element to be displayed\n         *  @param [onHideFn] {Function} Function to be called upon removing the element from display, is passed one argument containing all information about the display element.\n         *  @param [duration] {Number} Number of milliseconds (ms) the element should be displayed.\n         *  @param [delay] {Number} Number of milliseconds (ms) the Engine should wait before displaying the element.\n         *  @param [duringDisplayFn] {Function} Function to be called upon displaying the element for another screen refresh. Careful: Keep this function simple, could seriously hamper performance as it's called about every 16-17 ms.  is passed one argument containing all information about the display element.\n         *  @param [onDisplayfn] {Function} Function to be called upon starting to display the element. Is passed one argument containing all information about the display element.\n         */\n\n        //displayElement: function(el, callback, duration, offset, duringDisplaycb) {\n        displayElement: function(paramObj) {\n            var reqAt,\n                id = String(Math.random());\n            //QRTE.log(arguments);\n            if (paramObj.delay === undefined) {\n                paramObj.delay = 0;\n            }\n\n\n\n            if (paramObj.duration === undefined) {\n                paramObj = Infinity;\n            }\n\n            if (isNaN(QRTE.lastRefresh)) {\n                reqAt = window.requestAnimationFrame.now();\n            } else {\n                reqAt = QRTE.lastRefresh;\n            }\n            paramObj.userId = paramObj.id;\n            paramObj.id = id;\n            paramObj.shown = false;\n            paramObj.requestedAt = reqAt;\n            paramObj.hide = false;\n\n            QRTE.currentStack.push(paramObj);\n            if (paramObj.delay === 0) {\n                //This element needs to be displayed as soon as possible\n                QRTE.dispSingleEle(paramObj, QRTE.previousTimestamp);\n            }\n            QRTE.log('Added element to display stack:', paramObj);\n            //console.log('paramObj: ', paramObj.userId, ', duration: ', paramObj.duration);\n\n            return id;\n        },\n\n        hideElement: function(id) {\n            var found = false,\n                i;\n            for (i = 0; i < QRTE.currentStack.length; i += 1) {\n                if (QRTE.currentStack[i].id === id) {\n                    found = true;\n                    QRTE.currentStack[i].hide = true;\n                    this.log('Element to be hidden: ', QRTE.currentStack[i]);\n                }\n            }\n            return found;\n        },\n\n        hideAllElements: function() {\n            for (i = 0; i < QRTE.currentStack.length; i += 1) {\n                QRTE.currentStack[i].hide = true;\n            }\n            QRTE.proceedOnFrameEnd = true;\n        },\n\n        /**\n         * Hide a DrawEngine Element\n         * @private\n         * @method hideSingleEle\n         * @param curEle {Object}\n         */\n        hideSingleEle: function(curEle, timestamp) {\n            curEle.displayOffset = QRTE.projectedRefresh;\n            curEle.displayOffsetTime = window.requestAnimationFrame.now();\n            curEle.el.style.display = 'none';\n            curEle.keep = false;\n            curEle.hide = true;\n            //delete QRTE.currentStack[key];\n            curEle.displayDuration = curEle.displayOffsetTime - curEle.displayOnsetTime;\n            if (curEle.onHideFn !== undefined) {\n                curEle.onHideFn(curEle, timestamp);\n            }\n\n            return curEle;\n\n        },\n\n\n        /**\n         * Display a DrawEngine Element\n         * @private\n         * @method dispSingleEle\n         * @param curEle {Object}\n         */\n        dispSingleEle: function(curEle, timestamp) {\n            curEle.el.style.display = 'block';\n            curEle.displayOnset = QRTE.projectedRefresh;\n            curEle.displayOnsetTime = window.requestAnimationFrame.now();\n            curEle.shown = true;\n            if (curEle.onDisplayFn !== undefined) {\n                //Added try-catch block to catch the error that's causing the OnsetTime not to get saved.\n                try {\n                    curEle.onDisplayFn(curEle, timestamp);\n                } catch (e) {\n                    QRTE.setTrialData('Error[OnsetError]', JSON.stringify(e));\n                }\n            }\n            return curEle;\n        },\n\n        checkEngineCompatibility: function() {\n            return window.requestAnimationFrame.method === 'native-highres';\n        },\n    };\n\n    if (typeof QRTEController == 'undefined') {\n        //QRTE SurveySlider controller layer\n        //Takes care of progressing through the survey. Catches all qualtrics native ways of submitting the form and replaces that by\n        //its own asynchronous ajax stuff.\n        QRTEController = {\n\n\n            //This plug-in to QRTEngine has been developed under the name SurveySlider\n            // for general Qualtrics Surveys. It has been adapted to work with QRTEngine\n            nextTrialContainer: null,\n            nextTrialText: '',\n            currentForm: null,\n            previousForm: null,\n            handlingSubmit: false,\n            onSubmitStack: [],\n            inited: false,\n            childInputs: [],\n            loadUponCallback: false,\n            setEmbeddedData: function() {},\n            tempED: {},\n\n\n\n            //Initialize thecontroller\n            init: function() {\n                this.nextTrialContainer = new Element('div', {\n                    id: 'nextTrialContainer'\n                });\n                this.currentForm = $$('form')[0];\n\n                //Catch submits and change it with our own submit function (which does AJAX submissions)\n                //this.currentForm.observe('QRTE:submit', QRTE.handleSubmit);\n                this.currentElements = $$('.QuestionOuter');\n\n                //Initial SSload firing\n                Qualtrics.SurveyEngine.addOnload(function() {\n                    QRTEController.currentForm.fire('QRTE:load');\n                });\n                //Change SurveyEngine.OnLoad to trigger on SSload, rather than page load\n                Qualtrics.SurveyEngine.addOnload = function(f) {\n                        var questions = $$('.QuestionOuter'),\n                            currentCount = QRTEController.count(Qualtrics.SurveyEngine.QuestionInfo),\n                            id = questions[currentCount - 1].id;\n                        if ($('body') && $('body').hasClassName('EditSection')) return;\n                        try {\n                            var obj = new Qualtrics.SurveyEngine.QuestionData(id);\n                            obj.onload = f;\n\n                            QRTEController.currentForm.observe('QRTE:load', obj.onload.bind(obj));\n                            //Event.observe(this.currentForm, 'SSload', obj.onload.bind(obj));\n                        } catch (e) {\n                            console.error('SE API Error: ' + e);\n                        }\n                    }\n                    //Set the Qualtrics setEmbeddedData to inside the QRTEController\n                QRTEController.setEmbeddedData = Qualtrics.SurveyEngine.setEmbeddedData;\n                Qualtrics.SurveyEngine.setEmbeddedData = function(key, value) {\n                    QRTEController.tempED[key] = value;\n                }\n                this.submitPage = this.requestNextTrial;\n                this.inited = true;\n            },\n\n            /**\n             * Requests the next trial from the Qualtrics server.\n             *\n             *\n             */\n            requestNextTrial: function(isLastTrial) {\n\n                //If this is the last trial of a block, DON'T request the next page, let qualtrics handle it themselves\n                if (this.handlingSubmit === false && isLastTrial === false) {\n                    //Load next trial means that current page is a trial and has been inited\n                    //Need to remove relevant input elements from current form before submitting\n                    //After that add them back\n                    this.handlingSubmit = true\n                    var childs = $$('form input[type=text]'),\n                        childInputs = [];\n                    //remove current input elements from the form\n                    for (var i = 0; i < childs.length; i += 1) {\n                        childInputs[i] = {\n                            ele: childs[i],\n                            parent: childs[i].up()\n                        };\n                        childs[i].remove();\n                    }\n                    //add previous input elements to form\n                    //Text inputs\n                    for (var i = 0; i < this.childInputs.length; i += 1) {\n                        this.childInputs[i].ele.style.display = 'none';\n                        this.currentForm.insert(this.childInputs[i].ele);\n                    }\n\n\n                    //And embedded data\n                    for (var key in this.tempED) {\n                        if (this.tempED.hasOwnProperty(key)) {\n                            QRTEController.setEmbeddedData(key, this.tempED[key]);\n                        }\n                    }\n                    //Reset stored embedded data\n                    this.tempED = {};\n                    //set new childs\n                    this.childInputs = childInputs;\n\n                    //Loop over submit stack, or callbacks that need to be finished before submitting\n                    for (var i = 0; i < QRTEController.onSubmitStack.length; i += 1) {\n                        QRTE.onSubmitStack[i]();\n                    }\n                    QRTEController.onSubmitStack = [];\n                    debugger;\n                    this.currentForm.request({\n                        onComplete: this.requestNextTrialCallback\n                    });\n\n                    //Set server comm onset for the next trial\n                    QRTE.setBlockData('ServerCommOnset', window.requestAnimationFrame.now());\n\n                    QRTEController.betweenSubmits = true;\n\n                    for (var i = 0; i < this.childInputs.length; i += 1) {\n                        this.childInputs[i].parent.insert(this.childInputs[i].ele);\n                        this.childInputs[i].ele.style.display = 'none';\n                    }\n                } else if (isLastTrial === true) {\n                    //Just add the previous trial's childInputs to the form \n                    for (var i = 0; i < this.childInputs.length; i += 1) {\n\n                        this.currentForm.insert(this.childInputs[i].ele);\n                        this.childInputs[i].ele.style.display = 'none';\n                    }\n\n                    this.loadNextTrial = function() {\n                        //Directly submitting the form doesn't seem to work? Let's do it through NextButton click\n                        $('NextButton').click();\n                    };\n                }\n            },\n\n            loadNextTrial: function() {\n                if (this.handlingSubmit === true) {\n                    //The submit still hasn't returned..\n                    this.loadUponCallback = true;\n                    return;\n\n                }\n                //Set handling submit to false (as page has been returned)\n                //Save the previous form\n                this.previousForm = this.currentForm;\n                //Reset the QuestionInfo object, this is for Qualtrics to correctly initiate its own page\n                Qualtrics.SurveyEngine.QuestionInfo = {}\n                    //Parse the HTML that was returned earlier and set it as the current trial container's contents\n                this.nextTrialContainer = jQuery(this.nextTrialContainer).html(this.nextTrialText)[0];\n                //Filter out the 'form' field, and append it back.\n                this.currentForm = jQuery(this.nextTrialContainer).find('form')[0];\n                jQuery(this.previousForm).replaceWith(jQuery(this.currentForm));\n\n                jQuery(this.currentForm).show();\n\n                if (this.currentForm.select('.END_OF_SURVEY').length === 0) {\n                    this.currentForm.fire('QRTE:load');\n                    this.submitPage = this.requestNextTrial;\n                } else {\n                    this.submitPage = this.currentForm.submit;\n                }\n\n            },\n\n            requestNextTrialCallback: function(e) {\n                QRTEController.nextTrialText = e.responseText;\n                QRTEController.handlingSubmit = false;\n                QRTE.setBlockData('ServerCommOffset', window.requestAnimationFrame.now());\n\n                if (QRTEController.loadUponCallback === true) {\n                    QRTEController.loadUponCallback = false;\n                    QRTEController.loadNextTrial();\n                }\n            },\n\n            submitPage: function() {\n                console.log('Not yet initialised');\n            },\n\n            count: function(obj) {\n                var count = 0;\n\n                for (var prop in obj) {\n                    if (obj.hasOwnProperty(prop))\n                        ++count;\n                }\n\n                return count;\n            },\n\n            BDCache: {},\n            storeBlockData: function(blockData) {\n                this.BDCache = blockData;\n            },\n\n            loadBlockData: function() {\n                return this.BDCache;\n            }\n        };\n\n        document.observe('dom:loaded', QRTEController.init.bind(QRTEController));\n\n\n        (function() {\n            var lastFrame, method, now, queue, requestAnimationFrame, timer, vendor, _i, _len, _ref, _ref1;\n            method = 'native';\n            now = Date.now || function() {\n                return new Date().getTime();\n            };\n            requestAnimationFrame = window.requestAnimationFrame;\n            _ref = ['webkit', 'moz', 'o', 'ms'];\n            for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n                vendor = _ref[_i];\n                if (!(requestAnimationFrame != null)) {\n                    requestAnimationFrame = window[vendor + \"RequestAnimationFrame\"];\n                }\n            }\n            if (!(requestAnimationFrame != null)) {\n                method = 'timer';\n                lastFrame = 0;\n                queue = timer = null;\n                requestAnimationFrame = function(callback) {\n                    var fire, nextFrame, time;\n                    if (queue != null) {\n                        queue.push(callback);\n                        return;\n                    }\n                    time = now();\n                    nextFrame = Math.max(0, 16.66 - (time - lastFrame));\n                    queue = [callback];\n                    lastFrame = time + nextFrame;\n                    fire = function() {\n                        var cb, q, _j, _len1;\n                        q = queue;\n                        queue = null;\n                        for (_j = 0, _len1 = q.length; _j < _len1; _j++) {\n                            cb = q[_j];\n                            cb(lastFrame);\n                        }\n                    };\n                    timer = setTimeout(fire, nextFrame);\n                };\n            }\n            requestAnimationFrame(function(time) {\n                var _ref1;\n                if ((((_ref1 = window.performance) != null ? _ref1.now : void 0) != null) && time < 1e12) {\n                    requestAnimationFrame.now = function() {\n                        return window.performance.now() + window.performance.timing.navigationStart;\n                    };\n                    requestAnimationFrame.method = 'native-highres';\n                } else {\n                    requestAnimationFrame.now = now;\n                }\n            });\n            requestAnimationFrame.now = ((_ref1 = window.performance) != null ? _ref1.now : void 0) != null ? (function() {\n                return window.performance.now() + window.performance.timing.navigationStart;\n            }) : now;\n            requestAnimationFrame.method = method;\n            window.requestAnimationFrame = requestAnimationFrame;\n        })();\n\n        function loadScript(url, callback) {\n\n            var script = document.createElement(\"script\")\n            script.type = \"text/javascript\";\n\n            if (script.readyState) { //IE\n                script.onreadystatechange = function() {\n                    if (script.readyState == \"loaded\" || script.readyState == \"complete\") {\n                        script.onreadystatechange = null;\n                        callback();\n                    }\n\n                };\n            } else { //Others\n                script.onload = function() {\n                    callback();\n                };\n            }\n\n            script.src = url;\n            document.getElementsByTagName(\"head\")[0].appendChild(script);\n        }\n\n        (function() {\n\n            //jQuery is only required for the Fixation flash fix. prototypejs is unable to efficiently replace elements\n            //and introduces a 10 ms delay between loading element and firing off the scripts. Unacceptable\n            //First time jQuery should be used is the second trial\n\n            loadScript(\"https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js\", function() {\n\n                $.noConflict();\n\n            });\n\n        })();\n\n        //If preview mode is run (PreviewBanner element exists, add a QRTEngine plug with id QRTEPlug)\n\n        if ($('PreviewBanner')) {\n            var plug, row, banner = $('PreviewBanner');\n            //Go down to the first table row inside that banner\n            row = banner.children[0].children[0].children[0];\n            //Insert new cell    \n            plug = row.insertCell(2);\n            plug.id = \"QRTEPlug\";\n            plug.width = \"20%\";\n            plug.innerHTML = 'This survey is proudly and successfully powered by <a href=\"http://qrtengine.com\" target=\"_blank\"><i><b>QRTEngine</b></i></a>';\n            plug.style.textAlign = \"center\";\n        }\n    }","\n    /* ==========================================================\n     * QRTEngine.js v16\n     * ==========================================================\n     * Copyright 2013-2014 Erwin Haasnoot\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     * http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     *\n     *\n     *\n     * ========================================================== */\n    /**\n     * Qualtrics Reaction Time Engine or QRTE is an add-on providing an interface\n     * for easy reaction time experiment creation in the Qualtrics survey research suite (tm).\n     * For instructions on how to use this add-on, see xxxx\n     *\n     * QRTE was developed by Erwin Haasnoot\n     * Email: erwinhaasnoot[at]gmail.com\n     * @class QRTE\n     *\n     */\n    var QRTE = {\n        version: 'v16',\n        columnsField: 'QRTE_columns',\n        blockDataField: 'QRTE_blockData',\n        idField: 'QRTE_idData',\n        exitQuestions: 'QRTE_exitQuestions',\n        inited: false,\n        /**\n         * TDCache contains the Trial-Level Data in an Object. DO NOT directly manipulate this Object. It might cause inconsistencies in the data file and cause unexpected once parsed.\n         * Use QRTE.setTrialData and QRTE.getTrialData instead.\n         *\n         * @property TDCache\n         * @private\n         * @type Object\n         */\n        TDCache: {},\n\n        /**\n         * ColumnCache contains all the mappings from QID to Columns\n         * @property columnCache\n         * @private\n         * @type Object\n         */\n        columnCache: {},\n\n        /**\n         * BDCache contains the BlockLevel Data in an Object. Directly manipulating this Object might cause inconsistencies\n         * @property BDCache\n         * @private\n         * @type Object\n         */\n        BDCache: {},\n\n        /**\n         * SDCache is a cache for speeding up retrieval of Survey level Data,\n         * All Survey data is saved to both Embedded Data and Survey Data\n         * @private\n         * @property SDCache\n         * @type Object\n         */\n        SDCache: {},\n\n        /**\n         * idCache is a cache for quickly retrieving the Qualtrics QID to QRTLib Id mappings.\n         * Saved in the idData embedded data field after every trial.\n         * @private\n         * @property idCache\n         * @type Object\n         */\n        idCache: {},\n\n        /**\n         * questionQueue contains Objects (stimuli) that are waiting to be presented\n         * @private\n         * @property questionQueue\n         * @type Array\n         */\n        questionQueue: [],\n\n        /**\n         * currentPageQuestions contains the Question Objects that are\n         * displayed at any given time.\n         * @private\n         * @property currentPageQuestions\n         * @type Array\n         */\n        currentPageQuestions: [],\n\n        /**\n         * Contains Trial Data Columns that were 'newly' added in this trial run.\n         * @private\n         * @property newlyAddedColumns\n         * @type Array\n         */\n        newlyAddedColumns: [],\n\n        /**\n         * Contains the Post-Initialization Element.\n         * @private\n         * @property postInitElement\n         * @type Object\n         */\n        postInitElement: {},\n\n        /**\n         * Setter function for Trial-Level Data.\n         * @method setTrialData\n         * @param key {String} Key\n         * @param value {Value} Value\n         */\n        setTrialData: function(key, value) {\n            //Store value in trial cache\n            this.TDCache[key] = value;\n            if (this.BDCache.QRTLib_trialColumns[key] === undefined) {\n                //Add column to overall trial data\n                this.BDCache.QRTLib_trialColumns[key] = '';\n                this.newlyAddedColumns.push(key);\n            }\n        },\n\n        /**\n         * Gets the value of Trial-Level Data field 'key\n         * @method getTrialData\n         * @param key {String} Key\n         */\n        getTrialData: function(key) {\n            return this.TDCache[key];\n        },\n\n        /**\n         * Setter function for Block-Level Data.\n         * @method setBlockData\n         * @param key {String} Key\n         * @param value {Value} Value\n         */\n        setBlockData: function(key, value) {\n            this.BDCache[key] = value;\n        },\n\n\n        /**\n         * Gets the value of Block-Level Data field 'key\n         * @method getBlockData\n         * @param key {String} Key\n         */\n        getBlockData: function(key) {\n            return this.BDCache[key];\n        },\n\n\n\n\n        /**\n         * Stringify the Block Data and store it in the Embedded Data Field. This preserves the values stored on Block Level for use in later trials\n         * @method saveBlockData\n         * @param key {String} Key\n         */\n        saveBlockData: function() {\n            //Store blockData in ED so that we can use it next trial\n            QRTEController.storeBlockData(QRTE.BDCache);\n            Qualtrics.SurveyEngine.setEmbeddedData(QRTE.blockDataField, Object.toJSON(QRTE.BDCache));\n        },\n\n\n\n        /**\n         * Setter function for Survey-Level Data (Embedded Data).\n         * @method setSurveyData\n         * @param key {String} Key\n         * @param value {Value} Value\n         */\n        setSurveyData: function(key, value) {\n            this.SDCache[key] = value;\n            Qualtrics.SurveyEngine.setEmbeddedData(key, value);\n        },\n\n\n\n        /**\n         * Gets the value of Survey-Level Data (Embedded Data) 'key'\n         * @method getSurveyData\n         * @param key {String} Key\n         */\n\n        getSurveyData: function(key) {\n            if (this.SDCache[key] !== undefined) {\n                return this.SDCache[key];\n            }\n            //This only works if the Survey Data has been set during the same trial due to a bug in Qualtrics.\n            return Qualtrics.SurveyEngine.getEmbeddedData(key);\n        },\n\n        /**\n         * Sets a configuration for a question\n         * @method setConfig\n         * @param QID {String} The QRTE Question Id of the Question you want the configuration to apply to\n         * @param option {String} The type of configuration you want to set, Allowed options: 'cresp', 'allowable', 'duration', 'endaction', 'delay'. Refer to website for documentation on these configs\n         * @param value {String} The value the configuration needs to be set to. Differs per option.\n         */\n        setConfig: function(QID, option, value) {\n            var setterFunc;\n            if (typeof QID === 'string') {\n                setterFunc = function(QID, option, value) {\n                    this.setTrialData(QID + \"[\" + option + \"]\", value);\n                };\n            } else {\n                setterFunc = function(QID, option, value) {\n                    this.setTrialData(QID.questionId + \"[\" + option + \"]\", value);\n                    QID['_' + option] = value;\n                };\n\n            }\n\n            this._setConfig(QID, option, value, setterFunc);\n        },\n\n\n        /**\n         * Loads the configuration for a question.\n         * @private\n         * @method loadConfig\n         * @param question {Object} Question for which the configuration needs to be loaded.\n         */\n        loadConfig: function(question) {\n            if (this.idCache[question.questionId] !== undefined) {\n                question.QRTLib_configId = this.idCache[question.questionId];\n            } else {\n                question.QRTLib_configId = question.question;\n            }\n            question.duration = this.getDuration(question);\n            question.allowable = this.getAllowable(question);\n            question.cresp = this.getCResp(question);\n            question.offset = this.getOffset(question);\n            question.endAction = this.getEndAction(question);\n        },\n\n        /**\n         * Stores the accuracy of a trial\n         * @private\n         * @method saveAcc\n         * @param question {Object} Question for which accuracy needs to be stored\n         * @param acc {Integer} Accuracy of question\n         */\n\n        saveAcc: function(question, acc) {\n            if (acc === 0 || acc === 1) {\n                this.setTrialData(question.QRTLibId + \"[ACC]\", acc);\n                this.setSurveyData(\"ACC\", acc);\n            }\n        },\n\n\n\n        /**\n         * Check whether the given response was a correct response\n         * @method isCorrectResponse\n         * @param question {Object} Question for which correct response needs to be checked\n         * @param resp {String} Given response\n         */\n        isCorrectResponse: function(question, resp) {\n            return question.cresp.indexOf(resp) >= 0;\n        },\n\n        /**\n         * Check whether the given response was an allowable response\n         * @method isAllowableResponse\n         * @param question {Object} Question for which allowable response needs to be checked\n         * @param resp {String} Given response\n         */\n        isAllowableResponse: function(question, resp) {\n            return question.allowable.indexOf(resp) >= 0;\n        },\n\n\n\n        /**\n         * Check whether the given response was an allowable response\n         * @private\n         * @method keycode2string\n         * @param e {Object} KeyPress event from which to retrieve the response\n         */\n        keycode2string: function(e) {\n            return String.fromCharCode(e.charCode);\n        },\n\n        /** \n         * Wait for images to load before starting trial.\n         * @property waitForImageLoad\n         * @private\n         * @type Boolean\n         */\n\n        waitForImageLoad: true,\n\n        /** \n         * Trial Start waiting list - initialised with waiting for TrialStart\n         * @property loadWaitingList\n         * @private\n         * @type Array\n         */\n\n        loadWaitingList: [false],\n\n        /**\n         * Initializes the Engine, called at the start of the 'Init' question.\n         * @private\n         * @method initLib\n         * @param blockDataString {String} JSON string containing information saved for this block (block-level data)\n         * @param blockId {String} Id of the current block\n         * @param columns {String} JSON string containing information about the columns that have been defined in this block\n         * @param idData {String} JSON string containing information about the mapping of the QID to the name of the question\n         * @param exitQuestions {String} String containing the currently defined QuestionTags of the Exit questions\n         * @param exitItemTag {String} String containing the Tag of this block's Exit question.\n         */\n\n\n        initLib: function(blockDataString, blockId, columns, idData, exitQuestions, exitItemTag) {\n            //var blockDataString = Qualtrics.SurveyEngine.getEmbeddedData(QRTE.blockDataField),\n            //columns = Qualtrics.SurveyEngine.getEmbeddedData(QRTE.columnsField),\n            //idData = Qualtrics.SurveyEngine.getEmbeddedData(QRTE.idField);\n            var glue;\n            QRTE.fixSetEmbeddedDataBug();\n            //Initialise block Data\n            if (blockDataString === undefined columnData || blockDataString === '') {\n                blockDataString = '{}';\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.blockDataField, blockDataString);\n            }\n\n            this.BDCache = QRTEController.loadBlockData(blockDataString);\n\n            if (this.BDCache.QRTLib_currentBlock !== blockId) {\n                //If this is a new block, initialise a new block\n                this.BDCache = {\n                    QRTLib_currentBlock: blockId,\n                    QRTLib_blockCounter: 1,\n                    QRTLib_trialColumns: {}\n                };\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.blockDataField, Object.toJSON(this.BDCache));\n                if (exitQuestions === null) {exitQuestions = '';}\n                glue = '';\n                if (exitQuestions !== '') {\n                    glue = ';';\n                }\n                //And update the exit questions\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.exitQuestions, exitQuestions + glue + exitItemTag);\n\n            }\n            QRTE.TDCache = Object.toJSON(QRTE.getBlockData('QRTLib_trialColumns')).evalJSON();\n            if (columns === undefined || columns === null || columns === '') {\n                columns = '{}';\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.columnsField, columns);\n            }\n            QRTE.SDCache[QRTE.columnsField] = columns.evalJSON();\n            if (idData === undefined || idData === null || idData === '') {\n                idData = '{}';\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.idField, idData);\n            }\n            QRTE.idCache = idData.evalJSON();\n        },\n\n        /**\n         * Init initializes the QRTEngine, expects are params object with possible fields defined with parameters.\n         * @method Init\n         * @param paramObj {Object} object containing parameters of Init function\n         *  @param paramObj.blockData {String} blockData string in json format (from embedded data)\n         *  @param paramObj.columnData {String} columnData string in json format (from embedded data)\n         *  @param paramObj.exitQuestions {String} exitQuestions string (from embedded data)\n         *  @param paramObj.exitItemTag {String} Tag of the Exit question of this block\n         *  @param paramObj.blockId {String} Identificaton of the block\n         *  @param [paramObj.onLoadFn] {Function} Function to be called when this Question is displayed\n         *  @param [paramObj.interTrialDelay] {Integer|Array} Specify millisecond delay between end of previous trial and beginning of new trial\n         *  @param [paramObj.preTrialDelay] {Integer|Array} Specify millisecond (ms) delay before the start of the first trial of the block. //NYI\n         *  @param [paramObj.initQuestionIndex] {Integer} Specify index of the Init question in the Question Block (defaults to 1)\n         *  @param [paramObj.waitForImages] {Boolean} Specify whether we should wait for images or not. Is on by default, but could be turned off if all images are pre-loaded in cache, or are very small in general.\n         */\n        Init: function(paramObj) {\n            var validationArray, qArray, initIndex;\n            //init the library\n            QRTE.init();\n\n            //set the initIndex (if the Init question is not the first question of the block)\n            QRTE.initIndex = paramObj.initQuestionIndex - 1 || 0;\n\n\n            validationArray = [{\n                name: 'blockData',\n                type: ['JSON', 'Empty'],\n                required: true\n            }, {\n                name: 'columnData',\n                type: ['JSON', 'Empty'],\n                required: true\n            }, {\n                name: 'idData',\n                type: ['JSON', 'Empty'],\n                required: true\n            }, {\n                name: 'blockId',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'onLoadFn',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'interTrialDelay',\n                type: ['Integer', 'Array'],\n                required: false\n            }, {\n                name: 'exitQuestions',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'exitItemTag',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'waitForImages',\n                type: ['Boolean'],\n                required: false\n            }];\n\n            //Validate Parameter Object, outputs stuff to console\n            QRTE.validateParams(paramObj, validationArray, 'Init');\n\n\n            //Initialize the library itself (necessary for each trial)\n            QRTE.initLib(paramObj.blockData, paramObj.blockId, paramObj.columnData, paramObj.idData, paramObj.exitQuestions, paramObj.exitItemTag);\n\n\n            if (paramObj.waitForImages !== undefined) {\n                QRTE.waitForImageLoad = paramObj.waitForImages;\n            }\n            //calculate server communication delay\n            QRTE.setTrialData('InitPre[OnsetTime]', QRTE.getBlockData('QRTLib_previousStorageDone'));\n\n            QRTE.setTrialData('InitPre[OffsetTime]', window.requestAnimationFrame.now());\n            QRTE.setTrialData('InitPre[CalculatedDuration]', QRTE.getTrialData('InitPre[OffsetTime]') - QRTE.getTrialData('InitPre[OnsetTime]'));\n            QRTE.setTrialData('Init[OnsetTime]', window.requestAnimationFrame.now());\n\n\n\n            Qualtrics.SurveyEngine.addOnload(function() {\n                this.qHTML = document.getElementById(this.questionId);\n                this.QRTLib_isActive = false;\n                this.hideChoices();\n                this.proceed = QRTE.proceed;\n                this.QRTLibId = 'InitPost';\n\n                paramObj.onLoadFn.apply(this);\n                var QuestionStackElement = {\n                    questionElement: this,\n                    onShowFunc: function() {},\n                    type: 'Stimulus',\n                    loadConfig: true,\n                    id: 'InitPost',\n                    conditional: function() {\n                        return true;\n                    },\n                    proceedOnHide: true\n\n                };\n                QRTE.setConfig(QuestionStackElement.id, 'duration', 0);\n                QRTE.postInitElement = QuestionStackElement;\n                QRTE.questionQueue.push(QuestionStackElement);\n            });\n\n            if (paramObj.interTrialDelay instanceof Array) {\n                paramObj.interTrialDelay = paramObj.interTrialDelay[Math.floor(Math.random() * paramObj.interTrialDelay.length)];\n            }\n            QRTE.setTrialData(paramObj.blockId + '[InterTrialDelay]', paramObj.interTrialDelay);\n            if (paramObj.interTrialDelay > 0) {\n                QRTE.setBlockData('QRTLib_intraTrialDelay', paramObj.interTrialDelay);\n            } else {\n                QRTE.setBlockData('QRTLib_intraTrialDelay', -1);\n            }\n        },\n\n        /**\n         * Create a Stimulus question\n         * @method Stimulus\n         * @param paramObj {Object}\n         *  @param paramObj.id {String} Id of the Question\n         *  @param paramObj.onShowFn {Function} Function to be called upon showing the question (not the same as upon loading)\n         *  @param [paramObj.conditional] {Function} Function to be called with which to decide whether to present this question or not, should return a boolean.\n         *  @param [paramObj.loadConfig] {Boolean} Load predefined config for this question (defaults to true)\n         *  @param [paramObj.stimContinue] {Boolean} Continue looking for stimuli after having seen this one, only if set to true (defaults to false)\n         *  @param [paramObj.onKeyPress] {Function} Function to be called upon receiving a key press while this Question is active (called next to onAllowableKey or onCorrectKey)\n         *  @param [paramObj.onAllowableKey] {Function} Function to be called upon receiving a key press on a key defined as 'allowable' \n         *  @param [paramObj.onCorrectKey] {Function} Function to be called upon receiving a key press on a key defined as 'correct'\n         *  @param [paramObj.onIncorrectKey] {Function} Function to be called upon receiving an allowable key that is not defined as correct (only if correct responses are defined)\n         *  @param [paramObj.proceedOnHide] {Boolean} Set whether all currently displayed elements should be removed on hide, or if only this should be removed from display (Defaults to True). This allows the user to decouple presentation of a stimulus from proceeding of a slide.\n         *  @param [paramObj.onHideFn] {Function} Function to be called upon Stimulus being hidden\n         *  @param [paramObj.duringDisplayFn] {Function} Function to be called during each frame that the Stimulus is being displayed\n         \n         */\n        Stimulus: function(paramObj) {\n            var validationArray = [{\n                name: 'id',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'onShowFn',\n                type: ['Function'],\n                required: true\n            }, {\n                name: 'conditional',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'loadConfig',\n                type: ['Boolean'],\n                required: false\n            }, {\n                name: 'duringDisplayFn',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'continue',\n                type: ['Boolean'],\n                required: false\n            }, {\n                name: 'onAllowableKey',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'onCorrectKey',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'onKeyPress',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'onIncorrectKey',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'proceedOnHide',\n                type: ['Boolean'],\n                required: false\n            }, {\n                name: 'onHideFn',\n                type: ['Function'],\n                required: false\n            }];\n\n            //Validate Parameter Object, outputs stuff to console\n            QRTE.validateParams(paramObj, validationArray, 'Stimulus');\n\n\n            if (paramObj.conditional === undefined) {\n                paramObj.conditional = function() {\n                    return true;\n                };\n            }\n            if (paramObj.loadConfig === undefined) {\n                paramObj.loadConfig = true;\n            }\n\n            if (paramObj.stimContinue === undefined) {\n                paramObj.stimContinue = false;\n            }\n\n            if (paramObj.proceedOnHide === undefined) {\n                paramObj.proceedOnHide = true;\n            }\n            Qualtrics.SurveyEngine.addOnload(function() {\n                this.QRTLib_isActive = false;\n                this.proceed = QRTE.proceed;\n                this.QRTLibId = paramObj.id;\n                var QuestionStackElement = {\n                    questionElement: this,\n                    onShowFunc: paramObj.onShowFn,\n                    duringDisplayFn: paramObj.duringDisplayFn,\n                    onHideFn: paramObj.onHideFn,\n                    type: 'Stimulus',\n                    loadConfig: paramObj.loadConfig,\n                    id: paramObj.id,\n                    conditional: paramObj.conditional,\n                    stimContinue: paramObj.stimContinue,\n                    onAllowableKey: paramObj.onAllowableKey,\n                    onCorrectKey: paramObj.onCorrectKey,\n                    onKeyPress: paramObj.onKeyPress,\n                    onIncorrectKey: paramObj.onIncorrectKey,\n                    proceedOnHide: paramObj.proceedOnHide\n                };\n                QRTE.questionQueue.push(QuestionStackElement);\n            });\n        },\n\n        /**\n         * Exit denotes the end of the block. Important for the initialization phase and the exit phase.\n         * Make the question a Form question with precisely 2 answer fields (more is unnecessary, those will get ignored)\n         * @method Exit\n         */\n        Exit: function() {\n\n\n            qArray = $('Questions').getElementsByClassName('QuestionOuter');\n            for (var i = 0; i < qArray.length && i < QRTE.initIndex + 1; i += 1) {\n                qArray[i].style.display = 'block';\n            }\n            Qualtrics.SurveyEngine.addOnload(function() {\n                //Hide all choice\n                this.hideChoices();\n                //display the question\n                //this.questionContainer.style.display = 'none';\n                var QuestionStackElement, onShowFn;\n                onShowFn = function() {\n\n                    //Create and/or store standard information about the trial\n                    var blockId = QRTE.getBlockData('QRTLib_currentBlock'),\n                        tempTD = {},\n                        key,\n                        i;\n\n                    QRTE.setBlockData('QRTLib_previousEndTime', window.requestAnimationFrame.now());\n                    QRTE.setTrialData(blockId + '[TrialNr]', QRTE.getBlockData('QRTLib_blockCounter'));\n                    QRTE.setTrialData(blockId + '[RefreshPeriod]', QRTE.refreshPeriod);\n                    QRTE.setTrialData('BlockId', blockId);\n                    QRTE.setTrialData('EngineType', window.requestAnimationFrame.method);\n                    QRTE.setTrialData('Exit[OnsetTime]', window.requestAnimationFrame.now());\n                    QRTE.setTrialData('QRTEngine[Version]', QRTE.version);\n\n                    //CHECK IF ATLEAST TWO FORM FIELDS HAVE BEEN DEFINED\n                    this.setChoiceValue(2, 'testtest');\n                    if (this.getChoiceValue(2) !== 'testtest') {\n                        //alert('You need to define two answer form fields in the Exit question!!');\n                    }\n\n                    for (key in QRTE.TDCache) {\n                        if (QRTE.TDCache.hasOwnProperty(key) && key !== '') {\n                            //Change QID thingies to entered ID's, also force every value to a string so that the Parser handles high numerical values correctly\n                            tempTD[QRTE.getOutputKey(key)] = String(QRTE.TDCache[key]);\n                        }\n                    }\n\n                    this.setChoiceValue(1, Object.toJSON(tempTD));\n                    this.setChoiceValue(2, blockId);\n                    if (QRTE.SDCache[QRTE.columnsField][blockId] === undefined) {\n                        QRTE.SDCache[QRTE.columnsField][blockId] = [];\n                    }\n                    for (i = 0; i < QRTE.newlyAddedColumns.length; i += 1) {\n                        QRTE.SDCache[QRTE.columnsField][blockId].push(QRTE.getOutputKey(QRTE.newlyAddedColumns[i]));\n                    }\n\n                    QRTE.setSurveyData(QRTE.columnsField, Object.toJSON(QRTE.SDCache[QRTE.columnsField]));\n                    QRTE.setBlockData('QRTLib_blockCounter', QRTE.getBlockData('QRTLib_blockCounter') + 1);\n                    QRTE.setBlockData('QRTLib_previousStorageDone', window.requestAnimationFrame.now());\n                    QRTE.saveBlockData();\n\n                    //If wanting to test, uncomment this line and comment the one after that to enforce manual nextbutton clicks\n                    //$('NextButton').style.display = 'block';\n                    //QRTE.submitPage();\n                    QRTEController.loadNextTrial();\n                };\n\n                QuestionStackElement = {\n                    questionElement: this,\n                    onShowFunc: onShowFn,\n                    type: 'Storage',\n                    loadConfig: true,\n                    conditional: function() {\n                        return true;\n                    }\n                };\n                QRTE.questionQueue.push(QuestionStackElement);\n\n                QRTE.startTrial(0);\n\n            });\n\n            QRTE.loadWaitingList = [false];\n            if (QRTE.waitForImageLoad === true) {\n                //set wait for image load queues.\n                var loadIndex = 1,\n                    images = $$('.QuestionOuter img'),\n                    i = 0;\n\n                var l = images.length;\n                for (; i < l; i += 1) {\n                    images[i].observe('load', function(e) {\n                        QRTE.startTrial(e.path[0].QRTELoadIndex);\n                    })\n                    images[i].QRTELoadIndex = i + 1;\n                    QRTE.loadWaitingList[i + 1] = false;\n                }\n\n            }\n\n        },\n\n        /**\n         * Remove the padding Qualtrics adds between Questions (causes question presentation to drift downwards if not called).\n         * DEPRECATED: Separators hidden through CSS now\n         * @method removeSeparators\n         * @private\n         */\n        removeSeparators: function() {\n            var questionElement = document.getElementById('Questions'),\n                index;\n            for (index = 0; index < questionElement.children.length; index += 1) {\n                if (questionElement.children[index].className === \"Separator\") {\n                    questionElement.children[index].parentNode.removeChild(questionElement.children[index]);\n                }\n            }\n        },\n        /**\n         * Notifies the engine the first trial is ready to be started. Called at the end of the 'exit' question\n         * @private\n         * @method startTrial\n         */\n        startTrial: function(startId) {\n            var duringDisplayFn, onHideFn, onDisplayFn, serverCommDelay, remainingDelay;\n            //All questions have been hidden, so display the parent block again\n            //$('Questions').style.display = 'block';\n\n            QRTE.loadWaitingList[startId] = true;\n            if (!QRTE.loadWaitingList.every()) {\n                QRTE.log('Process ' + startId + 'finished, waiting for other processes to finish')\n                return;\n            }\n\n            //Save the absolute time of when onLoad part of library was finished\n            serverCommDelay = window.requestAnimationFrame.now() - QRTE.getBlockData('QRTLib_previousEndTime'); //Calculate the remaining time based on the lib initialization + server delay times\n            remainingDelay = QRTE.getBlockData('QRTLib_intraTrialDelay') - serverCommDelay;\n\n\n            if (isNaN(remainingDelay)) {\n                remainingDelay = QRTE.getBlockData('QRTLib_intraTrialDelay') * 3;\n                //If this init call is the first one of the block (first trial), calculate the estimated refreshdelay during the pre-trial interval\n                onDisplayFn = function(ele, time) {\n                    QRTE.setTrialData('Init[OffsetTime]', ele.displayOnsetTime);\n                    QRTE.setTrialData('Init[CalculatedDuration]', ele.displayOnsetTime - QRTE.getTrialData('Init[OnsetTime]'));\n                    QRTE.refreshPeriodEstimationStack = [];\n                };\n                duringDisplayFn = function(ele, time) {\n                    //Get current time, required for \n                    QRTE.refreshPeriodEstimationStack.push(time);\n                };\n                onHideFn = function(ele, timestamp) {\n                    var diffs = [];\n\n                    for (i = 1; i < QRTE.refreshPeriodEstimationStack.length; i += 1) {\n                        diffs[i - 1] = QRTE.refreshPeriodEstimationStack[i] - QRTE.refreshPeriodEstimationStack[i - 1];\n                    }\n                    QRTE.refreshPeriod = QRTE.median(diffs);\n                    QRTE.log('Estimated refresh delay = ' + QRTE.refreshPeriod);\n                    QRTE.setBlockData('QRTE_refreshPeriod', QRTE.refreshPeriod);\n                    QRTE.referenceTime = timestamp;\n                    QRTE.framesSinceReference = 0;\n                };\n            } else {\n                onDisplayFn = function(ele, time) {\n                    QRTE.setTrialData('Init[OffsetTime]', ele.displayOnsetTime);\n                    QRTE.setTrialData('Init[CalculatedDuration]', ele.displayOnsetTime - QRTE.getTrialData('Init[OnsetTime]'));\n                };\n\n                QRTE.refreshPeriod = QRTE.getBlockData('QRTE_refreshPeriod');\n            }\n\n            //QRTE.setTrialData('ITI[Duration]', (remainingDelay > 0) ? remainingDelay : 0);\n            QRTE.initTime = window.requestAnimationFrame.now();\n\n            QRTE.postInitElement.onHideFn = onHideFn;\n            QRTE.postInitElement.onDisplayFn = onDisplayFn;\n            QRTE.postInitElement.duringDisplayFn = duringDisplayFn;\n            QRTE.setConfig('InitPost', 'duration', (remainingDelay > 0) ? remainingDelay : 0);\n            //UNCOMMENT\n            //QRTE.setConfig('InitPost', 'duration', (remainingDelay > 0) ? remainingDelay : Infinity);\n            QRTE.inited = true;\n\n            //Set initial trial data related to loading of this trial\n            QRTE.setTrialData('InitServerComm[Onset]', QRTE.getBlockData('ServerCommOnset'));\n            QRTE.setTrialData('InitServerComm[Offset]', QRTE.getBlockData('ServerCommOffset'));\n            QRTE.setTrialData('InitServerComm[CalculatedDuration]', QRTE.getBlockData('ServerCommOffset') - QRTE.getBlockData('ServerCommOnset'));\n\n            //<Load next trial here>\n            var currentLoops = '${lm://CurrentLoopNumber}',\n                totalLoops = '${lm://TotalLoops}';\n            //Check if last trial, currentloops === totalLoops;\n            QRTEController.requestNextTrial(currentLoops !== '' && currentLoops === totalLoops);\n\n            QRTE.proceed();\n        },\n\n\n\n        proceed: function() {\n            QRTE.log(\"proceed called after \" + window.requestAnimationFrame.now() - QRTE.initTime);\n            QRTE.hideAllElements();\n        },\n\n        proceedPage: function() {\n            var currentQ;\n            QRTE.log(\"Proceeding page..\");\n            while (QRTE.currentPageQuestions.length > 0) {\n                currentQ = QRTE.currentPageQuestions.shift();\n\n                //Disable\n                currentQ.questionElement.QRTLib_isActive = false;\n            }\n\n\n            //Go to next question\n            QRTE.showNextPage();\n        },\n\n        disableQuestion: function(disableQ) {},\n\n        /**\n         * Determine and show the next page/slide\n         * @private\n         * @method showNextPage\n         */\n        showNextPage: function() {\n            var continueSearch = true,\n                shownQ = false,\n                nextQ,\n                shown;\n            while (continueSearch === true) {\n                continueSearch = false;\n                nextQ = QRTE.questionQueue.shift();\n                if (nextQ !== undefined && (nextQ.type === 'Stimulus' || nextQ.type === 'Storage')) {\n                    QRTE.currentPageQuestions.push(nextQ);\n                    shown = QRTE.showStimulusQuestion.apply(nextQ.questionElement, [nextQ]);\n\n                    if (nextQ.stimContinue) {\n                        continueSearch = true;\n                        if (shown === true) {\n                            shownQ = true;\n                        }\n                    }\n                    QRTE.log('shown ' + nextQ.id + ': ' + shown);\n                    QRTE.log('continue ' + nextQ.id + ': ' + continueSearch);\n                    if (shown === false && shownQ === false) {\n                        continueSearch = true;\n                    }\n                }\n            }\n\n        },\n\n        /**\n         * Show Question\n         * Handles the activation of that question, which includes:\n         * The loading of the configuration (duration, allowable keys etc).\n         * Sets the event handler to respond to any key presses during the event.\n         * @private\n         * @method showStimulusQuestion\n         * @param question {Object} question to be shown.\n         *  @param id {String} Id of question.\n         *  @param onShowFunc {Function} Function to be called when showing question\n         *  @param loadConfig {Boolean} If true, config is loaded from the current block data (which has been defined elsewhere)\n         *  @param questionElement {Object} This Qualtrics question element\n         *  @param duringDisplayFn {Function} Function to be called each frame that the question is presented\n         */\n        showStimulusQuestion: function(question) {\n            //Save the loading start time\n            //QRTE.setTrialData(question.questionElement.QRTLibId + '[LoadStartTime]', window.requestAnimationFrame.now());\n            //Set mapping of the QID -> QRTE Id\n            QRTE.setId(this, question.id);\n\n            //Initialize variables\n            var stimulusShown = false,\n                questionScope = this,\n                dispEle;\n            QRTE.log(question);\n\n            //Check whether question should be shown or not, if not skip to the next question (implicitly)\n            if (question.conditional() === true) {\n                this.QRTLib_isActive = true;\n\n\n                if (question.loadConfig === true) {\n                    //Load the Configuration of the Question, important!\n                    QRTE.loadConfig(this);\n                }\n\n                //Check if KeyPress listener is required (one or more of the following fields are defined: onKeyPress, onCorrectKey or onAllowableKey)\n                //If so, add keypress listener.\n                if (question.onKeyPress !== undefined || question.questionElement.allowable !== '' || question.questionElement.cresp !== '') {\n                    //Initialize the fields used for storing data about RT timing.\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[RTTime]', '');\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[RT]', '');\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[RESP]', '');\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[ACC]', 0);\n\n                    //Add the key listener\n                    QRTE.addKeyListener(function(e) {\n\n                        //Get the Key of the response\n                        var RT, RESP = QRTE.keycode2string(e),\n                            RTTime = window.requestAnimationFrame.now();\n                        RT = RTTime - QRTE.getTrialData(question.questionElement.QRTLibId + '[OnsetTime]');\n\n                        //Store the Time of the Key Press and calculate the RT and ACC if correct\n\n                        if ((QRTE.isAllowableResponse(question.questionElement, RESP) || QRTE.isCorrectResponse(question.questionElement, RESP)) && QRTE.getTrialData(question.questionElement.QRTLibId + '[RTTime]') === '') {\n                            QRTE.setTrialData(question.questionElement.QRTLibId + '[RTTime]', RTTime);\n                            QRTE.setTrialData(question.questionElement.QRTLibId + '[RT]', RT);\n                            QRTE.setTrialData(question.questionElement.QRTLibId + '[RESP]', RESP);\n                            if (QRTE.isCorrectResponse(question.questionElement, RESP)) {\n                                QRTE.saveAcc(question.questionElement, 1);\n                            } else {\n                                QRTE.saveAcc(question.questionElement, 0);\n                            }\n                        }\n\n                        //Store the RT and the Response\n\n                        //Set Handling Key Press to true, this lets the engine know that a keypress is currently being handled. Necessary when there is a timer (response deadline)\n                        question.handlingKeyPress = true;\n\n                        if (question.onCorrectKey !== undefined && QRTE.isCorrectResponse(question.questionElement, RESP)) {\n                            question.onCorrectKey.apply(question.questionElement, [e, RESP]);\n                        } else if (question.onIncorrectKey !== undefined && QRTE.isAllowableResponse(question.questionElement, RESP)) {\n                            question.onIncorrectKey.apply(question.questionElement, [e, RESP]);\n                        }\n\n                        if (question.onAllowableKey !== undefined && QRTE.isAllowableResponse(question.questionElement, RESP)) {\n                            question.onAllowableKey.apply(question.questionElement, [e, RESP]);\n                        }\n\n                        if (question.onKeyPress !== undefined) {\n                            question.onKeyPress.apply(question.questionElement, [e, RESP]);\n                        }\n\n                        if (question.questionElement.endAction === 'TERMINATE') {\n                            //Proceed to the next Question Page if the response is allowable\n                            if (QRTE.isAllowableResponse(question.questionElement, RESP) && question.questionElement.QRTLib_isActive === true) {\n                                question.questionElement.proceed();\n                            }\n                        }\n                        question.handlingKeyPress = false;\n\n                    }, this);\n                }\n\n                //Build the display Element. Stimuli Questions have to take into account the possibility of being associated with a key press. \n                //OnDisplayFn therefore logs the displayOnsetTime, so that the RT can be calculated.\n                dispEle = {\n                    el: this.questionContainer,\n                    duration: this.duration,\n                    delay: this.offset,\n                    duringDisplayFn: question.duringDisplayFn,\n                    onDisplayFn: function(displayEl, timestamp) {\n                        if (question.onDisplayFn !== undefined) {\n                            question.onDisplayFn(displayEl, timestamp);\n                        }\n                        QRTE.setTrialData(questionScope.QRTLibId + '[OnsetTime]', displayEl.displayOnsetTime);\n                    },\n                    proceedOnHide: question.proceedOnHide,\n                    id: question.id\n                };\n\n                //Set the OnHide Function\n                dispEle.onHideFn = function(displayEl, timestamp) {\n                    if (question.onHideFn !== undefined) {\n                        question.onHideFn(displayEl, timestamp);\n                    }\n                    QRTE.setTrialData(questionScope.QRTLibId + '[OffsetTime]', displayEl.displayOffsetTime);\n                    QRTE.setTrialData(questionScope.QRTLibId + '[CalculatedDuration]', displayEl.displayDuration);\n                };\n\n\n                this.QRTLib_timer = QRTE.displayElement(dispEle);\n\n                question.onShowFunc.apply(this);\n\n                stimulusShown = true;\n            }\n\n            //QRTE.setTrialData(question.questionElement.QRTLibId + '[LoadEndTime]', window.requestAnimationFrame.now());\n            return stimulusShown;\n        },\n\n        setId: function(question, desc) {\n\n            this.idCache[question.questionId] = desc;\n            question.qId = desc;\n\n            Qualtrics.SurveyEngine.setEmbeddedData(QRTE.idField, Object.toJSON(this.idCache));\n        },\n\n        getOutputKey: function(key) {\n            var oldKey;\n            for (oldKey in this.idCache) {\n                if (this.idCache.hasOwnProperty(oldKey) && oldKey === key.substring(0, oldKey.length)) {\n\n                    return QRTE.getBlockData('QRTLib_currentBlock') + this.idCache[oldKey] + key.substring(oldKey.length, key.length);\n                }\n            }\n            return key;\n        },\n\n\n        OnKeyPress: function(fn, qScope) {\n\n            qScope = qScope || window;\n\n            var keyFn = function(e) {\n                QRTE.setTrialData(qScope.QRTLibId + '[RTTime]', window.requestAnimationFrame.now());\n                var RT = QRTE.getTrialData(qScope.QRTLibId + '[RTTime]') - QRTE.getTrialData(qScope.QRTLibId + '[OnsetTime]');\n                QRTE.setTrialData(qScope.QRTLibId + '[RT]', RT);\n                QRTE.setTrialData(qScope.QRTLibId + '[RESP]', QRTE.keycode2string(e));\n                QRTE.log(qScope);\n                fn.apply(qScope, [e]);\n            }\n\n            QRTE.addKeyListener(keyFn, qScope);\n        },\n\n        addKeyListener: function(fn, listenerScope) {\n            Event.observe(document, 'keypress', function(e) {\n                if (listenerScope.QRTLib_isActive === true) {\n                    fn.apply(listenerScope, [e]);\n                }\n            });\n        },\n\n        /*  \n         **************Methods below this line are support methods*******************\n         */\n\n        hideQuestions: function() {\n            qArray = $('Questions').getElementsByClassName('QuestionOuter');\n            for (var i = 0; i < qArray.length; i += 1) {\n                qArray[i].style.display = 'none';\n            }\n        },\n\n        unhideQuestions: function() {\n            //Redisplay outer questions\n            qArray = $('Questions').getElementsByClassName('QuestionOuter');\n            for (var i = 0; i < qArray.length; i += 1) {\n                qArray[i].style.display = 'block';\n            }\n            //Redisplay separators\n            qArray = $('Questions').getElementsByClassName('Separator');\n            for (var i = 0; i < qArray.length; i += 1) {\n                qArray[i].style.display = 'block';\n            }\n\n\n        },\n\n        _handleKeyPressEvent: function() {\n\n        },\n\n        _setConfig: function(QID, option, value, setterFunc) {\n            var qidString = QID;\n            if (typeof QID !== 'string') {\n                qidString = QID.questionId;\n            }\n            option = option.toLowerCase();\n\n            switch (option) {\n                case 'duration':\n                    if (value instanceof Array) {\n                        value = value[Math.floor(Math.random() * value.length)];\n                    }\n                    setterFunc.apply(this, [qidString, 'Duration', value]);\n                    break;\n                case 'allowable':\n                    setterFunc.apply(this, [qidString, 'Allowable', value]);\n                    break;\n                case 'cresp':\n                    setterFunc.apply(this, [qidString, 'CRESP', value]);\n                    break;\n                case 'delay':\n                    setterFunc.apply(this, [qidString, 'Offset', value]);\n                    break;\n                case 'endaction':\n                    setterFunc.apply(this, [qidString, 'EndAction', value]);\n                    break;\n                default:\n                    QRTE.log('No such configuration: ' + option);\n                    break;\n            }\n        },\n        getDuration: function(question) {\n            var duration = Infinity,\n                edDuration = this.getTrialData(question.QRTLib_configId + '[Duration]');\n            if (edDuration !== undefined && edDuration !== '' && !isNaN(edDuration)) {\n                duration = edDuration;\n            }\n            if (question._Duration !== undefined && question._Duration !== '' && !isNaN(question._Duration)) {\n                duration = question._Duration;\n            }\n\n            return duration;\n        },\n        getAllowable: function(question) {\n            var allowable = \"\",\n                edAllowable = this.getTrialData(question.QRTLib_configId + '[Allowable]');\n            if (edAllowable !== undefined) {\n                allowable = edAllowable;\n            }\n            if (question._Allowable !== undefined) {\n                allowable = question._Allowable;\n            }\n\n            if (allowable === '{ANY}') {\n                allowable = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890-=[]\\\\;',./`\";\n            }\n            //allowable = allowable.toUpperCase();\n            return allowable;\n        },\n        getCResp: function(question) {\n            var cresp = '',\n                edcresp = this.getTrialData(question.QRTLib_configId + '[CRESP]');\n            if (edcresp !== undefined) {\n                cresp = edcresp;\n            }\n            if (question._cresp !== undefined) {\n                cresp = question._CRESP;\n            }\n\n            if (cresp === '{ANY}') {\n                cresp = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890-=[]\\\\;',./`\";\n            }\n            //cresp = cresp.toUpperCase();\n\n            return cresp;\n        },\n\n        getOffset: function(question) {\n            var offset = 0,\n                edOffset = this.getTrialData(question.QRTLib_configId + '[Offset]');\n            if (edOffset !== undefined && edOffset !== '' && !isNaN(edOffset)) {\n                offset = edOffset;\n            }\n            if (question._Offset !== undefined && question._Offset !== '' && !isNaN(question._Offset)) {\n                offset = question._Offset;\n            }\n\n            return offset;\n\n        },\n\n        getEndAction: function(question) {\n            var endAction = 'NONE',\n                edEndAction = this.getTrialData(question.QRTLib_configId + '[EndAction]');\n            if (edEndAction !== undefined && edEndAction !== '') {\n                endAction = edEndAction;\n            }\n            if (question._EndAction !== undefined && question._EndAction !== '') {\n                endAction = question._EndAction;\n            }\n\n            return endAction;\n\n        },\n        evaluateConditional: function(conditional) {\n            QRTE.log('Conditional: ', conditional);\n            return conditional === '' || conditional();\n        },\n        log: function() {\n            if (QRTE.debug === true) {\n                for (var i = 0; i < arguments.length; i += 1) {\n                    console.log(arguments[i]);\n                }\n            }\n        },\n\n        median: function(values) {\n\n            values.sort(function(a, b) {\n                return a - b;\n            });\n\n            var half = Math.floor(values.length / 2);\n\n            if (values.length % 2) return values[half];\n            else return (values[half - 1] + values[half]) / 2.0;\n        },\n\n        waitForKey: function(question, keys) {\n            Event.observe(document, 'keypress', function(e) {\n                var resp = QRTE.keycode2string(e);\n                if (keys.indexOf(resp) >= 0) {\n                    question.clickNextButton();\n                }\n            });\n        },\n\n        validateParams: function(paramObj, validationArray) {\n            var valObj, val, index, typeCheck = true,\n                indexType;\n            //Loop over validationArray to check whether parameters suffice\n            for (index = 0; index < validationArray.length; index += 1) {\n                valObj = validationArray[index];\n                if (paramObj[valObj.name] === undefined && valObj.required === true) {\n                    alert('Required parameter: ' + valObj.name + ' seems to be missing');\n                    QRTE.log('Required parameter: ' + valObj.name + ' seems to be missing');\n                    break;\n                }\n\n                val = paramObj[valObj.name];\n\n                //Loop over type checkers\n                for (indexType = 0; indexType < valObj.type.length; indexType += 1) {\n                    typeCheck = QRTE.validateType(val, valObj.type[indexType]);\n                    if (typeCheck === true) {\n                        break;\n                    }\n                }\n                if (typeCheck === false && valObj.required === true) {\n                    alert('Parameter: ' + valObj.name + ' is of the wrong type, expected type: ' + valObj.type + ', type received: ' + (typeof val) + \"\\n\" + \"Please open the console for detailed error messages\");\n                    QRTE.log('Parameter: ' + valObj.name + ' is of the wrong type, expected type: ' + valObj.type + ', type received: ' + (typeof val));\n                    QRTE.log('Faulty parameter ' + valObj.name + ': ', val);\n                    QRTE.log('Proper functioning of QRTE is no longer guaranteed, please fix the above error');\n                }\n\n            }\n        },\n\n        validateType: function(val, type) {\n            switch (type) {\n                case 'JSON':\n                    return val.isJSON();\n                case 'String':\n                    return (typeof val === 'string' || val instanceof String);\n                case 'Number':\n                    return (!isNaN(parseFloat(val)) && isFinite(val));\n                case 'Array':\n                    return val instanceof Array;\n                case 'Object':\n                    return typeof val === 'object';\n                case 'Function':\n                    return typeof val === 'function';\n                case 'Boolean':\n                    return (val === true || val === false);\n                case 'Empty':\n                    return val === '';\n                default:\n                    return false;\n            }\n        },\n\n        fixSetEmbeddedDataBug: function() {\n            Qualtrics.SurveyEngine.setEmbeddedData = function(key, value) {\n                var fieldName = 'ED~' + key;\n                if ($(fieldName)) {\n                    $(fieldName).value = value;\n                } else {\n                    $('Header').appendChild(QBuilder('input', {\n                        type: 'hidden',\n                        id: fieldName,\n                        name: fieldName,\n                        value: value\n                    }));\n                    Qualtrics.SurveyEngine.setEmbeddedData(key, value);\n                }\n            }\n        },\n\n        //DisplayEngine part\n\n        //Since it's impossible to know when a screen refresh has happened, we assume that the first timestamp is the actual screen refresh.\n        //Based on the difference between the current timestamp Tn and the root timestamp Tn-1, we estimate the amount of frames that have passed since. \n        //Based on the amount of frames we estimate the previous screen refresh. Although not perfect, it's the best we can do.\n\n        refreshRate: 60, //hertz\n        refreshPeriod: 1000 / 60,\n        lastRefresh: 0,\n        currentRefresh: 0,\n        previousTimestamp: 0,\n        referenceTime: 0,\n        framesSinceReference: 0,\n        currentStack: [],\n        proceedOnFrameEnd: false,\n\n        init: function() {\n            window.requestAnimationFrame(QRTE.draw);\n        },\n\n        draw: function(timestamp) {\n            var curEle, newStack = [];\n            timestamp = window.requestAnimationFrame.now();\n\n\n            if (timestamp < 1e12) {\n                timestamp += window.performance.timing.navigationStart;\n            }\n\n            if (QRTE.referenceTime === 0) {\n                QRTE.referenceTime = timestamp;\n                QRTE.previousTimestamp = timestamp;\n                QRTE.framesSinceReference = 0;\n            } else {\n                //QRTE.framesSinceReference += QRTE.calcFrames(QRTE.referenceTime, timestamp);\n                QRTE.prevFrames = QRTE.framesSinceReference;\n                //frameDiff =  QRTE.calcFrames(QRTE.referenceTime, timestamp) - QRTE.prevFrames;\n                QRTE.framesSinceReference = QRTE.calcFrames(QRTE.referenceTime, timestamp);\n            }\n            QRTE.currentRefresh = (QRTE.framesSinceReference * QRTE.refreshPeriod) + QRTE.referenceTime;\n            QRTE.projectedRefresh = QRTE.currentRefresh + QRTE.refreshPeriod;\n            curEle = QRTE.currentStack.shift();\n\n            while (curEle) {\n                curEle.keep = true;\n\n                //Call duringDisplay callback function, with the current element and the timestamp as arguments.\n                if (curEle.shown === true && typeof curEle.duringDisplayFn === 'function') {\n                    curEle.duringDisplayFn(curEle, timestamp);\n                }\n\n                if (QRTE.proceedOnFrameEnd === true || curEle.hide === true || (curEle.shown === true && curEle.displayOnset !== undefined && (curEle.displayOnset + curEle.duration < QRTE.projectedRefresh))) {\n                    //If the next refresh makes it go beyond the duration, hide the element again!\n                    curEle = QRTE.hideSingleEle(curEle, timestamp);\n                } else if (curEle.shown === false && curEle.requestedAt + curEle.delay < QRTE.projectedRefresh) {\n                    curEle = QRTE.dispSingleEle(curEle, timestamp);\n                }\n\n                if (curEle.keep === false && curEle.proceedOnHide === true) {\n                    //Behold! We have found an element that commands us to proceed to the next page.\n                    QRTE.proceedOnFrameEnd = true;\n                    //Every element that has been processed so far needs to be re-processed (sadly), so that they properly hide.\n                    for (var ind = 0; ind < newStack.length; ind += 1) {\n                        if (newStack[ind].hide !== true) {\n                            newStack[ind].hide = true;\n                            QRTE.currentStack.push(newStack[ind]);\n                        }\n                    }\n                } else {\n                    //Push it to the newStack, for it to be processed next time.\n                    newStack.push(curEle);\n                }\n\n                curEle = QRTE.currentStack.shift();\n            }\n            QRTE.currentStack = newStack;\n            QRTE.lastRefresh = QRTE.currentRefresh;\n            QRTE.previousTimestamp = timestamp;\n            window.requestAnimationFrame(QRTE.draw);\n            if ((newStack.length === 0 || QRTE.proceedOnFrameEnd) && QRTE.inited === true) {\n                QRTE.proceedOnFrameEnd = false;\n                QRTE.proceedPage();\n            }\n\n\n        },\n\n        calcFrames: function(previous, current) {\n            var diff = current - previous,\n                frames = 0;\n\n            if (diff < QRTE.refreshPeriod) {\n                frames = 1;\n            } else {\n                frames = Math.floor(diff / QRTE.refreshPeriod);\n                if (diff % QRTE.refreshPeriod >= (QRTE.refreshPeriod * 0.9)) {\n                    frames += 1;\n                }\n            }\n\n            return frames;\n        },\n\n        /**\n         * Display an element for a specified duration with a specified delay. Vsyncs the display duration using requestAnimationFrame (if possible in the browser)\n         * and allows for high-precision control over its duration. Please start any custom attributes for the paramObj with the 'custom_' header, to avoid collisions.\n         * @private\n         * @method displayElement\n         * @param paramObj {Object}\n         *  @param el {Object} HTML element to be displayed\n         *  @param [onHideFn] {Function} Function to be called upon removing the element from display, is passed one argument containing all information about the display element.\n         *  @param [duration] {Number} Number of milliseconds (ms) the element should be displayed.\n         *  @param [delay] {Number} Number of milliseconds (ms) the Engine should wait before displaying the element.\n         *  @param [duringDisplayFn] {Function} Function to be called upon displaying the element for another screen refresh. Careful: Keep this function simple, could seriously hamper performance as it's called about every 16-17 ms.  is passed one argument containing all information about the display element.\n         *  @param [onDisplayfn] {Function} Function to be called upon starting to display the element. Is passed one argument containing all information about the display element.\n         */\n\n        //displayElement: function(el, callback, duration, offset, duringDisplaycb) {\n        displayElement: function(paramObj) {\n            var reqAt,\n                id = String(Math.random());\n            //QRTE.log(arguments);\n            if (paramObj.delay === undefined) {\n                paramObj.delay = 0;\n            }\n\n\n\n            if (paramObj.duration === undefined) {\n                paramObj = Infinity;\n            }\n\n            if (isNaN(QRTE.lastRefresh)) {\n                reqAt = window.requestAnimationFrame.now();\n            } else {\n                reqAt = QRTE.lastRefresh;\n            }\n            paramObj.userId = paramObj.id;\n            paramObj.id = id;\n            paramObj.shown = false;\n            paramObj.requestedAt = reqAt;\n            paramObj.hide = false;\n\n            QRTE.currentStack.push(paramObj);\n            if (paramObj.delay === 0) {\n                //This element needs to be displayed as soon as possible\n                QRTE.dispSingleEle(paramObj, QRTE.previousTimestamp);\n            }\n            QRTE.log('Added element to display stack:', paramObj);\n            //console.log('paramObj: ', paramObj.userId, ', duration: ', paramObj.duration);\n\n            return id;\n        },\n\n        hideElement: function(id) {\n            var found = false,\n                i;\n            for (i = 0; i < QRTE.currentStack.length; i += 1) {\n                if (QRTE.currentStack[i].id === id) {\n                    found = true;\n                    QRTE.currentStack[i].hide = true;\n                    this.log('Element to be hidden: ', QRTE.currentStack[i]);\n                }\n            }\n            return found;\n        },\n\n        hideAllElements: function() {\n            for (i = 0; i < QRTE.currentStack.length; i += 1) {\n                QRTE.currentStack[i].hide = true;\n            }\n            QRTE.proceedOnFrameEnd = true;\n        },\n\n        /**\n         * Hide a DrawEngine Element\n         * @private\n         * @method hideSingleEle\n         * @param curEle {Object}\n         */\n        hideSingleEle: function(curEle, timestamp) {\n            curEle.displayOffset = QRTE.projectedRefresh;\n            curEle.displayOffsetTime = window.requestAnimationFrame.now();\n            curEle.el.style.display = 'none';\n            curEle.keep = false;\n            curEle.hide = true;\n            //delete QRTE.currentStack[key];\n            curEle.displayDuration = curEle.displayOffsetTime - curEle.displayOnsetTime;\n            if (curEle.onHideFn !== undefined) {\n                curEle.onHideFn(curEle, timestamp);\n            }\n\n            return curEle;\n\n        },\n\n\n        /**\n         * Display a DrawEngine Element\n         * @private\n         * @method dispSingleEle\n         * @param curEle {Object}\n         */\n        dispSingleEle: function(curEle, timestamp) {\n            curEle.el.style.display = 'block';\n            curEle.displayOnset = QRTE.projectedRefresh;\n            curEle.displayOnsetTime = window.requestAnimationFrame.now();\n            curEle.shown = true;\n            if (curEle.onDisplayFn !== undefined) {\n                //Added try-catch block to catch the error that's causing the OnsetTime not to get saved.\n                try {\n                    curEle.onDisplayFn(curEle, timestamp);\n                } catch (e) {\n                    QRTE.setTrialData('Error[OnsetError]', JSON.stringify(e));\n                }\n            }\n            return curEle;\n        },\n\n        checkEngineCompatibility: function() {\n            return window.requestAnimationFrame.method === 'native-highres';\n        },\n    };\n\n    if (typeof QRTEController == 'undefined') {\n        //QRTE SurveySlider controller layer\n        //Takes care of progressing through the survey. Catches all qualtrics native ways of submitting the form and replaces that by\n        //its own asynchronous ajax stuff.\n        QRTEController = {\n\n\n            //This plug-in to QRTEngine has been developed under the name SurveySlider\n            // for general Qualtrics Surveys. It has been adapted to work with QRTEngine\n            nextTrialContainer: null,\n            nextTrialText: '',\n            currentForm: null,\n            previousForm: null,\n            handlingSubmit: false,\n            onSubmitStack: [],\n            inited: false,\n            childInputs: [],\n            loadUponCallback: false,\n            setEmbeddedData: function() {},\n            tempED: {},\n\n\n\n            //Initialize thecontroller\n            init: function() {\n                this.nextTrialContainer = new Element('div', {\n                    id: 'nextTrialContainer'\n                });\n                this.currentForm = $$('form')[0];\n\n                //Catch submits and change it with our own submit function (which does AJAX submissions)\n                //this.currentForm.observe('QRTE:submit', QRTE.handleSubmit);\n                this.currentElements = $$('.QuestionOuter');\n\n                //Initial SSload firing\n                Qualtrics.SurveyEngine.addOnload(function() {\n                    QRTEController.currentForm.fire('QRTE:load');\n                });\n                //Change SurveyEngine.OnLoad to trigger on SSload, rather than page load\n                Qualtrics.SurveyEngine.addOnload = function(f) {\n                        var questions = $$('.QuestionOuter'),\n                            currentCount = QRTEController.count(Qualtrics.SurveyEngine.QuestionInfo),\n                            id = questions[currentCount - 1].id;\n                        if ($('body') && $('body').hasClassName('EditSection')) return;\n                        try {\n                            var obj = new Qualtrics.SurveyEngine.QuestionData(id);\n                            obj.onload = f;\n\n                            QRTEController.currentForm.observe('QRTE:load', obj.onload.bind(obj));\n                            //Event.observe(this.currentForm, 'SSload', obj.onload.bind(obj));\n                        } catch (e) {\n                            console.error('SE API Error: ' + e);\n                        }\n                    }\n                    //Set the Qualtrics setEmbeddedData to inside the QRTEController\n                QRTEController.setEmbeddedData = Qualtrics.SurveyEngine.setEmbeddedData;\n                Qualtrics.SurveyEngine.setEmbeddedData = function(key, value) {\n                    QRTEController.tempED[key] = value;\n                }\n                this.submitPage = this.requestNextTrial;\n                this.inited = true;\n            },\n\n            /**\n             * Requests the next trial from the Qualtrics server.\n             *\n             *\n             */\n            requestNextTrial: function(isLastTrial) {\n\n                //If this is the last trial of a block, DON'T request the next page, let qualtrics handle it themselves\n                if (this.handlingSubmit === false && isLastTrial === false) {\n                    //Load next trial means that current page is a trial and has been inited\n                    //Need to remove relevant input elements from current form before submitting\n                    //After that add them back\n                    this.handlingSubmit = true\n                    var childs = $$('form input[type=text]'),\n                        childInputs = [];\n                    //remove current input elements from the form\n                    for (var i = 0; i < childs.length; i += 1) {\n                        childInputs[i] = {\n                            ele: childs[i],\n                            parent: childs[i].up()\n                        };\n                        childs[i].remove();\n                    }\n                    //add previous input elements to form\n                    //Text inputs\n                    for (var i = 0; i < this.childInputs.length; i += 1) {\n                        this.childInputs[i].ele.style.display = 'none';\n                        this.currentForm.insert(this.childInputs[i].ele);\n                    }\n\n\n                    //And embedded data\n                    for (var key in this.tempED) {\n                        if (this.tempED.hasOwnProperty(key)) {\n                            QRTEController.setEmbeddedData(key, this.tempED[key]);\n                        }\n                    }\n                    //Reset stored embedded data\n                    this.tempED = {};\n                    //set new childs\n                    this.childInputs = childInputs;\n\n                    //Loop over submit stack, or callbacks that need to be finished before submitting\n                    for (var i = 0; i < QRTEController.onSubmitStack.length; i += 1) {\n                        QRTE.onSubmitStack[i]();\n                    }\n                    QRTEController.onSubmitStack = [];\n                    debugger;\n                    this.currentForm.request({\n                        onComplete: this.requestNextTrialCallback\n                    });\n\n                    //Set server comm onset for the next trial\n                    QRTE.setBlockData('ServerCommOnset', window.requestAnimationFrame.now());\n\n                    QRTEController.betweenSubmits = true;\n\n                    for (var i = 0; i < this.childInputs.length; i += 1) {\n                        this.childInputs[i].parent.insert(this.childInputs[i].ele);\n                        this.childInputs[i].ele.style.display = 'none';\n                    }\n                } else if (isLastTrial === true) {\n                    //Just add the previous trial's childInputs to the form \n                    for (var i = 0; i < this.childInputs.length; i += 1) {\n\n                        this.currentForm.insert(this.childInputs[i].ele);\n                        this.childInputs[i].ele.style.display = 'none';\n                    }\n\n                    this.loadNextTrial = function() {\n                        //Directly submitting the form doesn't seem to work? Let's do it through NextButton click\n                        $('NextButton').click();\n                    };\n                }\n            },\n\n            loadNextTrial: function() {\n                if (this.handlingSubmit === true) {\n                    //The submit still hasn't returned..\n                    this.loadUponCallback = true;\n                    return;\n\n                }\n                //Set handling submit to false (as page has been returned)\n                //Save the previous form\n                this.previousForm = this.currentForm;\n                //Reset the QuestionInfo object, this is for Qualtrics to correctly initiate its own page\n                Qualtrics.SurveyEngine.QuestionInfo = {}\n                    //Parse the HTML that was returned earlier and set it as the current trial container's contents\n                this.nextTrialContainer = jQuery(this.nextTrialContainer).html(this.nextTrialText)[0];\n                //Filter out the 'form' field, and append it back.\n                this.currentForm = jQuery(this.nextTrialContainer).find('form')[0];\n                jQuery(this.previousForm).replaceWith(jQuery(this.currentForm));\n\n                jQuery(this.currentForm).show();\n\n                if (this.currentForm.select('.END_OF_SURVEY').length === 0) {\n                    this.currentForm.fire('QRTE:load');\n                    this.submitPage = this.requestNextTrial;\n                } else {\n                    this.submitPage = this.currentForm.submit;\n                }\n\n            },\n\n            requestNextTrialCallback: function(e) {\n                QRTEController.nextTrialText = e.responseText;\n                QRTEController.handlingSubmit = false;\n                QRTE.setBlockData('ServerCommOffset', window.requestAnimationFrame.now());\n\n                if (QRTEController.loadUponCallback === true) {\n                    QRTEController.loadUponCallback = false;\n                    QRTEController.loadNextTrial();\n                }\n            },\n\n            submitPage: function() {\n                console.log('Not yet initialised');\n            },\n\n            count: function(obj) {\n                var count = 0;\n\n                for (var prop in obj) {\n                    if (obj.hasOwnProperty(prop))\n                        ++count;\n                }\n\n                return count;\n            },\n\n            BDCache: {},\n            storeBlockData: function(blockData) {\n                this.BDCache = blockData;\n            },\n\n            loadBlockData: function() {\n                return this.BDCache;\n            }\n        };\n\n        document.observe('dom:loaded', QRTEController.init.bind(QRTEController));\n\n\n        (function() {\n            var lastFrame, method, now, queue, requestAnimationFrame, timer, vendor, _i, _len, _ref, _ref1;\n            method = 'native';\n            now = Date.now || function() {\n                return new Date().getTime();\n            };\n            requestAnimationFrame = window.requestAnimationFrame;\n            _ref = ['webkit', 'moz', 'o', 'ms'];\n            for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n                vendor = _ref[_i];\n                if (!(requestAnimationFrame != null)) {\n                    requestAnimationFrame = window[vendor + \"RequestAnimationFrame\"];\n                }\n            }\n            if (!(requestAnimationFrame != null)) {\n                method = 'timer';\n                lastFrame = 0;\n                queue = timer = null;\n                requestAnimationFrame = function(callback) {\n                    var fire, nextFrame, time;\n                    if (queue != null) {\n                        queue.push(callback);\n                        return;\n                    }\n                    time = now();\n                    nextFrame = Math.max(0, 16.66 - (time - lastFrame));\n                    queue = [callback];\n                    lastFrame = time + nextFrame;\n                    fire = function() {\n                        var cb, q, _j, _len1;\n                        q = queue;\n                        queue = null;\n                        for (_j = 0, _len1 = q.length; _j < _len1; _j++) {\n                            cb = q[_j];\n                            cb(lastFrame);\n                        }\n                    };\n                    timer = setTimeout(fire, nextFrame);\n                };\n            }\n            requestAnimationFrame(function(time) {\n                var _ref1;\n                if ((((_ref1 = window.performance) != null ? _ref1.now : void 0) != null) && time < 1e12) {\n                    requestAnimationFrame.now = function() {\n                        return window.performance.now() + window.performance.timing.navigationStart;\n                    };\n                    requestAnimationFrame.method = 'native-highres';\n                } else {\n                    requestAnimationFrame.now = now;\n                }\n            });\n            requestAnimationFrame.now = ((_ref1 = window.performance) != null ? _ref1.now : void 0) != null ? (function() {\n                return window.performance.now() + window.performance.timing.navigationStart;\n            }) : now;\n            requestAnimationFrame.method = method;\n            window.requestAnimationFrame = requestAnimationFrame;\n        })();\n\n        function loadScript(url, callback) {\n\n            var script = document.createElement(\"script\")\n            script.type = \"text/javascript\";\n\n            if (script.readyState) { //IE\n                script.onreadystatechange = function() {\n                    if (script.readyState == \"loaded\" || script.readyState == \"complete\") {\n                        script.onreadystatechange = null;\n                        callback();\n                    }\n\n                };\n            } else { //Others\n                script.onload = function() {\n                    callback();\n                };\n            }\n\n            script.src = url;\n            document.getElementsByTagName(\"head\")[0].appendChild(script);\n        }\n\n        (function() {\n\n            //jQuery is only required for the Fixation flash fix. prototypejs is unable to efficiently replace elements\n            //and introduces a 10 ms delay between loading element and firing off the scripts. Unacceptable\n            //First time jQuery should be used is the second trial\n\n            loadScript(\"https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js\", function() {\n\n                $.noConflict();\n\n            });\n\n        })();\n\n        //If preview mode is run (PreviewBanner element exists, add a QRTEngine plug with id QRTEPlug)\n\n        if ($('PreviewBanner')) {\n            var plug, row, banner = $('PreviewBanner');\n            //Go down to the first table row inside that banner\n            row = banner.children[0].children[0].children[0];\n            //Insert new cell    \n            plug = row.insertCell(2);\n            plug.id = \"QRTEPlug\";\n            plug.width = \"20%\";\n            plug.innerHTML = 'This survey is proudly and successfully powered by <a href=\"http://qrtengine.com\" target=\"_blank\"><i><b>QRTEngine</b></i></a>';\n            plug.style.textAlign = \"center\";\n        }\n    }","void 0 === 0","void 0","void 3","void 2","void 1","void","void 0","document.observe","    /** ==========================================================\n     * QRTEngine.js v16\n     * ==========================================================\n     * Copyright 2013-2014 Erwin Haasnoot\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     * http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     *\n     *\n     *\n     * ========================================================== */\n    /**\n     * Qualtrics Reaction Time Engine or QRTE is an add-on providing an interface\n     * for easy reaction time experiment creation in the Qualtrics survey research suite (tm).\n     * For instructions on how to use this add-on, see xxxx\n     *\n     * QRTE was developed by Erwin Haasnoot\n     * Email: erwinhaasnoot[at]gmail.com\n     * @class QRTE\n     *\n     */\n     \n    var QRTE = {\n        version: 'v16',\n        columnsField: 'QRTE_columns',\n        blockDataField: 'QRTE_blockData',\n        idField: 'QRTE_idData',\n        exitQuestions: 'QRTE_exitQuestions',\n        inited: false,\n        /**\n         * TDCache contains the Trial-Level Data in an Object. DO NOT directly manipulate this Object. It might cause inconsistencies in the data file and cause unexpected once parsed.\n         * Use QRTE.setTrialData and QRTE.getTrialData instead.\n         *\n         * @property TDCache\n         * @private\n         * @type Object\n         */\n        TDCache: {},\n\n        /**\n         * ColumnCache contains all the mappings from QID to Columns\n         * @property columnCache\n         * @private\n         * @type Object\n         */\n        columnCache: {},\n\n        /**\n         * BDCache contains the BlockLevel Data in an Object. Directly manipulating this Object might cause inconsistencies\n         * @property BDCache\n         * @private\n         * @type Object\n         */\n        BDCache: {},\n\n        /**\n         * SDCache is a cache for speeding up retrieval of Survey level Data,\n         * All Survey data is saved to both Embedded Data and Survey Data\n         * @private\n         * @property SDCache\n         * @type Object\n         */\n        SDCache: {},\n\n        /**\n         * idCache is a cache for quickly retrieving the Qualtrics QID to QRTLib Id mappings.\n         * Saved in the idData embedded data field after every trial.\n         * @private\n         * @property idCache\n         * @type Object\n         */\n        idCache: {},\n\n        /**\n         * questionQueue contains Objects (stimuli) that are waiting to be presented\n         * @private\n         * @property questionQueue\n         * @type Array\n         */\n        questionQueue: [],\n\n        /**\n         * currentPageQuestions contains the Question Objects that are\n         * displayed at any given time.\n         * @private\n         * @property currentPageQuestions\n         * @type Array\n         */\n        currentPageQuestions: [],\n\n        /**\n         * Contains Trial Data Columns that were 'newly' added in this trial run.\n         * @private\n         * @property newlyAddedColumns\n         * @type Array\n         */\n        newlyAddedColumns: [],\n\n        /**\n         * Contains the Post-Initialization Element.\n         * @private\n         * @property postInitElement\n         * @type Object\n         */\n        postInitElement: {},\n\n        /**\n         * Setter function for Trial-Level Data.\n         * @method setTrialData\n         * @param key {String} Key\n         * @param value {Value} Value\n         */\n        setTrialData: function(key, value) {\n            //Store value in trial cache\n            this.TDCache[key] = value;\n            if (this.BDCache.QRTLib_trialColumns[key] === undefined) {\n                //Add column to overall trial data\n                this.BDCache.QRTLib_trialColumns[key] = '';\n                this.newlyAddedColumns.push(key);\n            }\n        },\n\n        /**\n         * Gets the value of Trial-Level Data field 'key\n         * @method getTrialData\n         * @param key {String} Key\n         */\n        getTrialData: function(key) {\n            return this.TDCache[key];\n        },\n\n        /**\n         * Setter function for Block-Level Data.\n         * @method setBlockData\n         * @param key {String} Key\n         * @param value {Value} Value\n         */\n        setBlockData: function(key, value) {\n            this.BDCache[key] = value;\n        },\n\n\n        /**\n         * Gets the value of Block-Level Data field 'key\n         * @method getBlockData\n         * @param key {String} Key\n         */\n        getBlockData: function(key) {\n            return this.BDCache[key];\n        },\n\n\n\n\n        /**\n         * Stringify the Block Data and store it in the Embedded Data Field. This preserves the values stored on Block Level for use in later trials\n         * @method saveBlockData\n         * @param key {String} Key\n         */\n        saveBlockData: function() {\n            //Store blockData in ED so that we can use it next trial\n            QRTEController.storeBlockData(QRTE.BDCache);\n            Qualtrics.SurveyEngine.setEmbeddedData(QRTE.blockDataField, Object.toJSON(QRTE.BDCache));\n        },\n\n\n\n        /**\n         * Setter function for Survey-Level Data (Embedded Data).\n         * @method setSurveyData\n         * @param key {String} Key\n         * @param value {Value} Value\n         */\n        setSurveyData: function(key, value) {\n            this.SDCache[key] = value;\n            Qualtrics.SurveyEngine.setEmbeddedData(key, value);\n        },\n\n\n\n        /**\n         * Gets the value of Survey-Level Data (Embedded Data) 'key'\n         * @method getSurveyData\n         * @param key {String} Key\n         */\n\n        getSurveyData: function(key) {\n            if (this.SDCache[key] !== undefined) {\n                return this.SDCache[key];\n            }\n            //This only works if the Survey Data has been set during the same trial due to a bug in Qualtrics.\n            return Qualtrics.SurveyEngine.getEmbeddedData(key);\n        },\n\n        /**\n         * Sets a configuration for a question\n         * @method setConfig\n         * @param QID {String} The QRTE Question Id of the Question you want the configuration to apply to\n         * @param option {String} The type of configuration you want to set, Allowed options: 'cresp', 'allowable', 'duration', 'endaction', 'delay'. Refer to website for documentation on these configs\n         * @param value {String} The value the configuration needs to be set to. Differs per option.\n         */\n        setConfig: function(QID, option, value) {\n            var setterFunc;\n            if (typeof QID === 'string') {\n                setterFunc = function(QID, option, value) {\n                    this.setTrialData(QID + \"[\" + option + \"]\", value);\n                };\n            } else {\n                setterFunc = function(QID, option, value) {\n                    this.setTrialData(QID.questionId + \"[\" + option + \"]\", value);\n                    QID['_' + option] = value;\n                };\n\n            }\n\n            this._setConfig(QID, option, value, setterFunc);\n        },\n\n\n        /**\n         * Loads the configuration for a question.\n         * @private\n         * @method loadConfig\n         * @param question {Object} Question for which the configuration needs to be loaded.\n         */\n        loadConfig: function(question) {\n            if (this.idCache[question.questionId] !== undefined) {\n                question.QRTLib_configId = this.idCache[question.questionId];\n            } else {\n                question.QRTLib_configId = question.question;\n            }\n            question.duration = this.getDuration(question);\n            question.allowable = this.getAllowable(question);\n            question.cresp = this.getCResp(question);\n            question.offset = this.getOffset(question);\n            question.endAction = this.getEndAction(question);\n        },\n\n        /**\n         * Stores the accuracy of a trial\n         * @private\n         * @method saveAcc\n         * @param question {Object} Question for which accuracy needs to be stored\n         * @param acc {Integer} Accuracy of question\n         */\n\n        saveAcc: function(question, acc) {\n            if (acc === 0 || acc === 1) {\n                this.setTrialData(question.QRTLibId + \"[ACC]\", acc);\n                this.setSurveyData(\"ACC\", acc);\n            }\n        },\n\n\n\n        /**\n         * Check whether the given response was a correct response\n         * @method isCorrectResponse\n         * @param question {Object} Question for which correct response needs to be checked\n         * @param resp {String} Given response\n         */\n        isCorrectResponse: function(question, resp) {\n            return question.cresp.indexOf(resp) >= 0;\n        },\n\n        /**\n         * Check whether the given response was an allowable response\n         * @method isAllowableResponse\n         * @param question {Object} Question for which allowable response needs to be checked\n         * @param resp {String} Given response\n         */\n        isAllowableResponse: function(question, resp) {\n            return question.allowable.indexOf(resp) >= 0;\n        },\n\n\n\n        /**\n         * Check whether the given response was an allowable response\n         * @private\n         * @method keycode2string\n         * @param e {Object} KeyPress event from which to retrieve the response\n         */\n        keycode2string: function(e) {\n            return String.fromCharCode(e.charCode);\n        },\n\n        /** \n         * Wait for images to load before starting trial.\n         * @property waitForImageLoad\n         * @private\n         * @type Boolean\n         */\n\n        waitForImageLoad: true,\n\n        /** \n         * Trial Start waiting list - initialised with waiting for TrialStart\n         * @property loadWaitingList\n         * @private\n         * @type Array\n         */\n\n        loadWaitingList: [false],\n\n        /**\n         * Initializes the Engine, called at the start of the 'Init' question.\n         * @private\n         * @method initLib\n         * @param blockDataString {String} JSON string containing information saved for this block (block-level data)\n         * @param blockId {String} Id of the current block\n         * @param columns {String} JSON string containing information about the columns that have been defined in this block\n         * @param idData {String} JSON string containing information about the mapping of the QID to the name of the question\n         * @param exitQuestions {String} String containing the currently defined QuestionTags of the Exit questions\n         * @param exitItemTag {String} String containing the Tag of this block's Exit question.\n         */\n\n\n        initLib: function(blockDataString, blockId, columns, idData, exitQuestions, exitItemTag) {\n            //var blockDataString = Qualtrics.SurveyEngine.getEmbeddedData(QRTE.blockDataField),\n            //columns = Qualtrics.SurveyEngine.getEmbeddedData(QRTE.columnsField),\n            //idData = Qualtrics.SurveyEngine.getEmbeddedData(QRTE.idField);\n            var glue;\n            QRTE.fixSetEmbeddedDataBug();\n            //Initialise block Data\n            if (blockDataString === undefined || blockDataString === null || blockDataString === '') {\n                blockDataString = '{}';\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.blockDataField, blockDataString);\n            }\n\n            this.BDCache = QRTEController.loadBlockData(blockDataString);\n\n            if (this.BDCache.QRTLib_currentBlock !== blockId) {\n                //If this is a new block, initialise a new block\n                this.BDCache = {\n                    QRTLib_currentBlock: blockId,\n                    QRTLib_blockCounter: 1,\n                    QRTLib_trialColumns: {}\n                };\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.blockDataField, Object.toJSON(this.BDCache));\n                if (exitQuestions === null) {exitQuestions = '';}\n                glue = '';\n                if (exitQuestions !== '') {\n                    glue = ';';\n                }\n                //And update the exit questions\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.exitQuestions, exitQuestions + glue + exitItemTag);\n\n            }\n            QRTE.TDCache = Object.toJSON(QRTE.getBlockData('QRTLib_trialColumns')).evalJSON();\n            if (columns === undefined || columns === null || columns === '') {\n                columns = '{}';\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.columnsField, columns);\n            }\n            QRTE.SDCache[QRTE.columnsField] = columns.evalJSON();\n            if (idData === undefined || idData === null || idData === '') {\n                idData = '{}';\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.idField, idData);\n            }\n            QRTE.idCache = idData.evalJSON();\n        },\n\n        /**\n         * Init initializes the QRTEngine, expects are params object with possible fields defined with parameters.\n         * @method Init\n         * @param paramObj {Object} object containing parameters of Init function\n         *  @param paramObj.blockData {String} blockData string in json format (from embedded data)\n         *  @param paramObj.columnData {String} columnData string in json format (from embedded data)\n         *  @param paramObj.exitQuestions {String} exitQuestions string (from embedded data)\n         *  @param paramObj.exitItemTag {String} Tag of the Exit question of this block\n         *  @param paramObj.blockId {String} Identificaton of the block\n         *  @param [paramObj.onLoadFn] {Function} Function to be called when this Question is displayed\n         *  @param [paramObj.interTrialDelay] {Integer|Array} Specify millisecond delay between end of previous trial and beginning of new trial\n         *  @param [paramObj.preTrialDelay] {Integer|Array} Specify millisecond (ms) delay before the start of the first trial of the block. //NYI\n         *  @param [paramObj.initQuestionIndex] {Integer} Specify index of the Init question in the Question Block (defaults to 1)\n         *  @param [paramObj.waitForImages] {Boolean} Specify whether we should wait for images or not. Is on by default, but could be turned off if all images are pre-loaded in cache, or are very small in general.\n         */\n        Init: function(paramObj) {\n            var validationArray, qArray, initIndex;\n            //init the library\n            QRTE.init();\n\n            //set the initIndex (if the Init question is not the first question of the block)\n            QRTE.initIndex = paramObj.initQuestionIndex - 1 || 0;\n\n\n            validationArray = [{\n                name: 'blockData',\n                type: ['JSON', 'Empty'],\n                required: true\n            }, {\n                name: 'columnData',\n                type: ['JSON', 'Empty'],\n                required: true\n            }, {\n                name: 'idData',\n                type: ['JSON', 'Empty'],\n                required: true\n            }, {\n                name: 'blockId',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'onLoadFn',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'interTrialDelay',\n                type: ['Integer', 'Array'],\n                required: false\n            }, {\n                name: 'exitQuestions',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'exitItemTag',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'waitForImages',\n                type: ['Boolean'],\n                required: false\n            }];\n\n            //Validate Parameter Object, outputs stuff to console\n            QRTE.validateParams(paramObj, validationArray, 'Init');\n\n\n            //Initialize the library itself (necessary for each trial)\n            QRTE.initLib(paramObj.blockData, paramObj.blockId, paramObj.columnData, paramObj.idData, paramObj.exitQuestions, paramObj.exitItemTag);\n\n\n            if (paramObj.waitForImages !== undefined) {\n                QRTE.waitForImageLoad = paramObj.waitForImages;\n            }\n            //calculate server communication delay\n            QRTE.setTrialData('InitPre[OnsetTime]', QRTE.getBlockData('QRTLib_previousStorageDone'));\n\n            QRTE.setTrialData('InitPre[OffsetTime]', window.requestAnimationFrame.now());\n            QRTE.setTrialData('InitPre[CalculatedDuration]', QRTE.getTrialData('InitPre[OffsetTime]') - QRTE.getTrialData('InitPre[OnsetTime]'));\n            QRTE.setTrialData('Init[OnsetTime]', window.requestAnimationFrame.now());\n\n\n\n            Qualtrics.SurveyEngine.addOnload(function() {\n                this.qHTML = document.getElementById(this.questionId);\n                this.QRTLib_isActive = false;\n                this.hideChoices();\n                this.proceed = QRTE.proceed;\n                this.QRTLibId = 'InitPost';\n\n                paramObj.onLoadFn.apply(this);\n                var QuestionStackElement = {\n                    questionElement: this,\n                    onShowFunc: function() {},\n                    type: 'Stimulus',\n                    loadConfig: true,\n                    id: 'InitPost',\n                    conditional: function() {\n                        return true;\n                    },\n                    proceedOnHide: true\n\n                };\n                QRTE.setConfig(QuestionStackElement.id, 'duration', 0);\n                QRTE.postInitElement = QuestionStackElement;\n                QRTE.questionQueue.push(QuestionStackElement);\n            });\n\n            if (paramObj.interTrialDelay instanceof Array) {\n                paramObj.interTrialDelay = paramObj.interTrialDelay[Math.floor(Math.random() * paramObj.interTrialDelay.length)];\n            }\n            QRTE.setTrialData(paramObj.blockId + '[InterTrialDelay]', paramObj.interTrialDelay);\n            if (paramObj.interTrialDelay > 0) {\n                QRTE.setBlockData('QRTLib_intraTrialDelay', paramObj.interTrialDelay);\n            } else {\n                QRTE.setBlockData('QRTLib_intraTrialDelay', -1);\n            }\n        },\n\n        /**\n         * Create a Stimulus question\n         * @method Stimulus\n         * @param paramObj {Object}\n         *  @param paramObj.id {String} Id of the Question\n         *  @param paramObj.onShowFn {Function} Function to be called upon showing the question (not the same as upon loading)\n         *  @param [paramObj.conditional] {Function} Function to be called with which to decide whether to present this question or not, should return a boolean.\n         *  @param [paramObj.loadConfig] {Boolean} Load predefined config for this question (defaults to true)\n         *  @param [paramObj.stimContinue] {Boolean} Continue looking for stimuli after having seen this one, only if set to true (defaults to false)\n         *  @param [paramObj.onKeyPress] {Function} Function to be called upon receiving a key press while this Question is active (called next to onAllowableKey or onCorrectKey)\n         *  @param [paramObj.onAllowableKey] {Function} Function to be called upon receiving a key press on a key defined as 'allowable' \n         *  @param [paramObj.onCorrectKey] {Function} Function to be called upon receiving a key press on a key defined as 'correct'\n         *  @param [paramObj.onIncorrectKey] {Function} Function to be called upon receiving an allowable key that is not defined as correct (only if correct responses are defined)\n         *  @param [paramObj.proceedOnHide] {Boolean} Set whether all currently displayed elements should be removed on hide, or if only this should be removed from display (Defaults to True). This allows the user to decouple presentation of a stimulus from proceeding of a slide.\n         *  @param [paramObj.onHideFn] {Function} Function to be called upon Stimulus being hidden\n         *  @param [paramObj.duringDisplayFn] {Function} Function to be called during each frame that the Stimulus is being displayed\n         \n         */\n        Stimulus: function(paramObj) {\n            var validationArray = [{\n                name: 'id',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'onShowFn',\n                type: ['Function'],\n                required: true\n            }, {\n                name: 'conditional',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'loadConfig',\n                type: ['Boolean'],\n                required: false\n            }, {\n                name: 'duringDisplayFn',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'continue',\n                type: ['Boolean'],\n                required: false\n            }, {\n                name: 'onAllowableKey',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'onCorrectKey',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'onKeyPress',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'onIncorrectKey',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'proceedOnHide',\n                type: ['Boolean'],\n                required: false\n            }, {\n                name: 'onHideFn',\n                type: ['Function'],\n                required: false\n            }];\n\n            //Validate Parameter Object, outputs stuff to console\n            QRTE.validateParams(paramObj, validationArray, 'Stimulus');\n\n\n            if (paramObj.conditional === undefined) {\n                paramObj.conditional = function() {\n                    return true;\n                };\n            }\n            if (paramObj.loadConfig === undefined) {\n                paramObj.loadConfig = true;\n            }\n\n            if (paramObj.stimContinue === undefined) {\n                paramObj.stimContinue = false;\n            }\n\n            if (paramObj.proceedOnHide === undefined) {\n                paramObj.proceedOnHide = true;\n            }\n            Qualtrics.SurveyEngine.addOnload(function() {\n                this.QRTLib_isActive = false;\n                this.proceed = QRTE.proceed;\n                this.QRTLibId = paramObj.id;\n                var QuestionStackElement = {\n                    questionElement: this,\n                    onShowFunc: paramObj.onShowFn,\n                    duringDisplayFn: paramObj.duringDisplayFn,\n                    onHideFn: paramObj.onHideFn,\n                    type: 'Stimulus',\n                    loadConfig: paramObj.loadConfig,\n                    id: paramObj.id,\n                    conditional: paramObj.conditional,\n                    stimContinue: paramObj.stimContinue,\n                    onAllowableKey: paramObj.onAllowableKey,\n                    onCorrectKey: paramObj.onCorrectKey,\n                    onKeyPress: paramObj.onKeyPress,\n                    onIncorrectKey: paramObj.onIncorrectKey,\n                    proceedOnHide: paramObj.proceedOnHide\n                };\n                QRTE.questionQueue.push(QuestionStackElement);\n            });\n        },\n\n        /**\n         * Exit denotes the end of the block. Important for the initialization phase and the exit phase.\n         * Make the question a Form question with precisely 2 answer fields (more is unnecessary, those will get ignored)\n         * @method Exit\n         */\n        Exit: function() {\n\n\n            qArray = $('Questions').getElementsByClassName('QuestionOuter');\n            for (var i = 0; i < qArray.length && i < QRTE.initIndex + 1; i += 1) {\n                qArray[i].style.display = 'block';\n            }\n            Qualtrics.SurveyEngine.addOnload(function() {\n                //Hide all choice\n                this.hideChoices();\n                //display the question\n                //this.questionContainer.style.display = 'none';\n                var QuestionStackElement, onShowFn;\n                onShowFn = function() {\n\n                    //Create and/or store standard information about the trial\n                    var blockId = QRTE.getBlockData('QRTLib_currentBlock'),\n                        tempTD = {},\n                        key,\n                        i;\n\n                    QRTE.setBlockData('QRTLib_previousEndTime', window.requestAnimationFrame.now());\n                    QRTE.setTrialData(blockId + '[TrialNr]', QRTE.getBlockData('QRTLib_blockCounter'));\n                    QRTE.setTrialData(blockId + '[RefreshPeriod]', QRTE.refreshPeriod);\n                    QRTE.setTrialData('BlockId', blockId);\n                    QRTE.setTrialData('EngineType', window.requestAnimationFrame.method);\n                    QRTE.setTrialData('Exit[OnsetTime]', window.requestAnimationFrame.now());\n                    QRTE.setTrialData('QRTEngine[Version]', QRTE.version);\n\n                    //CHECK IF ATLEAST TWO FORM FIELDS HAVE BEEN DEFINED\n                    this.setChoiceValue(2, 'testtest');\n                    if (this.getChoiceValue(2) !== 'testtest') {\n                        //alert('You need to define two answer form fields in the Exit question!!');\n                    }\n\n                    for (key in QRTE.TDCache) {\n                        if (QRTE.TDCache.hasOwnProperty(key) && key !== '') {\n                            //Change QID thingies to entered ID's, also force every value to a string so that the Parser handles high numerical values correctly\n                            tempTD[QRTE.getOutputKey(key)] = String(QRTE.TDCache[key]);\n                        }\n                    }\n\n                    this.setChoiceValue(1, Object.toJSON(tempTD));\n                    this.setChoiceValue(2, blockId);\n                    if (QRTE.SDCache[QRTE.columnsField][blockId] === undefined) {\n                        QRTE.SDCache[QRTE.columnsField][blockId] = [];\n                    }\n                    for (i = 0; i < QRTE.newlyAddedColumns.length; i += 1) {\n                        QRTE.SDCache[QRTE.columnsField][blockId].push(QRTE.getOutputKey(QRTE.newlyAddedColumns[i]));\n                    }\n\n                    QRTE.setSurveyData(QRTE.columnsField, Object.toJSON(QRTE.SDCache[QRTE.columnsField]));\n                    QRTE.setBlockData('QRTLib_blockCounter', QRTE.getBlockData('QRTLib_blockCounter') + 1);\n                    QRTE.setBlockData('QRTLib_previousStorageDone', window.requestAnimationFrame.now());\n                    QRTE.saveBlockData();\n\n                    //If wanting to test, uncomment this line and comment the one after that to enforce manual nextbutton clicks\n                    //$('NextButton').style.display = 'block';\n                    //QRTE.submitPage();\n                    QRTEController.loadNextTrial();\n                };\n\n                QuestionStackElement = {\n                    questionElement: this,\n                    onShowFunc: onShowFn,\n                    type: 'Storage',\n                    loadConfig: true,\n                    conditional: function() {\n                        return true;\n                    }\n                };\n                QRTE.questionQueue.push(QuestionStackElement);\n\n                QRTE.startTrial(0);\n\n            });\n\n            QRTE.loadWaitingList = [false];\n            if (QRTE.waitForImageLoad === true) {\n                //set wait for image load queues.\n                var loadIndex = 1,\n                    images = $$('.QuestionOuter img'),\n                    i = 0;\n\n                var l = images.length;\n                for (; i < l; i += 1) {\n                    images[i].observe('load', function(e) {\n                        QRTE.startTrial(e.path[0].QRTELoadIndex);\n                    })\n                    images[i].QRTELoadIndex = i + 1;\n                    QRTE.loadWaitingList[i + 1] = false;\n                }\n\n            }\n\n        },\n\n        /**\n         * Remove the padding Qualtrics adds between Questions (causes question presentation to drift downwards if not called).\n         * DEPRECATED: Separators hidden through CSS now\n         * @method removeSeparators\n         * @private\n         */\n        removeSeparators: function() {\n            var questionElement = document.getElementById('Questions'),\n                index;\n            for (index = 0; index < questionElement.children.length; index += 1) {\n                if (questionElement.children[index].className === \"Separator\") {\n                    questionElement.children[index].parentNode.removeChild(questionElement.children[index]);\n                }\n            }\n        },\n        /**\n         * Notifies the engine the first trial is ready to be started. Called at the end of the 'exit' question\n         * @private\n         * @method startTrial\n         */\n        startTrial: function(startId) {\n            var duringDisplayFn, onHideFn, onDisplayFn, serverCommDelay, remainingDelay;\n            //All questions have been hidden, so display the parent block again\n            //$('Questions').style.display = 'block';\n\n            QRTE.loadWaitingList[startId] = true;\n            if (!QRTE.loadWaitingList.every()) {\n                QRTE.log('Process ' + startId + 'finished, waiting for other processes to finish')\n                return;\n            }\n\n            //Save the absolute time of when onLoad part of library was finished\n            serverCommDelay = window.requestAnimationFrame.now() - QRTE.getBlockData('QRTLib_previousEndTime'); //Calculate the remaining time based on the lib initialization + server delay times\n            remainingDelay = QRTE.getBlockData('QRTLib_intraTrialDelay') - serverCommDelay;\n\n\n            if (isNaN(remainingDelay)) {\n                remainingDelay = QRTE.getBlockData('QRTLib_intraTrialDelay') * 3;\n                //If this init call is the first one of the block (first trial), calculate the estimated refreshdelay during the pre-trial interval\n                onDisplayFn = function(ele, time) {\n                    QRTE.setTrialData('Init[OffsetTime]', ele.displayOnsetTime);\n                    QRTE.setTrialData('Init[CalculatedDuration]', ele.displayOnsetTime - QRTE.getTrialData('Init[OnsetTime]'));\n                    QRTE.refreshPeriodEstimationStack = [];\n                };\n                duringDisplayFn = function(ele, time) {\n                    //Get current time, required for \n                    QRTE.refreshPeriodEstimationStack.push(time);\n                };\n                onHideFn = function(ele, timestamp) {\n                    var diffs = [];\n\n                    for (i = 1; i < QRTE.refreshPeriodEstimationStack.length; i += 1) {\n                        diffs[i - 1] = QRTE.refreshPeriodEstimationStack[i] - QRTE.refreshPeriodEstimationStack[i - 1];\n                    }\n                    QRTE.refreshPeriod = QRTE.median(diffs);\n                    QRTE.log('Estimated refresh delay = ' + QRTE.refreshPeriod);\n                    QRTE.setBlockData('QRTE_refreshPeriod', QRTE.refreshPeriod);\n                    QRTE.referenceTime = timestamp;\n                    QRTE.framesSinceReference = 0;\n                };\n            } else {\n                onDisplayFn = function(ele, time) {\n                    QRTE.setTrialData('Init[OffsetTime]', ele.displayOnsetTime);\n                    QRTE.setTrialData('Init[CalculatedDuration]', ele.displayOnsetTime - QRTE.getTrialData('Init[OnsetTime]'));\n                };\n\n                QRTE.refreshPeriod = QRTE.getBlockData('QRTE_refreshPeriod');\n            }\n\n            //QRTE.setTrialData('ITI[Duration]', (remainingDelay > 0) ? remainingDelay : 0);\n            QRTE.initTime = window.requestAnimationFrame.now();\n\n            QRTE.postInitElement.onHideFn = onHideFn;\n            QRTE.postInitElement.onDisplayFn = onDisplayFn;\n            QRTE.postInitElement.duringDisplayFn = duringDisplayFn;\n            QRTE.setConfig('InitPost', 'duration', (remainingDelay > 0) ? remainingDelay : 0);\n            //UNCOMMENT\n            //QRTE.setConfig('InitPost', 'duration', (remainingDelay > 0) ? remainingDelay : Infinity);\n            QRTE.inited = true;\n\n            //Set initial trial data related to loading of this trial\n            QRTE.setTrialData('InitServerComm[Onset]', QRTE.getBlockData('ServerCommOnset'));\n            QRTE.setTrialData('InitServerComm[Offset]', QRTE.getBlockData('ServerCommOffset'));\n            QRTE.setTrialData('InitServerComm[CalculatedDuration]', QRTE.getBlockData('ServerCommOffset') - QRTE.getBlockData('ServerCommOnset'));\n\n            //<Load next trial here>\n            var currentLoops = '${lm://CurrentLoopNumber}',\n                totalLoops = '${lm://TotalLoops}';\n            //Check if last trial, currentloops === totalLoops;\n            QRTEController.requestNextTrial(currentLoops !== '' && currentLoops === totalLoops);\n\n            QRTE.proceed();\n        },\n\n\n\n        proceed: function() {\n            QRTE.log(\"proceed called after \" + window.requestAnimationFrame.now() - QRTE.initTime);\n            QRTE.hideAllElements();\n        },\n\n        proceedPage: function() {\n            var currentQ;\n            QRTE.log(\"Proceeding page..\");\n            while (QRTE.currentPageQuestions.length > 0) {\n                currentQ = QRTE.currentPageQuestions.shift();\n\n                //Disable\n                currentQ.questionElement.QRTLib_isActive = false;\n            }\n\n\n            //Go to next question\n            QRTE.showNextPage();\n        },\n\n        disableQuestion: function(disableQ) {},\n\n        /**\n         * Determine and show the next page/slide\n         * @private\n         * @method showNextPage\n         */\n        showNextPage: function() {\n            var continueSearch = true,\n                shownQ = false,\n                nextQ,\n                shown;\n            while (continueSearch === true) {\n                continueSearch = false;\n                nextQ = QRTE.questionQueue.shift();\n                if (nextQ !== undefined && (nextQ.type === 'Stimulus' || nextQ.type === 'Storage')) {\n                    QRTE.currentPageQuestions.push(nextQ);\n                    shown = QRTE.showStimulusQuestion.apply(nextQ.questionElement, [nextQ]);\n\n                    if (nextQ.stimContinue) {\n                        continueSearch = true;\n                        if (shown === true) {\n                            shownQ = true;\n                        }\n                    }\n                    QRTE.log('shown ' + nextQ.id + ': ' + shown);\n                    QRTE.log('continue ' + nextQ.id + ': ' + continueSearch);\n                    if (shown === false && shownQ === false) {\n                        continueSearch = true;\n                    }\n                }\n            }\n\n        },\n\n        /**\n         * Show Question\n         * Handles the activation of that question, which includes:\n         * The loading of the configuration (duration, allowable keys etc).\n         * Sets the event handler to respond to any key presses during the event.\n         * @private\n         * @method showStimulusQuestion\n         * @param question {Object} question to be shown.\n         *  @param id {String} Id of question.\n         *  @param onShowFunc {Function} Function to be called when showing question\n         *  @param loadConfig {Boolean} If true, config is loaded from the current block data (which has been defined elsewhere)\n         *  @param questionElement {Object} This Qualtrics question element\n         *  @param duringDisplayFn {Function} Function to be called each frame that the question is presented\n         */\n        showStimulusQuestion: function(question) {\n            //Save the loading start time\n            //QRTE.setTrialData(question.questionElement.QRTLibId + '[LoadStartTime]', window.requestAnimationFrame.now());\n            //Set mapping of the QID -> QRTE Id\n            QRTE.setId(this, question.id);\n\n            //Initialize variables\n            var stimulusShown = false,\n                questionScope = this,\n                dispEle;\n            QRTE.log(question);\n\n            //Check whether question should be shown or not, if not skip to the next question (implicitly)\n            if (question.conditional() === true) {\n                this.QRTLib_isActive = true;\n\n\n                if (question.loadConfig === true) {\n                    //Load the Configuration of the Question, important!\n                    QRTE.loadConfig(this);\n                }\n\n                //Check if KeyPress listener is required (one or more of the following fields are defined: onKeyPress, onCorrectKey or onAllowableKey)\n                //If so, add keypress listener.\n                if (question.onKeyPress !== undefined || question.questionElement.allowable !== '' || question.questionElement.cresp !== '') {\n                    //Initialize the fields used for storing data about RT timing.\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[RTTime]', '');\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[RT]', '');\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[RESP]', '');\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[ACC]', 0);\n\n                    //Add the key listener\n                    QRTE.addKeyListener(function(e) {\n\n                        //Get the Key of the response\n                        var RT, RESP = QRTE.keycode2string(e),\n                            RTTime = window.requestAnimationFrame.now();\n                        RT = RTTime - QRTE.getTrialData(question.questionElement.QRTLibId + '[OnsetTime]');\n\n                        //Store the Time of the Key Press and calculate the RT and ACC if correct\n\n                        if ((QRTE.isAllowableResponse(question.questionElement, RESP) || QRTE.isCorrectResponse(question.questionElement, RESP)) && QRTE.getTrialData(question.questionElement.QRTLibId + '[RTTime]') === '') {\n                            QRTE.setTrialData(question.questionElement.QRTLibId + '[RTTime]', RTTime);\n                            QRTE.setTrialData(question.questionElement.QRTLibId + '[RT]', RT);\n                            QRTE.setTrialData(question.questionElement.QRTLibId + '[RESP]', RESP);\n                            if (QRTE.isCorrectResponse(question.questionElement, RESP)) {\n                                QRTE.saveAcc(question.questionElement, 1);\n                            } else {\n                                QRTE.saveAcc(question.questionElement, 0);\n                            }\n                        }\n\n                        //Store the RT and the Response\n\n                        //Set Handling Key Press to true, this lets the engine know that a keypress is currently being handled. Necessary when there is a timer (response deadline)\n                        question.handlingKeyPress = true;\n\n                        if (question.onCorrectKey !== undefined && QRTE.isCorrectResponse(question.questionElement, RESP)) {\n                            question.onCorrectKey.apply(question.questionElement, [e, RESP]);\n                        } else if (question.onIncorrectKey !== undefined && QRTE.isAllowableResponse(question.questionElement, RESP)) {\n                            question.onIncorrectKey.apply(question.questionElement, [e, RESP]);\n                        }\n\n                        if (question.onAllowableKey !== undefined && QRTE.isAllowableResponse(question.questionElement, RESP)) {\n                            question.onAllowableKey.apply(question.questionElement, [e, RESP]);\n                        }\n\n                        if (question.onKeyPress !== undefined) {\n                            question.onKeyPress.apply(question.questionElement, [e, RESP]);\n                        }\n\n                        if (question.questionElement.endAction === 'TERMINATE') {\n                            //Proceed to the next Question Page if the response is allowable\n                            if (QRTE.isAllowableResponse(question.questionElement, RESP) && question.questionElement.QRTLib_isActive === true) {\n                                question.questionElement.proceed();\n                            }\n                        }\n                        question.handlingKeyPress = false;\n\n                    }, this);\n                }\n\n                //Build the display Element. Stimuli Questions have to take into account the possibility of being associated with a key press. \n                //OnDisplayFn therefore logs the displayOnsetTime, so that the RT can be calculated.\n                dispEle = {\n                    el: this.questionContainer,\n                    duration: this.duration,\n                    delay: this.offset,\n                    duringDisplayFn: question.duringDisplayFn,\n                    onDisplayFn: function(displayEl, timestamp) {\n                        if (question.onDisplayFn !== undefined) {\n                            question.onDisplayFn(displayEl, timestamp);\n                        }\n                        QRTE.setTrialData(questionScope.QRTLibId + '[OnsetTime]', displayEl.displayOnsetTime);\n                    },\n                    proceedOnHide: question.proceedOnHide,\n                    id: question.id\n                };\n\n                //Set the OnHide Function\n                dispEle.onHideFn = function(displayEl, timestamp) {\n                    if (question.onHideFn !== undefined) {\n                        question.onHideFn(displayEl, timestamp);\n                    }\n                    QRTE.setTrialData(questionScope.QRTLibId + '[OffsetTime]', displayEl.displayOffsetTime);\n                    QRTE.setTrialData(questionScope.QRTLibId + '[CalculatedDuration]', displayEl.displayDuration);\n                };\n\n\n                this.QRTLib_timer = QRTE.displayElement(dispEle);\n\n                question.onShowFunc.apply(this);\n\n                stimulusShown = true;\n            }\n\n            //QRTE.setTrialData(question.questionElement.QRTLibId + '[LoadEndTime]', window.requestAnimationFrame.now());\n            return stimulusShown;\n        },\n\n        setId: function(question, desc) {\n\n            this.idCache[question.questionId] = desc;\n            question.qId = desc;\n\n            Qualtrics.SurveyEngine.setEmbeddedData(QRTE.idField, Object.toJSON(this.idCache));\n        },\n\n        getOutputKey: function(key) {\n            var oldKey;\n            for (oldKey in this.idCache) {\n                if (this.idCache.hasOwnProperty(oldKey) && oldKey === key.substring(0, oldKey.length)) {\n\n                    return QRTE.getBlockData('QRTLib_currentBlock') + this.idCache[oldKey] + key.substring(oldKey.length, key.length);\n                }\n            }\n            return key;\n        },\n\n\n        OnKeyPress: function(fn, qScope) {\n\n            qScope = qScope || window;\n\n            var keyFn = function(e) {\n                QRTE.setTrialData(qScope.QRTLibId + '[RTTime]', window.requestAnimationFrame.now());\n                var RT = QRTE.getTrialData(qScope.QRTLibId + '[RTTime]') - QRTE.getTrialData(qScope.QRTLibId + '[OnsetTime]');\n                QRTE.setTrialData(qScope.QRTLibId + '[RT]', RT);\n                QRTE.setTrialData(qScope.QRTLibId + '[RESP]', QRTE.keycode2string(e));\n                QRTE.log(qScope);\n                fn.apply(qScope, [e]);\n            }\n\n            QRTE.addKeyListener(keyFn, qScope);\n        },\n\n        addKeyListener: function(fn, listenerScope) {\n            Event.observe(document, 'keypress', function(e) {\n                if (listenerScope.QRTLib_isActive === true) {\n                    fn.apply(listenerScope, [e]);\n                }\n            });\n        },\n\n        /*  \n         **************Methods below this line are support methods*******************\n         */\n\n        hideQuestions: function() {\n            qArray = $('Questions').getElementsByClassName('QuestionOuter');\n            for (var i = 0; i < qArray.length; i += 1) {\n                qArray[i].style.display = 'none';\n            }\n        },\n\n        unhideQuestions: function() {\n            //Redisplay outer questions\n            qArray = $('Questions').getElementsByClassName('QuestionOuter');\n            for (var i = 0; i < qArray.length; i += 1) {\n                qArray[i].style.display = 'block';\n            }\n            //Redisplay separators\n            qArray = $('Questions').getElementsByClassName('Separator');\n            for (var i = 0; i < qArray.length; i += 1) {\n                qArray[i].style.display = 'block';\n            }\n\n\n        },\n\n        _handleKeyPressEvent: function() {\n\n        },\n\n        _setConfig: function(QID, option, value, setterFunc) {\n            var qidString = QID;\n            if (typeof QID !== 'string') {\n                qidString = QID.questionId;\n            }\n            option = option.toLowerCase();\n\n            switch (option) {\n                case 'duration':\n                    if (value instanceof Array) {\n                        value = value[Math.floor(Math.random() * value.length)];\n                    }\n                    setterFunc.apply(this, [qidString, 'Duration', value]);\n                    break;\n                case 'allowable':\n                    setterFunc.apply(this, [qidString, 'Allowable', value]);\n                    break;\n                case 'cresp':\n                    setterFunc.apply(this, [qidString, 'CRESP', value]);\n                    break;\n                case 'delay':\n                    setterFunc.apply(this, [qidString, 'Offset', value]);\n                    break;\n                case 'endaction':\n                    setterFunc.apply(this, [qidString, 'EndAction', value]);\n                    break;\n                default:\n                    QRTE.log('No such configuration: ' + option);\n                    break;\n            }\n        },\n        getDuration: function(question) {\n            var duration = Infinity,\n                edDuration = this.getTrialData(question.QRTLib_configId + '[Duration]');\n            if (edDuration !== undefined && edDuration !== '' && !isNaN(edDuration)) {\n                duration = edDuration;\n            }\n            if (question._Duration !== undefined && question._Duration !== '' && !isNaN(question._Duration)) {\n                duration = question._Duration;\n            }\n\n            return duration;\n        },\n        getAllowable: function(question) {\n            var allowable = \"\",\n                edAllowable = this.getTrialData(question.QRTLib_configId + '[Allowable]');\n            if (edAllowable !== undefined) {\n                allowable = edAllowable;\n            }\n            if (question._Allowable !== undefined) {\n                allowable = question._Allowable;\n            }\n\n            if (allowable === '{ANY}') {\n                allowable = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890-=[]\\\\;',./`\";\n            }\n            //allowable = allowable.toUpperCase();\n            return allowable;\n        },\n        getCResp: function(question) {\n            var cresp = '',\n                edcresp = this.getTrialData(question.QRTLib_configId + '[CRESP]');\n            if (edcresp !== undefined) {\n                cresp = edcresp;\n            }\n            if (question._cresp !== undefined) {\n                cresp = question._CRESP;\n            }\n\n            if (cresp === '{ANY}') {\n                cresp = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890-=[]\\\\;',./`\";\n            }\n            //cresp = cresp.toUpperCase();\n\n            return cresp;\n        },\n\n        getOffset: function(question) {\n            var offset = 0,\n                edOffset = this.getTrialData(question.QRTLib_configId + '[Offset]');\n            if (edOffset !== undefined && edOffset !== '' && !isNaN(edOffset)) {\n                offset = edOffset;\n            }\n            if (question._Offset !== undefined && question._Offset !== '' && !isNaN(question._Offset)) {\n                offset = question._Offset;\n            }\n\n            return offset;\n\n        },\n\n        getEndAction: function(question) {\n            var endAction = 'NONE',\n                edEndAction = this.getTrialData(question.QRTLib_configId + '[EndAction]');\n            if (edEndAction !== undefined && edEndAction !== '') {\n                endAction = edEndAction;\n            }\n            if (question._EndAction !== undefined && question._EndAction !== '') {\n                endAction = question._EndAction;\n            }\n\n            return endAction;\n\n        },\n        evaluateConditional: function(conditional) {\n            QRTE.log('Conditional: ', conditional);\n            return conditional === '' || conditional();\n        },\n        log: function() {\n            if (QRTE.debug === true) {\n                for (var i = 0; i < arguments.length; i += 1) {\n                    console.log(arguments[i]);\n                }\n            }\n        },\n\n        median: function(values) {\n\n            values.sort(function(a, b) {\n                return a - b;\n            });\n\n            var half = Math.floor(values.length / 2);\n\n            if (values.length % 2) return values[half];\n            else return (values[half - 1] + values[half]) / 2.0;\n        },\n\n        waitForKey: function(question, keys) {\n            Event.observe(document, 'keypress', function(e) {\n                var resp = QRTE.keycode2string(e);\n                if (keys.indexOf(resp) >= 0) {\n                    question.clickNextButton();\n                }\n            });\n        },\n\n        validateParams: function(paramObj, validationArray) {\n            var valObj, val, index, typeCheck = true,\n                indexType;\n            //Loop over validationArray to check whether parameters suffice\n            for (index = 0; index < validationArray.length; index += 1) {\n                valObj = validationArray[index];\n                if (paramObj[valObj.name] === undefined && valObj.required === true) {\n                    alert('Required parameter: ' + valObj.name + ' seems to be missing');\n                    QRTE.log('Required parameter: ' + valObj.name + ' seems to be missing');\n                    break;\n                }\n\n                val = paramObj[valObj.name];\n\n                //Loop over type checkers\n                for (indexType = 0; indexType < valObj.type.length; indexType += 1) {\n                    typeCheck = QRTE.validateType(val, valObj.type[indexType]);\n                    if (typeCheck === true) {\n                        break;\n                    }\n                }\n                if (typeCheck === false && valObj.required === true) {\n                    alert('Parameter: ' + valObj.name + ' is of the wrong type, expected type: ' + valObj.type + ', type received: ' + (typeof val) + \"\\n\" + \"Please open the console for detailed error messages\");\n                    QRTE.log('Parameter: ' + valObj.name + ' is of the wrong type, expected type: ' + valObj.type + ', type received: ' + (typeof val));\n                    QRTE.log('Faulty parameter ' + valObj.name + ': ', val);\n                    QRTE.log('Proper functioning of QRTE is no longer guaranteed, please fix the above error');\n                }\n\n            }\n        },\n\n        validateType: function(val, type) {\n            switch (type) {\n                case 'JSON':\n                    return val.isJSON();\n                case 'String':\n                    return (typeof val === 'string' || val instanceof String);\n                case 'Number':\n                    return (!isNaN(parseFloat(val)) && isFinite(val));\n                case 'Array':\n                    return val instanceof Array;\n                case 'Object':\n                    return typeof val === 'object';\n                case 'Function':\n                    return typeof val === 'function';\n                case 'Boolean':\n                    return (val === true || val === false);\n                case 'Empty':\n                    return val === '';\n                default:\n                    return false;\n            }\n        },\n\n        fixSetEmbeddedDataBug: function() {\n            Qualtrics.SurveyEngine.setEmbeddedData = function(key, value) {\n                var fieldName = 'ED~' + key;\n                if ($(fieldName)) {\n                    $(fieldName).value = value;\n                } else {\n                    $('Header').appendChild(QBuilder('input', {\n                        type: 'hidden',\n                        id: fieldName,\n                        name: fieldName,\n                        value: value\n                    }));\n                    Qualtrics.SurveyEngine.setEmbeddedData(key, value);\n                }\n            }\n        },\n\n        //DisplayEngine part\n\n        //Since it's impossible to know when a screen refresh has happened, we assume that the first timestamp is the actual screen refresh.\n        //Based on the difference between the current timestamp Tn and the root timestamp Tn-1, we estimate the amount of frames that have passed since. \n        //Based on the amount of frames we estimate the previous screen refresh. Although not perfect, it's the best we can do.\n\n        refreshRate: 60, //hertz\n        refreshPeriod: 1000 / 60,\n        lastRefresh: 0,\n        currentRefresh: 0,\n        previousTimestamp: 0,\n        referenceTime: 0,\n        framesSinceReference: 0,\n        currentStack: [],\n        proceedOnFrameEnd: false,\n\n        init: function() {\n            window.requestAnimationFrame(QRTE.draw);\n        },\n\n        draw: function(timestamp) {\n            var curEle, newStack = [];\n            timestamp = window.requestAnimationFrame.now();\n\n\n            if (timestamp < 1e12) {\n                timestamp += window.performance.timing.navigationStart;\n            }\n\n            if (QRTE.referenceTime === 0) {\n                QRTE.referenceTime = timestamp;\n                QRTE.previousTimestamp = timestamp;\n                QRTE.framesSinceReference = 0;\n            } else {\n                //QRTE.framesSinceReference += QRTE.calcFrames(QRTE.referenceTime, timestamp);\n                QRTE.prevFrames = QRTE.framesSinceReference;\n                //frameDiff =  QRTE.calcFrames(QRTE.referenceTime, timestamp) - QRTE.prevFrames;\n                QRTE.framesSinceReference = QRTE.calcFrames(QRTE.referenceTime, timestamp);\n            }\n            QRTE.currentRefresh = (QRTE.framesSinceReference * QRTE.refreshPeriod) + QRTE.referenceTime;\n            QRTE.projectedRefresh = QRTE.currentRefresh + QRTE.refreshPeriod;\n            curEle = QRTE.currentStack.shift();\n\n            while (curEle) {\n                curEle.keep = true;\n\n                //Call duringDisplay callback function, with the current element and the timestamp as arguments.\n                if (curEle.shown === true && typeof curEle.duringDisplayFn === 'function') {\n                    curEle.duringDisplayFn(curEle, timestamp);\n                }\n\n                if (QRTE.proceedOnFrameEnd === true || curEle.hide === true || (curEle.shown === true && curEle.displayOnset !== undefined && (curEle.displayOnset + curEle.duration < QRTE.projectedRefresh))) {\n                    //If the next refresh makes it go beyond the duration, hide the element again!\n                    curEle = QRTE.hideSingleEle(curEle, timestamp);\n                } else if (curEle.shown === false && curEle.requestedAt + curEle.delay < QRTE.projectedRefresh) {\n                    curEle = QRTE.dispSingleEle(curEle, timestamp);\n                }\n\n                if (curEle.keep === false && curEle.proceedOnHide === true) {\n                    //Behold! We have found an element that commands us to proceed to the next page.\n                    QRTE.proceedOnFrameEnd = true;\n                    //Every element that has been processed so far needs to be re-processed (sadly), so that they properly hide.\n                    for (var ind = 0; ind < newStack.length; ind += 1) {\n                        if (newStack[ind].hide !== true) {\n                            newStack[ind].hide = true;\n                            QRTE.currentStack.push(newStack[ind]);\n                        }\n                    }\n                } else {\n                    //Push it to the newStack, for it to be processed next time.\n                    newStack.push(curEle);\n                }\n\n                curEle = QRTE.currentStack.shift();\n            }\n            QRTE.currentStack = newStack;\n            QRTE.lastRefresh = QRTE.currentRefresh;\n            QRTE.previousTimestamp = timestamp;\n            window.requestAnimationFrame(QRTE.draw);\n            if ((newStack.length === 0 || QRTE.proceedOnFrameEnd) && QRTE.inited === true) {\n                QRTE.proceedOnFrameEnd = false;\n                QRTE.proceedPage();\n            }\n\n\n        },\n\n        calcFrames: function(previous, current) {\n            var diff = current - previous,\n                frames = 0;\n\n            if (diff < QRTE.refreshPeriod) {\n                frames = 1;\n            } else {\n                frames = Math.floor(diff / QRTE.refreshPeriod);\n                if (diff % QRTE.refreshPeriod >= (QRTE.refreshPeriod * 0.9)) {\n                    frames += 1;\n                }\n            }\n\n            return frames;\n        },\n\n        /**\n         * Display an element for a specified duration with a specified delay. Vsyncs the display duration using requestAnimationFrame (if possible in the browser)\n         * and allows for high-precision control over its duration. Please start any custom attributes for the paramObj with the 'custom_' header, to avoid collisions.\n         * @private\n         * @method displayElement\n         * @param paramObj {Object}\n         *  @param el {Object} HTML element to be displayed\n         *  @param [onHideFn] {Function} Function to be called upon removing the element from display, is passed one argument containing all information about the display element.\n         *  @param [duration] {Number} Number of milliseconds (ms) the element should be displayed.\n         *  @param [delay] {Number} Number of milliseconds (ms) the Engine should wait before displaying the element.\n         *  @param [duringDisplayFn] {Function} Function to be called upon displaying the element for another screen refresh. Careful: Keep this function simple, could seriously hamper performance as it's called about every 16-17 ms.  is passed one argument containing all information about the display element.\n         *  @param [onDisplayfn] {Function} Function to be called upon starting to display the element. Is passed one argument containing all information about the display element.\n         */\n\n        //displayElement: function(el, callback, duration, offset, duringDisplaycb) {\n        displayElement: function(paramObj) {\n            var reqAt,\n                id = String(Math.random());\n            //QRTE.log(arguments);\n            if (paramObj.delay === undefined) {\n                paramObj.delay = 0;\n            }\n\n\n\n            if (paramObj.duration === undefined) {\n                paramObj = Infinity;\n            }\n\n            if (isNaN(QRTE.lastRefresh)) {\n                reqAt = window.requestAnimationFrame.now();\n            } else {\n                reqAt = QRTE.lastRefresh;\n            }\n            paramObj.userId = paramObj.id;\n            paramObj.id = id;\n            paramObj.shown = false;\n            paramObj.requestedAt = reqAt;\n            paramObj.hide = false;\n\n            QRTE.currentStack.push(paramObj);\n            if (paramObj.delay === 0) {\n                //This element needs to be displayed as soon as possible\n                QRTE.dispSingleEle(paramObj, QRTE.previousTimestamp);\n            }\n            QRTE.log('Added element to display stack:', paramObj);\n            //console.log('paramObj: ', paramObj.userId, ', duration: ', paramObj.duration);\n\n            return id;\n        },\n\n        hideElement: function(id) {\n            var found = false,\n                i;\n            for (i = 0; i < QRTE.currentStack.length; i += 1) {\n                if (QRTE.currentStack[i].id === id) {\n                    found = true;\n                    QRTE.currentStack[i].hide = true;\n                    this.log('Element to be hidden: ', QRTE.currentStack[i]);\n                }\n            }\n            return found;\n        },\n\n        hideAllElements: function() {\n            for (i = 0; i < QRTE.currentStack.length; i += 1) {\n                QRTE.currentStack[i].hide = true;\n            }\n            QRTE.proceedOnFrameEnd = true;\n        },\n\n        /**\n         * Hide a DrawEngine Element\n         * @private\n         * @method hideSingleEle\n         * @param curEle {Object}\n         */\n        hideSingleEle: function(curEle, timestamp) {\n            curEle.displayOffset = QRTE.projectedRefresh;\n            curEle.displayOffsetTime = window.requestAnimationFrame.now();\n            curEle.el.style.display = 'none';\n            curEle.keep = false;\n            curEle.hide = true;\n            //delete QRTE.currentStack[key];\n            curEle.displayDuration = curEle.displayOffsetTime - curEle.displayOnsetTime;\n            if (curEle.onHideFn !== undefined) {\n                curEle.onHideFn(curEle, timestamp);\n            }\n\n            return curEle;\n\n        },\n\n\n        /**\n         * Display a DrawEngine Element\n         * @private\n         * @method dispSingleEle\n         * @param curEle {Object}\n         */\n        dispSingleEle: function(curEle, timestamp) {\n            curEle.el.style.display = 'block';\n            curEle.displayOnset = QRTE.projectedRefresh;\n            curEle.displayOnsetTime = window.requestAnimationFrame.now();\n            curEle.shown = true;\n            if (curEle.onDisplayFn !== undefined) {\n                //Added try-catch block to catch the error that's causing the OnsetTime not to get saved.\n                try {\n                    curEle.onDisplayFn(curEle, timestamp);\n                } catch (e) {\n                    QRTE.setTrialData('Error[OnsetError]', JSON.stringify(e));\n                }\n            }\n            return curEle;\n        },\n\n        checkEngineCompatibility: function() {\n            return window.requestAnimationFrame.method === 'native-highres';\n        },\n    };\n\n    if (typeof QRTEController == 'undefined') {\n        //QRTE SurveySlider controller layer\n        //Takes care of progressing through the survey. Catches all qualtrics native ways of submitting the form and replaces that by\n        //its own asynchronous ajax stuff.\n        QRTEController = {\n\n\n            //This plug-in to QRTEngine has been developed under the name SurveySlider\n            // for general Qualtrics Surveys. It has been adapted to work with QRTEngine\n            nextTrialContainer: null,\n            nextTrialText: '',\n            currentForm: null,\n            previousForm: null,\n            handlingSubmit: false,\n            onSubmitStack: [],\n            inited: false,\n            childInputs: [],\n            loadUponCallback: false,\n            setEmbeddedData: function() {},\n            tempED: {},\n\n\n\n            //Initialize thecontroller\n            init: function() {\n                this.nextTrialContainer = new Element('div', {\n                    id: 'nextTrialContainer'\n                });\n                this.currentForm = $$('form')[0];\n\n                //Catch submits and change it with our own submit function (which does AJAX submissions)\n                //this.currentForm.observe('QRTE:submit', QRTE.handleSubmit);\n                this.currentElements = $$('.QuestionOuter');\n\n                //Initial SSload firing\n                Qualtrics.SurveyEngine.addOnload(function() {\n                    QRTEController.currentForm.fire('QRTE:load');\n                });\n                //Change SurveyEngine.OnLoad to trigger on SSload, rather than page load\n                Qualtrics.SurveyEngine.addOnload = function(f) {\n                        var questions = $$('.QuestionOuter'),\n                            currentCount = QRTEController.count(Qualtrics.SurveyEngine.QuestionInfo),\n                            id = questions[currentCount - 1].id;\n                        if ($('body') && $('body').hasClassName('EditSection')) return;\n                        try {\n                            var obj = new Qualtrics.SurveyEngine.QuestionData(id);\n                            obj.onload = f;\n\n                            QRTEController.currentForm.observe('QRTE:load', obj.onload.bind(obj));\n                            //Event.observe(this.currentForm, 'SSload', obj.onload.bind(obj));\n                        } catch (e) {\n                            console.error('SE API Error: ' + e);\n                        }\n                    }\n                    //Set the Qualtrics setEmbeddedData to inside the QRTEController\n                QRTEController.setEmbeddedData = Qualtrics.SurveyEngine.setEmbeddedData;\n                Qualtrics.SurveyEngine.setEmbeddedData = function(key, value) {\n                    QRTEController.tempED[key] = value;\n                }\n                this.submitPage = this.requestNextTrial;\n                this.inited = true;\n            },\n\n            /**\n             * Requests the next trial from the Qualtrics server.\n             *\n             *\n             */\n            requestNextTrial: function(isLastTrial) {\n\n                //If this is the last trial of a block, DON'T request the next page, let qualtrics handle it themselves\n                if (this.handlingSubmit === false && isLastTrial === false) {\n                    //Load next trial means that current page is a trial and has been inited\n                    //Need to remove relevant input elements from current form before submitting\n                    //After that add them back\n                    this.handlingSubmit = true\n                    var childs = $$('form input[type=text]'),\n                        childInputs = [];\n                    //remove current input elements from the form\n                    for (var i = 0; i < childs.length; i += 1) {\n                        childInputs[i] = {\n                            ele: childs[i],\n                            parent: childs[i].up()\n                        };\n                        childs[i].remove();\n                    }\n                    //add previous input elements to form\n                    //Text inputs\n                    for (var i = 0; i < this.childInputs.length; i += 1) {\n                        this.childInputs[i].ele.style.display = 'none';\n                        this.currentForm.insert(this.childInputs[i].ele);\n                    }\n\n\n                    //And embedded data\n                    for (var key in this.tempED) {\n                        if (this.tempED.hasOwnProperty(key)) {\n                            QRTEController.setEmbeddedData(key, this.tempED[key]);\n                        }\n                    }\n                    //Reset stored embedded data\n                    this.tempED = {};\n                    //set new childs\n                    this.childInputs = childInputs;\n\n                    //Loop over submit stack, or callbacks that need to be finished before submitting\n                    for (var i = 0; i < QRTEController.onSubmitStack.length; i += 1) {\n                        QRTE.onSubmitStack[i]();\n                    }\n                    QRTEController.onSubmitStack = [];\n                    debugger;\n                    this.currentForm.request({\n                        onComplete: this.requestNextTrialCallback\n                    });\n\n                    //Set server comm onset for the next trial\n                    QRTE.setBlockData('ServerCommOnset', window.requestAnimationFrame.now());\n\n                    QRTEController.betweenSubmits = true;\n\n                    for (var i = 0; i < this.childInputs.length; i += 1) {\n                        this.childInputs[i].parent.insert(this.childInputs[i].ele);\n                        this.childInputs[i].ele.style.display = 'none';\n                    }\n                } else if (isLastTrial === true) {\n                    //Just add the previous trial's childInputs to the form \n                    for (var i = 0; i < this.childInputs.length; i += 1) {\n\n                        this.currentForm.insert(this.childInputs[i].ele);\n                        this.childInputs[i].ele.style.display = 'none';\n                    }\n\n                    this.loadNextTrial = function() {\n                        //Directly submitting the form doesn't seem to work? Let's do it through NextButton click\n                        $('NextButton').click();\n                    };\n                }\n            },\n\n            loadNextTrial: function() {\n                if (this.handlingSubmit === true) {\n                    //The submit still hasn't returned..\n                    this.loadUponCallback = true;\n                    return;\n\n                }\n                //Set handling submit to false (as page has been returned)\n                //Save the previous form\n                this.previousForm = this.currentForm;\n                //Reset the QuestionInfo object, this is for Qualtrics to correctly initiate its own page\n                Qualtrics.SurveyEngine.QuestionInfo = {}\n                    //Parse the HTML that was returned earlier and set it as the current trial container's contents\n                this.nextTrialContainer = jQuery(this.nextTrialContainer).html(this.nextTrialText)[0];\n                //Filter out the 'form' field, and append it back.\n                this.currentForm = jQuery(this.nextTrialContainer).find('form')[0];\n                jQuery(this.previousForm).replaceWith(jQuery(this.currentForm));\n\n                jQuery(this.currentForm).show();\n\n                if (this.currentForm.select('.END_OF_SURVEY').length === 0) {\n                    this.currentForm.fire('QRTE:load');\n                    this.submitPage = this.requestNextTrial;\n                } else {\n                    this.submitPage = this.currentForm.submit;\n                }\n\n            },\n\n            requestNextTrialCallback: function(e) {\n                QRTEController.nextTrialText = e.responseText;\n                QRTEController.handlingSubmit = false;\n                QRTE.setBlockData('ServerCommOffset', window.requestAnimationFrame.now());\n\n                if (QRTEController.loadUponCallback === true) {\n                    QRTEController.loadUponCallback = false;\n                    QRTEController.loadNextTrial();\n                }\n            },\n\n            submitPage: function() {\n                console.log('Not yet initialised');\n            },\n\n            count: function(obj) {\n                var count = 0;\n\n                for (var prop in obj) {\n                    if (obj.hasOwnProperty(prop))\n                        ++count;\n                }\n\n                return count;\n            },\n\n            BDCache: {},\n            storeBlockData: function(blockData) {\n                this.BDCache = blockData;\n            },\n\n            loadBlockData: function() {\n                return this.BDCache;\n            }\n        };\n\n        document.observe('dom:loaded', QRTEController.init.bind(QRTEController));\n\n\n        (function() {\n            var lastFrame, method, now, queue, requestAnimationFrame, timer, vendor, _i, _len, _ref, _ref1;\n            method = 'native';\n            now = Date.now || function() {\n                return new Date().getTime();\n            };\n            requestAnimationFrame = window.requestAnimationFrame;\n            _ref = ['webkit', 'moz', 'o', 'ms'];\n            for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n                vendor = _ref[_i];\n                if (!(requestAnimationFrame != null)) {\n                    requestAnimationFrame = window[vendor + \"RequestAnimationFrame\"];\n                }\n            }\n            if (!(requestAnimationFrame != null)) {\n                method = 'timer';\n                lastFrame = 0;\n                queue = timer = null;\n                requestAnimationFrame = function(callback) {\n                    var fire, nextFrame, time;\n                    if (queue != null) {\n                        queue.push(callback);\n                        return;\n                    }\n                    time = now();\n                    nextFrame = Math.max(0, 16.66 - (time - lastFrame));\n                    queue = [callback];\n                    lastFrame = time + nextFrame;\n                    fire = function() {\n                        var cb, q, _j, _len1;\n                        q = queue;\n                        queue = null;\n                        for (_j = 0, _len1 = q.length; _j < _len1; _j++) {\n                            cb = q[_j];\n                            cb(lastFrame);\n                        }\n                    };\n                    timer = setTimeout(fire, nextFrame);\n                };\n            }\n            requestAnimationFrame(function(time) {\n                var _ref1;\n                if ((((_ref1 = window.performance) != null ? _ref1.now : void 0) != null) && time < 1e12) {\n                    requestAnimationFrame.now = function() {\n                        return window.performance.now() + window.performance.timing.navigationStart;\n                    };\n                    requestAnimationFrame.method = 'native-highres';\n                } else {\n                    requestAnimationFrame.now = now;\n                }\n            });\n            requestAnimationFrame.now = ((_ref1 = window.performance) != null ? _ref1.now : void 0) != null ? (function() {\n                return window.performance.now() + window.performance.timing.navigationStart;\n            }) : now;\n            requestAnimationFrame.method = method;\n            window.requestAnimationFrame = requestAnimationFrame;\n        })();\n\n        function loadScript(url, callback) {\n\n            var script = document.createElement(\"script\")\n            script.type = \"text/javascript\";\n\n            if (script.readyState) { //IE\n                script.onreadystatechange = function() {\n                    if (script.readyState == \"loaded\" || script.readyState == \"complete\") {\n                        script.onreadystatechange = null;\n                        callback();\n                    }\n\n                };\n            } else { //Others\n                script.onload = function() {\n                    callback();\n                };\n            }\n\n            script.src = url;\n            document.getElementsByTagName(\"head\")[0].appendChild(script);\n        }\n\n        (function() {\n\n            //jQuery is only required for the Fixation flash fix. prototypejs is unable to efficiently replace elements\n            //and introduces a 10 ms delay between loading element and firing off the scripts. Unacceptable\n            //First time jQuery should be used is the second trial\n\n            loadScript(\"https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js\", function() {\n\n                $.noConflict();\n\n            });\n\n        })();\n\n        //If preview mode is run (PreviewBanner element exists, add a QRTEngine plug with id QRTEPlug)\n\n        if ($('PreviewBanner')) {\n            var plug, row, banner = $('PreviewBanner');\n            //Go down to the first table row inside that banner\n            row = banner.children[0].children[0].children[0];\n            //Insert new cell    \n            plug = row.insertCell(2);\n            plug.id = \"QRTEPlug\";\n            plug.width = \"20%\";\n            plug.innerHTML = 'This survey is proudly and successfully powered by <a href=\"http://qrtengine.com\" target=\"_blank\"><i><b>QRTEngine</b></i></a>';\n            plug.style.textAlign = \"center\";\n        }\n    }","<script>\n    /** ==========================================================\n     * QRTEngine.js v16\n     * ==========================================================\n     * Copyright 2013-2014 Erwin Haasnoot\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     * http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     *\n     *\n     *\n     * ========================================================== */\n    /**\n     * Qualtrics Reaction Time Engine or QRTE is an add-on providing an interface\n     * for easy reaction time experiment creation in the Qualtrics survey research suite (tm).\n     * For instructions on how to use this add-on, see xxxx\n     *\n     * QRTE was developed by Erwin Haasnoot\n     * Email: erwinhaasnoot[at]gmail.com\n     * @class QRTE\n     *\n     */\n     \n    var QRTE = {\n        version: 'v16',\n        columnsField: 'QRTE_columns',\n        blockDataField: 'QRTE_blockData',\n        idField: 'QRTE_idData',\n        exitQuestions: 'QRTE_exitQuestions',\n        inited: false,\n        /**\n         * TDCache contains the Trial-Level Data in an Object. DO NOT directly manipulate this Object. It might cause inconsistencies in the data file and cause unexpected once parsed.\n         * Use QRTE.setTrialData and QRTE.getTrialData instead.\n         *\n         * @property TDCache\n         * @private\n         * @type Object\n         */\n        TDCache: {},\n\n        /**\n         * ColumnCache contains all the mappings from QID to Columns\n         * @property columnCache\n         * @private\n         * @type Object\n         */\n        columnCache: {},\n\n        /**\n         * BDCache contains the BlockLevel Data in an Object. Directly manipulating this Object might cause inconsistencies\n         * @property BDCache\n         * @private\n         * @type Object\n         */\n        BDCache: {},\n\n        /**\n         * SDCache is a cache for speeding up retrieval of Survey level Data,\n         * All Survey data is saved to both Embedded Data and Survey Data\n         * @private\n         * @property SDCache\n         * @type Object\n         */\n        SDCache: {},\n\n        /**\n         * idCache is a cache for quickly retrieving the Qualtrics QID to QRTLib Id mappings.\n         * Saved in the idData embedded data field after every trial.\n         * @private\n         * @property idCache\n         * @type Object\n         */\n        idCache: {},\n\n        /**\n         * questionQueue contains Objects (stimuli) that are waiting to be presented\n         * @private\n         * @property questionQueue\n         * @type Array\n         */\n        questionQueue: [],\n\n        /**\n         * currentPageQuestions contains the Question Objects that are\n         * displayed at any given time.\n         * @private\n         * @property currentPageQuestions\n         * @type Array\n         */\n        currentPageQuestions: [],\n\n        /**\n         * Contains Trial Data Columns that were 'newly' added in this trial run.\n         * @private\n         * @property newlyAddedColumns\n         * @type Array\n         */\n        newlyAddedColumns: [],\n\n        /**\n         * Contains the Post-Initialization Element.\n         * @private\n         * @property postInitElement\n         * @type Object\n         */\n        postInitElement: {},\n\n        /**\n         * Setter function for Trial-Level Data.\n         * @method setTrialData\n         * @param key {String} Key\n         * @param value {Value} Value\n         */\n        setTrialData: function(key, value) {\n            //Store value in trial cache\n            this.TDCache[key] = value;\n            if (this.BDCache.QRTLib_trialColumns[key] === undefined) {\n                //Add column to overall trial data\n                this.BDCache.QRTLib_trialColumns[key] = '';\n                this.newlyAddedColumns.push(key);\n            }\n        },\n\n        /**\n         * Gets the value of Trial-Level Data field 'key\n         * @method getTrialData\n         * @param key {String} Key\n         */\n        getTrialData: function(key) {\n            return this.TDCache[key];\n        },\n\n        /**\n         * Setter function for Block-Level Data.\n         * @method setBlockData\n         * @param key {String} Key\n         * @param value {Value} Value\n         */\n        setBlockData: function(key, value) {\n            this.BDCache[key] = value;\n        },\n\n\n        /**\n         * Gets the value of Block-Level Data field 'key\n         * @method getBlockData\n         * @param key {String} Key\n         */\n        getBlockData: function(key) {\n            return this.BDCache[key];\n        },\n\n\n\n\n        /**\n         * Stringify the Block Data and store it in the Embedded Data Field. This preserves the values stored on Block Level for use in later trials\n         * @method saveBlockData\n         * @param key {String} Key\n         */\n        saveBlockData: function() {\n            //Store blockData in ED so that we can use it next trial\n            QRTEController.storeBlockData(QRTE.BDCache);\n            Qualtrics.SurveyEngine.setEmbeddedData(QRTE.blockDataField, Object.toJSON(QRTE.BDCache));\n        },\n\n\n\n        /**\n         * Setter function for Survey-Level Data (Embedded Data).\n         * @method setSurveyData\n         * @param key {String} Key\n         * @param value {Value} Value\n         */\n        setSurveyData: function(key, value) {\n            this.SDCache[key] = value;\n            Qualtrics.SurveyEngine.setEmbeddedData(key, value);\n        },\n\n\n\n        /**\n         * Gets the value of Survey-Level Data (Embedded Data) 'key'\n         * @method getSurveyData\n         * @param key {String} Key\n         */\n\n        getSurveyData: function(key) {\n            if (this.SDCache[key] !== undefined) {\n                return this.SDCache[key];\n            }\n            //This only works if the Survey Data has been set during the same trial due to a bug in Qualtrics.\n            return Qualtrics.SurveyEngine.getEmbeddedData(key);\n        },\n\n        /**\n         * Sets a configuration for a question\n         * @method setConfig\n         * @param QID {String} The QRTE Question Id of the Question you want the configuration to apply to\n         * @param option {String} The type of configuration you want to set, Allowed options: 'cresp', 'allowable', 'duration', 'endaction', 'delay'. Refer to website for documentation on these configs\n         * @param value {String} The value the configuration needs to be set to. Differs per option.\n         */\n        setConfig: function(QID, option, value) {\n            var setterFunc;\n            if (typeof QID === 'string') {\n                setterFunc = function(QID, option, value) {\n                    this.setTrialData(QID + \"[\" + option + \"]\", value);\n                };\n            } else {\n                setterFunc = function(QID, option, value) {\n                    this.setTrialData(QID.questionId + \"[\" + option + \"]\", value);\n                    QID['_' + option] = value;\n                };\n\n            }\n\n            this._setConfig(QID, option, value, setterFunc);\n        },\n\n\n        /**\n         * Loads the configuration for a question.\n         * @private\n         * @method loadConfig\n         * @param question {Object} Question for which the configuration needs to be loaded.\n         */\n        loadConfig: function(question) {\n            if (this.idCache[question.questionId] !== undefined) {\n                question.QRTLib_configId = this.idCache[question.questionId];\n            } else {\n                question.QRTLib_configId = question.question;\n            }\n            question.duration = this.getDuration(question);\n            question.allowable = this.getAllowable(question);\n            question.cresp = this.getCResp(question);\n            question.offset = this.getOffset(question);\n            question.endAction = this.getEndAction(question);\n        },\n\n        /**\n         * Stores the accuracy of a trial\n         * @private\n         * @method saveAcc\n         * @param question {Object} Question for which accuracy needs to be stored\n         * @param acc {Integer} Accuracy of question\n         */\n\n        saveAcc: function(question, acc) {\n            if (acc === 0 || acc === 1) {\n                this.setTrialData(question.QRTLibId + \"[ACC]\", acc);\n                this.setSurveyData(\"ACC\", acc);\n            }\n        },\n\n\n\n        /**\n         * Check whether the given response was a correct response\n         * @method isCorrectResponse\n         * @param question {Object} Question for which correct response needs to be checked\n         * @param resp {String} Given response\n         */\n        isCorrectResponse: function(question, resp) {\n            return question.cresp.indexOf(resp) >= 0;\n        },\n\n        /**\n         * Check whether the given response was an allowable response\n         * @method isAllowableResponse\n         * @param question {Object} Question for which allowable response needs to be checked\n         * @param resp {String} Given response\n         */\n        isAllowableResponse: function(question, resp) {\n            return question.allowable.indexOf(resp) >= 0;\n        },\n\n\n\n        /**\n         * Check whether the given response was an allowable response\n         * @private\n         * @method keycode2string\n         * @param e {Object} KeyPress event from which to retrieve the response\n         */\n        keycode2string: function(e) {\n            return String.fromCharCode(e.charCode);\n        },\n\n        /** \n         * Wait for images to load before starting trial.\n         * @property waitForImageLoad\n         * @private\n         * @type Boolean\n         */\n\n        waitForImageLoad: true,\n\n        /** \n         * Trial Start waiting list - initialised with waiting for TrialStart\n         * @property loadWaitingList\n         * @private\n         * @type Array\n         */\n\n        loadWaitingList: [false],\n\n        /**\n         * Initializes the Engine, called at the start of the 'Init' question.\n         * @private\n         * @method initLib\n         * @param blockDataString {String} JSON string containing information saved for this block (block-level data)\n         * @param blockId {String} Id of the current block\n         * @param columns {String} JSON string containing information about the columns that have been defined in this block\n         * @param idData {String} JSON string containing information about the mapping of the QID to the name of the question\n         * @param exitQuestions {String} String containing the currently defined QuestionTags of the Exit questions\n         * @param exitItemTag {String} String containing the Tag of this block's Exit question.\n         */\n\n\n        initLib: function(blockDataString, blockId, columns, idData, exitQuestions, exitItemTag) {\n            //var blockDataString = Qualtrics.SurveyEngine.getEmbeddedData(QRTE.blockDataField),\n            //columns = Qualtrics.SurveyEngine.getEmbeddedData(QRTE.columnsField),\n            //idData = Qualtrics.SurveyEngine.getEmbeddedData(QRTE.idField);\n            var glue;\n            QRTE.fixSetEmbeddedDataBug();\n            //Initialise block Data\n            if (blockDataString === undefined || blockDataString === null || blockDataString === '') {\n                blockDataString = '{}';\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.blockDataField, blockDataString);\n            }\n\n            this.BDCache = QRTEController.loadBlockData(blockDataString);\n\n            if (this.BDCache.QRTLib_currentBlock !== blockId) {\n                //If this is a new block, initialise a new block\n                this.BDCache = {\n                    QRTLib_currentBlock: blockId,\n                    QRTLib_blockCounter: 1,\n                    QRTLib_trialColumns: {}\n                };\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.blockDataField, Object.toJSON(this.BDCache));\n                if (exitQuestions === null) {exitQuestions = '';}\n                glue = '';\n                if (exitQuestions !== '') {\n                    glue = ';';\n                }\n                //And update the exit questions\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.exitQuestions, exitQuestions + glue + exitItemTag);\n\n            }\n            QRTE.TDCache = Object.toJSON(QRTE.getBlockData('QRTLib_trialColumns')).evalJSON();\n            if (columns === undefined || columns === null || columns === '') {\n                columns = '{}';\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.columnsField, columns);\n            }\n            QRTE.SDCache[QRTE.columnsField] = columns.evalJSON();\n            if (idData === undefined || idData === null || idData === '') {\n                idData = '{}';\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.idField, idData);\n            }\n            QRTE.idCache = idData.evalJSON();\n        },\n\n        /**\n         * Init initializes the QRTEngine, expects are params object with possible fields defined with parameters.\n         * @method Init\n         * @param paramObj {Object} object containing parameters of Init function\n         *  @param paramObj.blockData {String} blockData string in json format (from embedded data)\n         *  @param paramObj.columnData {String} columnData string in json format (from embedded data)\n         *  @param paramObj.exitQuestions {String} exitQuestions string (from embedded data)\n         *  @param paramObj.exitItemTag {String} Tag of the Exit question of this block\n         *  @param paramObj.blockId {String} Identificaton of the block\n         *  @param [paramObj.onLoadFn] {Function} Function to be called when this Question is displayed\n         *  @param [paramObj.interTrialDelay] {Integer|Array} Specify millisecond delay between end of previous trial and beginning of new trial\n         *  @param [paramObj.preTrialDelay] {Integer|Array} Specify millisecond (ms) delay before the start of the first trial of the block. //NYI\n         *  @param [paramObj.initQuestionIndex] {Integer} Specify index of the Init question in the Question Block (defaults to 1)\n         *  @param [paramObj.waitForImages] {Boolean} Specify whether we should wait for images or not. Is on by default, but could be turned off if all images are pre-loaded in cache, or are very small in general.\n         */\n        Init: function(paramObj) {\n            var validationArray, qArray, initIndex;\n            //init the library\n            QRTE.init();\n\n            //set the initIndex (if the Init question is not the first question of the block)\n            QRTE.initIndex = paramObj.initQuestionIndex - 1 || 0;\n\n\n            validationArray = [{\n                name: 'blockData',\n                type: ['JSON', 'Empty'],\n                required: true\n            }, {\n                name: 'columnData',\n                type: ['JSON', 'Empty'],\n                required: true\n            }, {\n                name: 'idData',\n                type: ['JSON', 'Empty'],\n                required: true\n            }, {\n                name: 'blockId',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'onLoadFn',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'interTrialDelay',\n                type: ['Integer', 'Array'],\n                required: false\n            }, {\n                name: 'exitQuestions',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'exitItemTag',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'waitForImages',\n                type: ['Boolean'],\n                required: false\n            }];\n\n            //Validate Parameter Object, outputs stuff to console\n            QRTE.validateParams(paramObj, validationArray, 'Init');\n\n\n            //Initialize the library itself (necessary for each trial)\n            QRTE.initLib(paramObj.blockData, paramObj.blockId, paramObj.columnData, paramObj.idData, paramObj.exitQuestions, paramObj.exitItemTag);\n\n\n            if (paramObj.waitForImages !== undefined) {\n                QRTE.waitForImageLoad = paramObj.waitForImages;\n            }\n            //calculate server communication delay\n            QRTE.setTrialData('InitPre[OnsetTime]', QRTE.getBlockData('QRTLib_previousStorageDone'));\n\n            QRTE.setTrialData('InitPre[OffsetTime]', window.requestAnimationFrame.now());\n            QRTE.setTrialData('InitPre[CalculatedDuration]', QRTE.getTrialData('InitPre[OffsetTime]') - QRTE.getTrialData('InitPre[OnsetTime]'));\n            QRTE.setTrialData('Init[OnsetTime]', window.requestAnimationFrame.now());\n\n\n\n            Qualtrics.SurveyEngine.addOnload(function() {\n                this.qHTML = document.getElementById(this.questionId);\n                this.QRTLib_isActive = false;\n                this.hideChoices();\n                this.proceed = QRTE.proceed;\n                this.QRTLibId = 'InitPost';\n\n                paramObj.onLoadFn.apply(this);\n                var QuestionStackElement = {\n                    questionElement: this,\n                    onShowFunc: function() {},\n                    type: 'Stimulus',\n                    loadConfig: true,\n                    id: 'InitPost',\n                    conditional: function() {\n                        return true;\n                    },\n                    proceedOnHide: true\n\n                };\n                QRTE.setConfig(QuestionStackElement.id, 'duration', 0);\n                QRTE.postInitElement = QuestionStackElement;\n                QRTE.questionQueue.push(QuestionStackElement);\n            });\n\n            if (paramObj.interTrialDelay instanceof Array) {\n                paramObj.interTrialDelay = paramObj.interTrialDelay[Math.floor(Math.random() * paramObj.interTrialDelay.length)];\n            }\n            QRTE.setTrialData(paramObj.blockId + '[InterTrialDelay]', paramObj.interTrialDelay);\n            if (paramObj.interTrialDelay > 0) {\n                QRTE.setBlockData('QRTLib_intraTrialDelay', paramObj.interTrialDelay);\n            } else {\n                QRTE.setBlockData('QRTLib_intraTrialDelay', -1);\n            }\n        },\n\n        /**\n         * Create a Stimulus question\n         * @method Stimulus\n         * @param paramObj {Object}\n         *  @param paramObj.id {String} Id of the Question\n         *  @param paramObj.onShowFn {Function} Function to be called upon showing the question (not the same as upon loading)\n         *  @param [paramObj.conditional] {Function} Function to be called with which to decide whether to present this question or not, should return a boolean.\n         *  @param [paramObj.loadConfig] {Boolean} Load predefined config for this question (defaults to true)\n         *  @param [paramObj.stimContinue] {Boolean} Continue looking for stimuli after having seen this one, only if set to true (defaults to false)\n         *  @param [paramObj.onKeyPress] {Function} Function to be called upon receiving a key press while this Question is active (called next to onAllowableKey or onCorrectKey)\n         *  @param [paramObj.onAllowableKey] {Function} Function to be called upon receiving a key press on a key defined as 'allowable' \n         *  @param [paramObj.onCorrectKey] {Function} Function to be called upon receiving a key press on a key defined as 'correct'\n         *  @param [paramObj.onIncorrectKey] {Function} Function to be called upon receiving an allowable key that is not defined as correct (only if correct responses are defined)\n         *  @param [paramObj.proceedOnHide] {Boolean} Set whether all currently displayed elements should be removed on hide, or if only this should be removed from display (Defaults to True). This allows the user to decouple presentation of a stimulus from proceeding of a slide.\n         *  @param [paramObj.onHideFn] {Function} Function to be called upon Stimulus being hidden\n         *  @param [paramObj.duringDisplayFn] {Function} Function to be called during each frame that the Stimulus is being displayed\n         \n         */\n        Stimulus: function(paramObj) {\n            var validationArray = [{\n                name: 'id',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'onShowFn',\n                type: ['Function'],\n                required: true\n            }, {\n                name: 'conditional',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'loadConfig',\n                type: ['Boolean'],\n                required: false\n            }, {\n                name: 'duringDisplayFn',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'continue',\n                type: ['Boolean'],\n                required: false\n            }, {\n                name: 'onAllowableKey',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'onCorrectKey',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'onKeyPress',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'onIncorrectKey',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'proceedOnHide',\n                type: ['Boolean'],\n                required: false\n            }, {\n                name: 'onHideFn',\n                type: ['Function'],\n                required: false\n            }];\n\n            //Validate Parameter Object, outputs stuff to console\n            QRTE.validateParams(paramObj, validationArray, 'Stimulus');\n\n\n            if (paramObj.conditional === undefined) {\n                paramObj.conditional = function() {\n                    return true;\n                };\n            }\n            if (paramObj.loadConfig === undefined) {\n                paramObj.loadConfig = true;\n            }\n\n            if (paramObj.stimContinue === undefined) {\n                paramObj.stimContinue = false;\n            }\n\n            if (paramObj.proceedOnHide === undefined) {\n                paramObj.proceedOnHide = true;\n            }\n            Qualtrics.SurveyEngine.addOnload(function() {\n                this.QRTLib_isActive = false;\n                this.proceed = QRTE.proceed;\n                this.QRTLibId = paramObj.id;\n                var QuestionStackElement = {\n                    questionElement: this,\n                    onShowFunc: paramObj.onShowFn,\n                    duringDisplayFn: paramObj.duringDisplayFn,\n                    onHideFn: paramObj.onHideFn,\n                    type: 'Stimulus',\n                    loadConfig: paramObj.loadConfig,\n                    id: paramObj.id,\n                    conditional: paramObj.conditional,\n                    stimContinue: paramObj.stimContinue,\n                    onAllowableKey: paramObj.onAllowableKey,\n                    onCorrectKey: paramObj.onCorrectKey,\n                    onKeyPress: paramObj.onKeyPress,\n                    onIncorrectKey: paramObj.onIncorrectKey,\n                    proceedOnHide: paramObj.proceedOnHide\n                };\n                QRTE.questionQueue.push(QuestionStackElement);\n            });\n        },\n\n        /**\n         * Exit denotes the end of the block. Important for the initialization phase and the exit phase.\n         * Make the question a Form question with precisely 2 answer fields (more is unnecessary, those will get ignored)\n         * @method Exit\n         */\n        Exit: function() {\n\n\n            qArray = $('Questions').getElementsByClassName('QuestionOuter');\n            for (var i = 0; i < qArray.length && i < QRTE.initIndex + 1; i += 1) {\n                qArray[i].style.display = 'block';\n            }\n            Qualtrics.SurveyEngine.addOnload(function() {\n                //Hide all choice\n                this.hideChoices();\n                //display the question\n                //this.questionContainer.style.display = 'none';\n                var QuestionStackElement, onShowFn;\n                onShowFn = function() {\n\n                    //Create and/or store standard information about the trial\n                    var blockId = QRTE.getBlockData('QRTLib_currentBlock'),\n                        tempTD = {},\n                        key,\n                        i;\n\n                    QRTE.setBlockData('QRTLib_previousEndTime', window.requestAnimationFrame.now());\n                    QRTE.setTrialData(blockId + '[TrialNr]', QRTE.getBlockData('QRTLib_blockCounter'));\n                    QRTE.setTrialData(blockId + '[RefreshPeriod]', QRTE.refreshPeriod);\n                    QRTE.setTrialData('BlockId', blockId);\n                    QRTE.setTrialData('EngineType', window.requestAnimationFrame.method);\n                    QRTE.setTrialData('Exit[OnsetTime]', window.requestAnimationFrame.now());\n                    QRTE.setTrialData('QRTEngine[Version]', QRTE.version);\n\n                    //CHECK IF ATLEAST TWO FORM FIELDS HAVE BEEN DEFINED\n                    this.setChoiceValue(2, 'testtest');\n                    if (this.getChoiceValue(2) !== 'testtest') {\n                        //alert('You need to define two answer form fields in the Exit question!!');\n                    }\n\n                    for (key in QRTE.TDCache) {\n                        if (QRTE.TDCache.hasOwnProperty(key) && key !== '') {\n                            //Change QID thingies to entered ID's, also force every value to a string so that the Parser handles high numerical values correctly\n                            tempTD[QRTE.getOutputKey(key)] = String(QRTE.TDCache[key]);\n                        }\n                    }\n\n                    this.setChoiceValue(1, Object.toJSON(tempTD));\n                    this.setChoiceValue(2, blockId);\n                    if (QRTE.SDCache[QRTE.columnsField][blockId] === undefined) {\n                        QRTE.SDCache[QRTE.columnsField][blockId] = [];\n                    }\n                    for (i = 0; i < QRTE.newlyAddedColumns.length; i += 1) {\n                        QRTE.SDCache[QRTE.columnsField][blockId].push(QRTE.getOutputKey(QRTE.newlyAddedColumns[i]));\n                    }\n\n                    QRTE.setSurveyData(QRTE.columnsField, Object.toJSON(QRTE.SDCache[QRTE.columnsField]));\n                    QRTE.setBlockData('QRTLib_blockCounter', QRTE.getBlockData('QRTLib_blockCounter') + 1);\n                    QRTE.setBlockData('QRTLib_previousStorageDone', window.requestAnimationFrame.now());\n                    QRTE.saveBlockData();\n\n                    //If wanting to test, uncomment this line and comment the one after that to enforce manual nextbutton clicks\n                    //$('NextButton').style.display = 'block';\n                    //QRTE.submitPage();\n                    QRTEController.loadNextTrial();\n                };\n\n                QuestionStackElement = {\n                    questionElement: this,\n                    onShowFunc: onShowFn,\n                    type: 'Storage',\n                    loadConfig: true,\n                    conditional: function() {\n                        return true;\n                    }\n                };\n                QRTE.questionQueue.push(QuestionStackElement);\n\n                QRTE.startTrial(0);\n\n            });\n\n            QRTE.loadWaitingList = [false];\n            if (QRTE.waitForImageLoad === true) {\n                //set wait for image load queues.\n                var loadIndex = 1,\n                    images = $$('.QuestionOuter img'),\n                    i = 0;\n\n                var l = images.length;\n                for (; i < l; i += 1) {\n                    images[i].observe('load', function(e) {\n                        QRTE.startTrial(e.path[0].QRTELoadIndex);\n                    })\n                    images[i].QRTELoadIndex = i + 1;\n                    QRTE.loadWaitingList[i + 1] = false;\n                }\n\n            }\n\n        },\n\n        /**\n         * Remove the padding Qualtrics adds between Questions (causes question presentation to drift downwards if not called).\n         * DEPRECATED: Separators hidden through CSS now\n         * @method removeSeparators\n         * @private\n         */\n        removeSeparators: function() {\n            var questionElement = document.getElementById('Questions'),\n                index;\n            for (index = 0; index < questionElement.children.length; index += 1) {\n                if (questionElement.children[index].className === \"Separator\") {\n                    questionElement.children[index].parentNode.removeChild(questionElement.children[index]);\n                }\n            }\n        },\n        /**\n         * Notifies the engine the first trial is ready to be started. Called at the end of the 'exit' question\n         * @private\n         * @method startTrial\n         */\n        startTrial: function(startId) {\n            var duringDisplayFn, onHideFn, onDisplayFn, serverCommDelay, remainingDelay;\n            //All questions have been hidden, so display the parent block again\n            //$('Questions').style.display = 'block';\n\n            QRTE.loadWaitingList[startId] = true;\n            if (!QRTE.loadWaitingList.every()) {\n                QRTE.log('Process ' + startId + 'finished, waiting for other processes to finish')\n                return;\n            }\n\n            //Save the absolute time of when onLoad part of library was finished\n            serverCommDelay = window.requestAnimationFrame.now() - QRTE.getBlockData('QRTLib_previousEndTime'); //Calculate the remaining time based on the lib initialization + server delay times\n            remainingDelay = QRTE.getBlockData('QRTLib_intraTrialDelay') - serverCommDelay;\n\n\n            if (isNaN(remainingDelay)) {\n                remainingDelay = QRTE.getBlockData('QRTLib_intraTrialDelay') * 3;\n                //If this init call is the first one of the block (first trial), calculate the estimated refreshdelay during the pre-trial interval\n                onDisplayFn = function(ele, time) {\n                    QRTE.setTrialData('Init[OffsetTime]', ele.displayOnsetTime);\n                    QRTE.setTrialData('Init[CalculatedDuration]', ele.displayOnsetTime - QRTE.getTrialData('Init[OnsetTime]'));\n                    QRTE.refreshPeriodEstimationStack = [];\n                };\n                duringDisplayFn = function(ele, time) {\n                    //Get current time, required for \n                    QRTE.refreshPeriodEstimationStack.push(time);\n                };\n                onHideFn = function(ele, timestamp) {\n                    var diffs = [];\n\n                    for (i = 1; i < QRTE.refreshPeriodEstimationStack.length; i += 1) {\n                        diffs[i - 1] = QRTE.refreshPeriodEstimationStack[i] - QRTE.refreshPeriodEstimationStack[i - 1];\n                    }\n                    QRTE.refreshPeriod = QRTE.median(diffs);\n                    QRTE.log('Estimated refresh delay = ' + QRTE.refreshPeriod);\n                    QRTE.setBlockData('QRTE_refreshPeriod', QRTE.refreshPeriod);\n                    QRTE.referenceTime = timestamp;\n                    QRTE.framesSinceReference = 0;\n                };\n            } else {\n                onDisplayFn = function(ele, time) {\n                    QRTE.setTrialData('Init[OffsetTime]', ele.displayOnsetTime);\n                    QRTE.setTrialData('Init[CalculatedDuration]', ele.displayOnsetTime - QRTE.getTrialData('Init[OnsetTime]'));\n                };\n\n                QRTE.refreshPeriod = QRTE.getBlockData('QRTE_refreshPeriod');\n            }\n\n            //QRTE.setTrialData('ITI[Duration]', (remainingDelay > 0) ? remainingDelay : 0);\n            QRTE.initTime = window.requestAnimationFrame.now();\n\n            QRTE.postInitElement.onHideFn = onHideFn;\n            QRTE.postInitElement.onDisplayFn = onDisplayFn;\n            QRTE.postInitElement.duringDisplayFn = duringDisplayFn;\n            QRTE.setConfig('InitPost', 'duration', (remainingDelay > 0) ? remainingDelay : 0);\n            //UNCOMMENT\n            //QRTE.setConfig('InitPost', 'duration', (remainingDelay > 0) ? remainingDelay : Infinity);\n            QRTE.inited = true;\n\n            //Set initial trial data related to loading of this trial\n            QRTE.setTrialData('InitServerComm[Onset]', QRTE.getBlockData('ServerCommOnset'));\n            QRTE.setTrialData('InitServerComm[Offset]', QRTE.getBlockData('ServerCommOffset'));\n            QRTE.setTrialData('InitServerComm[CalculatedDuration]', QRTE.getBlockData('ServerCommOffset') - QRTE.getBlockData('ServerCommOnset'));\n\n            //<Load next trial here>\n            var currentLoops = '${lm://CurrentLoopNumber}',\n                totalLoops = '${lm://TotalLoops}';\n            //Check if last trial, currentloops === totalLoops;\n            QRTEController.requestNextTrial(currentLoops !== '' && currentLoops === totalLoops);\n\n            QRTE.proceed();\n        },\n\n\n\n        proceed: function() {\n            QRTE.log(\"proceed called after \" + window.requestAnimationFrame.now() - QRTE.initTime);\n            QRTE.hideAllElements();\n        },\n\n        proceedPage: function() {\n            var currentQ;\n            QRTE.log(\"Proceeding page..\");\n            while (QRTE.currentPageQuestions.length > 0) {\n                currentQ = QRTE.currentPageQuestions.shift();\n\n                //Disable\n                currentQ.questionElement.QRTLib_isActive = false;\n            }\n\n\n            //Go to next question\n            QRTE.showNextPage();\n        },\n\n        disableQuestion: function(disableQ) {},\n\n        /**\n         * Determine and show the next page/slide\n         * @private\n         * @method showNextPage\n         */\n        showNextPage: function() {\n            var continueSearch = true,\n                shownQ = false,\n                nextQ,\n                shown;\n            while (continueSearch === true) {\n                continueSearch = false;\n                nextQ = QRTE.questionQueue.shift();\n                if (nextQ !== undefined && (nextQ.type === 'Stimulus' || nextQ.type === 'Storage')) {\n                    QRTE.currentPageQuestions.push(nextQ);\n                    shown = QRTE.showStimulusQuestion.apply(nextQ.questionElement, [nextQ]);\n\n                    if (nextQ.stimContinue) {\n                        continueSearch = true;\n                        if (shown === true) {\n                            shownQ = true;\n                        }\n                    }\n                    QRTE.log('shown ' + nextQ.id + ': ' + shown);\n                    QRTE.log('continue ' + nextQ.id + ': ' + continueSearch);\n                    if (shown === false && shownQ === false) {\n                        continueSearch = true;\n                    }\n                }\n            }\n\n        },\n\n        /**\n         * Show Question\n         * Handles the activation of that question, which includes:\n         * The loading of the configuration (duration, allowable keys etc).\n         * Sets the event handler to respond to any key presses during the event.\n         * @private\n         * @method showStimulusQuestion\n         * @param question {Object} question to be shown.\n         *  @param id {String} Id of question.\n         *  @param onShowFunc {Function} Function to be called when showing question\n         *  @param loadConfig {Boolean} If true, config is loaded from the current block data (which has been defined elsewhere)\n         *  @param questionElement {Object} This Qualtrics question element\n         *  @param duringDisplayFn {Function} Function to be called each frame that the question is presented\n         */\n        showStimulusQuestion: function(question) {\n            //Save the loading start time\n            //QRTE.setTrialData(question.questionElement.QRTLibId + '[LoadStartTime]', window.requestAnimationFrame.now());\n            //Set mapping of the QID -> QRTE Id\n            QRTE.setId(this, question.id);\n\n            //Initialize variables\n            var stimulusShown = false,\n                questionScope = this,\n                dispEle;\n            QRTE.log(question);\n\n            //Check whether question should be shown or not, if not skip to the next question (implicitly)\n            if (question.conditional() === true) {\n                this.QRTLib_isActive = true;\n\n\n                if (question.loadConfig === true) {\n                    //Load the Configuration of the Question, important!\n                    QRTE.loadConfig(this);\n                }\n\n                //Check if KeyPress listener is required (one or more of the following fields are defined: onKeyPress, onCorrectKey or onAllowableKey)\n                //If so, add keypress listener.\n                if (question.onKeyPress !== undefined || question.questionElement.allowable !== '' || question.questionElement.cresp !== '') {\n                    //Initialize the fields used for storing data about RT timing.\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[RTTime]', '');\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[RT]', '');\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[RESP]', '');\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[ACC]', 0);\n\n                    //Add the key listener\n                    QRTE.addKeyListener(function(e) {\n\n                        //Get the Key of the response\n                        var RT, RESP = QRTE.keycode2string(e),\n                            RTTime = window.requestAnimationFrame.now();\n                        RT = RTTime - QRTE.getTrialData(question.questionElement.QRTLibId + '[OnsetTime]');\n\n                        //Store the Time of the Key Press and calculate the RT and ACC if correct\n\n                        if ((QRTE.isAllowableResponse(question.questionElement, RESP) || QRTE.isCorrectResponse(question.questionElement, RESP)) && QRTE.getTrialData(question.questionElement.QRTLibId + '[RTTime]') === '') {\n                            QRTE.setTrialData(question.questionElement.QRTLibId + '[RTTime]', RTTime);\n                            QRTE.setTrialData(question.questionElement.QRTLibId + '[RT]', RT);\n                            QRTE.setTrialData(question.questionElement.QRTLibId + '[RESP]', RESP);\n                            if (QRTE.isCorrectResponse(question.questionElement, RESP)) {\n                                QRTE.saveAcc(question.questionElement, 1);\n                            } else {\n                                QRTE.saveAcc(question.questionElement, 0);\n                            }\n                        }\n\n                        //Store the RT and the Response\n\n                        //Set Handling Key Press to true, this lets the engine know that a keypress is currently being handled. Necessary when there is a timer (response deadline)\n                        question.handlingKeyPress = true;\n\n                        if (question.onCorrectKey !== undefined && QRTE.isCorrectResponse(question.questionElement, RESP)) {\n                            question.onCorrectKey.apply(question.questionElement, [e, RESP]);\n                        } else if (question.onIncorrectKey !== undefined && QRTE.isAllowableResponse(question.questionElement, RESP)) {\n                            question.onIncorrectKey.apply(question.questionElement, [e, RESP]);\n                        }\n\n                        if (question.onAllowableKey !== undefined && QRTE.isAllowableResponse(question.questionElement, RESP)) {\n                            question.onAllowableKey.apply(question.questionElement, [e, RESP]);\n                        }\n\n                        if (question.onKeyPress !== undefined) {\n                            question.onKeyPress.apply(question.questionElement, [e, RESP]);\n                        }\n\n                        if (question.questionElement.endAction === 'TERMINATE') {\n                            //Proceed to the next Question Page if the response is allowable\n                            if (QRTE.isAllowableResponse(question.questionElement, RESP) && question.questionElement.QRTLib_isActive === true) {\n                                question.questionElement.proceed();\n                            }\n                        }\n                        question.handlingKeyPress = false;\n\n                    }, this);\n                }\n\n                //Build the display Element. Stimuli Questions have to take into account the possibility of being associated with a key press. \n                //OnDisplayFn therefore logs the displayOnsetTime, so that the RT can be calculated.\n                dispEle = {\n                    el: this.questionContainer,\n                    duration: this.duration,\n                    delay: this.offset,\n                    duringDisplayFn: question.duringDisplayFn,\n                    onDisplayFn: function(displayEl, timestamp) {\n                        if (question.onDisplayFn !== undefined) {\n                            question.onDisplayFn(displayEl, timestamp);\n                        }\n                        QRTE.setTrialData(questionScope.QRTLibId + '[OnsetTime]', displayEl.displayOnsetTime);\n                    },\n                    proceedOnHide: question.proceedOnHide,\n                    id: question.id\n                };\n\n                //Set the OnHide Function\n                dispEle.onHideFn = function(displayEl, timestamp) {\n                    if (question.onHideFn !== undefined) {\n                        question.onHideFn(displayEl, timestamp);\n                    }\n                    QRTE.setTrialData(questionScope.QRTLibId + '[OffsetTime]', displayEl.displayOffsetTime);\n                    QRTE.setTrialData(questionScope.QRTLibId + '[CalculatedDuration]', displayEl.displayDuration);\n                };\n\n\n                this.QRTLib_timer = QRTE.displayElement(dispEle);\n\n                question.onShowFunc.apply(this);\n\n                stimulusShown = true;\n            }\n\n            //QRTE.setTrialData(question.questionElement.QRTLibId + '[LoadEndTime]', window.requestAnimationFrame.now());\n            return stimulusShown;\n        },\n\n        setId: function(question, desc) {\n\n            this.idCache[question.questionId] = desc;\n            question.qId = desc;\n\n            Qualtrics.SurveyEngine.setEmbeddedData(QRTE.idField, Object.toJSON(this.idCache));\n        },\n\n        getOutputKey: function(key) {\n            var oldKey;\n            for (oldKey in this.idCache) {\n                if (this.idCache.hasOwnProperty(oldKey) && oldKey === key.substring(0, oldKey.length)) {\n\n                    return QRTE.getBlockData('QRTLib_currentBlock') + this.idCache[oldKey] + key.substring(oldKey.length, key.length);\n                }\n            }\n            return key;\n        },\n\n\n        OnKeyPress: function(fn, qScope) {\n\n            qScope = qScope || window;\n\n            var keyFn = function(e) {\n                QRTE.setTrialData(qScope.QRTLibId + '[RTTime]', window.requestAnimationFrame.now());\n                var RT = QRTE.getTrialData(qScope.QRTLibId + '[RTTime]') - QRTE.getTrialData(qScope.QRTLibId + '[OnsetTime]');\n                QRTE.setTrialData(qScope.QRTLibId + '[RT]', RT);\n                QRTE.setTrialData(qScope.QRTLibId + '[RESP]', QRTE.keycode2string(e));\n                QRTE.log(qScope);\n                fn.apply(qScope, [e]);\n            }\n\n            QRTE.addKeyListener(keyFn, qScope);\n        },\n\n        addKeyListener: function(fn, listenerScope) {\n            Event.observe(document, 'keypress', function(e) {\n                if (listenerScope.QRTLib_isActive === true) {\n                    fn.apply(listenerScope, [e]);\n                }\n            });\n        },\n\n        /*  \n         **************Methods below this line are support methods*******************\n         */\n\n        hideQuestions: function() {\n            qArray = $('Questions').getElementsByClassName('QuestionOuter');\n            for (var i = 0; i < qArray.length; i += 1) {\n                qArray[i].style.display = 'none';\n            }\n        },\n\n        unhideQuestions: function() {\n            //Redisplay outer questions\n            qArray = $('Questions').getElementsByClassName('QuestionOuter');\n            for (var i = 0; i < qArray.length; i += 1) {\n                qArray[i].style.display = 'block';\n            }\n            //Redisplay separators\n            qArray = $('Questions').getElementsByClassName('Separator');\n            for (var i = 0; i < qArray.length; i += 1) {\n                qArray[i].style.display = 'block';\n            }\n\n\n        },\n\n        _handleKeyPressEvent: function() {\n\n        },\n\n        _setConfig: function(QID, option, value, setterFunc) {\n            var qidString = QID;\n            if (typeof QID !== 'string') {\n                qidString = QID.questionId;\n            }\n            option = option.toLowerCase();\n\n            switch (option) {\n                case 'duration':\n                    if (value instanceof Array) {\n                        value = value[Math.floor(Math.random() * value.length)];\n                    }\n                    setterFunc.apply(this, [qidString, 'Duration', value]);\n                    break;\n                case 'allowable':\n                    setterFunc.apply(this, [qidString, 'Allowable', value]);\n                    break;\n                case 'cresp':\n                    setterFunc.apply(this, [qidString, 'CRESP', value]);\n                    break;\n                case 'delay':\n                    setterFunc.apply(this, [qidString, 'Offset', value]);\n                    break;\n                case 'endaction':\n                    setterFunc.apply(this, [qidString, 'EndAction', value]);\n                    break;\n                default:\n                    QRTE.log('No such configuration: ' + option);\n                    break;\n            }\n        },\n        getDuration: function(question) {\n            var duration = Infinity,\n                edDuration = this.getTrialData(question.QRTLib_configId + '[Duration]');\n            if (edDuration !== undefined && edDuration !== '' && !isNaN(edDuration)) {\n                duration = edDuration;\n            }\n            if (question._Duration !== undefined && question._Duration !== '' && !isNaN(question._Duration)) {\n                duration = question._Duration;\n            }\n\n            return duration;\n        },\n        getAllowable: function(question) {\n            var allowable = \"\",\n                edAllowable = this.getTrialData(question.QRTLib_configId + '[Allowable]');\n            if (edAllowable !== undefined) {\n                allowable = edAllowable;\n            }\n            if (question._Allowable !== undefined) {\n                allowable = question._Allowable;\n            }\n\n            if (allowable === '{ANY}') {\n                allowable = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890-=[]\\\\;',./`\";\n            }\n            //allowable = allowable.toUpperCase();\n            return allowable;\n        },\n        getCResp: function(question) {\n            var cresp = '',\n                edcresp = this.getTrialData(question.QRTLib_configId + '[CRESP]');\n            if (edcresp !== undefined) {\n                cresp = edcresp;\n            }\n            if (question._cresp !== undefined) {\n                cresp = question._CRESP;\n            }\n\n            if (cresp === '{ANY}') {\n                cresp = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890-=[]\\\\;',./`\";\n            }\n            //cresp = cresp.toUpperCase();\n\n            return cresp;\n        },\n\n        getOffset: function(question) {\n            var offset = 0,\n                edOffset = this.getTrialData(question.QRTLib_configId + '[Offset]');\n            if (edOffset !== undefined && edOffset !== '' && !isNaN(edOffset)) {\n                offset = edOffset;\n            }\n            if (question._Offset !== undefined && question._Offset !== '' && !isNaN(question._Offset)) {\n                offset = question._Offset;\n            }\n\n            return offset;\n\n        },\n\n        getEndAction: function(question) {\n            var endAction = 'NONE',\n                edEndAction = this.getTrialData(question.QRTLib_configId + '[EndAction]');\n            if (edEndAction !== undefined && edEndAction !== '') {\n                endAction = edEndAction;\n            }\n            if (question._EndAction !== undefined && question._EndAction !== '') {\n                endAction = question._EndAction;\n            }\n\n            return endAction;\n\n        },\n        evaluateConditional: function(conditional) {\n            QRTE.log('Conditional: ', conditional);\n            return conditional === '' || conditional();\n        },\n        log: function() {\n            if (QRTE.debug === true) {\n                for (var i = 0; i < arguments.length; i += 1) {\n                    console.log(arguments[i]);\n                }\n            }\n        },\n\n        median: function(values) {\n\n            values.sort(function(a, b) {\n                return a - b;\n            });\n\n            var half = Math.floor(values.length / 2);\n\n            if (values.length % 2) return values[half];\n            else return (values[half - 1] + values[half]) / 2.0;\n        },\n\n        waitForKey: function(question, keys) {\n            Event.observe(document, 'keypress', function(e) {\n                var resp = QRTE.keycode2string(e);\n                if (keys.indexOf(resp) >= 0) {\n                    question.clickNextButton();\n                }\n            });\n        },\n\n        validateParams: function(paramObj, validationArray) {\n            var valObj, val, index, typeCheck = true,\n                indexType;\n            //Loop over validationArray to check whether parameters suffice\n            for (index = 0; index < validationArray.length; index += 1) {\n                valObj = validationArray[index];\n                if (paramObj[valObj.name] === undefined && valObj.required === true) {\n                    alert('Required parameter: ' + valObj.name + ' seems to be missing');\n                    QRTE.log('Required parameter: ' + valObj.name + ' seems to be missing');\n                    break;\n                }\n\n                val = paramObj[valObj.name];\n\n                //Loop over type checkers\n                for (indexType = 0; indexType < valObj.type.length; indexType += 1) {\n                    typeCheck = QRTE.validateType(val, valObj.type[indexType]);\n                    if (typeCheck === true) {\n                        break;\n                    }\n                }\n                if (typeCheck === false && valObj.required === true) {\n                    alert('Parameter: ' + valObj.name + ' is of the wrong type, expected type: ' + valObj.type + ', type received: ' + (typeof val) + \"\\n\" + \"Please open the console for detailed error messages\");\n                    QRTE.log('Parameter: ' + valObj.name + ' is of the wrong type, expected type: ' + valObj.type + ', type received: ' + (typeof val));\n                    QRTE.log('Faulty parameter ' + valObj.name + ': ', val);\n                    QRTE.log('Proper functioning of QRTE is no longer guaranteed, please fix the above error');\n                }\n\n            }\n        },\n\n        validateType: function(val, type) {\n            switch (type) {\n                case 'JSON':\n                    return val.isJSON();\n                case 'String':\n                    return (typeof val === 'string' || val instanceof String);\n                case 'Number':\n                    return (!isNaN(parseFloat(val)) && isFinite(val));\n                case 'Array':\n                    return val instanceof Array;\n                case 'Object':\n                    return typeof val === 'object';\n                case 'Function':\n                    return typeof val === 'function';\n                case 'Boolean':\n                    return (val === true || val === false);\n                case 'Empty':\n                    return val === '';\n                default:\n                    return false;\n            }\n        },\n\n        fixSetEmbeddedDataBug: function() {\n            Qualtrics.SurveyEngine.setEmbeddedData = function(key, value) {\n                var fieldName = 'ED~' + key;\n                if ($(fieldName)) {\n                    $(fieldName).value = value;\n                } else {\n                    $('Header').appendChild(QBuilder('input', {\n                        type: 'hidden',\n                        id: fieldName,\n                        name: fieldName,\n                        value: value\n                    }));\n                    Qualtrics.SurveyEngine.setEmbeddedData(key, value);\n                }\n            }\n        },\n\n        //DisplayEngine part\n\n        //Since it's impossible to know when a screen refresh has happened, we assume that the first timestamp is the actual screen refresh.\n        //Based on the difference between the current timestamp Tn and the root timestamp Tn-1, we estimate the amount of frames that have passed since. \n        //Based on the amount of frames we estimate the previous screen refresh. Although not perfect, it's the best we can do.\n\n        refreshRate: 60, //hertz\n        refreshPeriod: 1000 / 60,\n        lastRefresh: 0,\n        currentRefresh: 0,\n        previousTimestamp: 0,\n        referenceTime: 0,\n        framesSinceReference: 0,\n        currentStack: [],\n        proceedOnFrameEnd: false,\n\n        init: function() {\n            window.requestAnimationFrame(QRTE.draw);\n        },\n\n        draw: function(timestamp) {\n            var curEle, newStack = [];\n            timestamp = window.requestAnimationFrame.now();\n\n\n            if (timestamp < 1e12) {\n                timestamp += window.performance.timing.navigationStart;\n            }\n\n            if (QRTE.referenceTime === 0) {\n                QRTE.referenceTime = timestamp;\n                QRTE.previousTimestamp = timestamp;\n                QRTE.framesSinceReference = 0;\n            } else {\n                //QRTE.framesSinceReference += QRTE.calcFrames(QRTE.referenceTime, timestamp);\n                QRTE.prevFrames = QRTE.framesSinceReference;\n                //frameDiff =  QRTE.calcFrames(QRTE.referenceTime, timestamp) - QRTE.prevFrames;\n                QRTE.framesSinceReference = QRTE.calcFrames(QRTE.referenceTime, timestamp);\n            }\n            QRTE.currentRefresh = (QRTE.framesSinceReference * QRTE.refreshPeriod) + QRTE.referenceTime;\n            QRTE.projectedRefresh = QRTE.currentRefresh + QRTE.refreshPeriod;\n            curEle = QRTE.currentStack.shift();\n\n            while (curEle) {\n                curEle.keep = true;\n\n                //Call duringDisplay callback function, with the current element and the timestamp as arguments.\n                if (curEle.shown === true && typeof curEle.duringDisplayFn === 'function') {\n                    curEle.duringDisplayFn(curEle, timestamp);\n                }\n\n                if (QRTE.proceedOnFrameEnd === true || curEle.hide === true || (curEle.shown === true && curEle.displayOnset !== undefined && (curEle.displayOnset + curEle.duration < QRTE.projectedRefresh))) {\n                    //If the next refresh makes it go beyond the duration, hide the element again!\n                    curEle = QRTE.hideSingleEle(curEle, timestamp);\n                } else if (curEle.shown === false && curEle.requestedAt + curEle.delay < QRTE.projectedRefresh) {\n                    curEle = QRTE.dispSingleEle(curEle, timestamp);\n                }\n\n                if (curEle.keep === false && curEle.proceedOnHide === true) {\n                    //Behold! We have found an element that commands us to proceed to the next page.\n                    QRTE.proceedOnFrameEnd = true;\n                    //Every element that has been processed so far needs to be re-processed (sadly), so that they properly hide.\n                    for (var ind = 0; ind < newStack.length; ind += 1) {\n                        if (newStack[ind].hide !== true) {\n                            newStack[ind].hide = true;\n                            QRTE.currentStack.push(newStack[ind]);\n                        }\n                    }\n                } else {\n                    //Push it to the newStack, for it to be processed next time.\n                    newStack.push(curEle);\n                }\n\n                curEle = QRTE.currentStack.shift();\n            }\n            QRTE.currentStack = newStack;\n            QRTE.lastRefresh = QRTE.currentRefresh;\n            QRTE.previousTimestamp = timestamp;\n            window.requestAnimationFrame(QRTE.draw);\n            if ((newStack.length === 0 || QRTE.proceedOnFrameEnd) && QRTE.inited === true) {\n                QRTE.proceedOnFrameEnd = false;\n                QRTE.proceedPage();\n            }\n\n\n        },\n\n        calcFrames: function(previous, current) {\n            var diff = current - previous,\n                frames = 0;\n\n            if (diff < QRTE.refreshPeriod) {\n                frames = 1;\n            } else {\n                frames = Math.floor(diff / QRTE.refreshPeriod);\n                if (diff % QRTE.refreshPeriod >= (QRTE.refreshPeriod * 0.9)) {\n                    frames += 1;\n                }\n            }\n\n            return frames;\n        },\n\n        /**\n         * Display an element for a specified duration with a specified delay. Vsyncs the display duration using requestAnimationFrame (if possible in the browser)\n         * and allows for high-precision control over its duration. Please start any custom attributes for the paramObj with the 'custom_' header, to avoid collisions.\n         * @private\n         * @method displayElement\n         * @param paramObj {Object}\n         *  @param el {Object} HTML element to be displayed\n         *  @param [onHideFn] {Function} Function to be called upon removing the element from display, is passed one argument containing all information about the display element.\n         *  @param [duration] {Number} Number of milliseconds (ms) the element should be displayed.\n         *  @param [delay] {Number} Number of milliseconds (ms) the Engine should wait before displaying the element.\n         *  @param [duringDisplayFn] {Function} Function to be called upon displaying the element for another screen refresh. Careful: Keep this function simple, could seriously hamper performance as it's called about every 16-17 ms.  is passed one argument containing all information about the display element.\n         *  @param [onDisplayfn] {Function} Function to be called upon starting to display the element. Is passed one argument containing all information about the display element.\n         */\n\n        //displayElement: function(el, callback, duration, offset, duringDisplaycb) {\n        displayElement: function(paramObj) {\n            var reqAt,\n                id = String(Math.random());\n            //QRTE.log(arguments);\n            if (paramObj.delay === undefined) {\n                paramObj.delay = 0;\n            }\n\n\n\n            if (paramObj.duration === undefined) {\n                paramObj = Infinity;\n            }\n\n            if (isNaN(QRTE.lastRefresh)) {\n                reqAt = window.requestAnimationFrame.now();\n            } else {\n                reqAt = QRTE.lastRefresh;\n            }\n            paramObj.userId = paramObj.id;\n            paramObj.id = id;\n            paramObj.shown = false;\n            paramObj.requestedAt = reqAt;\n            paramObj.hide = false;\n\n            QRTE.currentStack.push(paramObj);\n            if (paramObj.delay === 0) {\n                //This element needs to be displayed as soon as possible\n                QRTE.dispSingleEle(paramObj, QRTE.previousTimestamp);\n            }\n            QRTE.log('Added element to display stack:', paramObj);\n            //console.log('paramObj: ', paramObj.userId, ', duration: ', paramObj.duration);\n\n            return id;\n        },\n\n        hideElement: function(id) {\n            var found = false,\n                i;\n            for (i = 0; i < QRTE.currentStack.length; i += 1) {\n                if (QRTE.currentStack[i].id === id) {\n                    found = true;\n                    QRTE.currentStack[i].hide = true;\n                    this.log('Element to be hidden: ', QRTE.currentStack[i]);\n                }\n            }\n            return found;\n        },\n\n        hideAllElements: function() {\n            for (i = 0; i < QRTE.currentStack.length; i += 1) {\n                QRTE.currentStack[i].hide = true;\n            }\n            QRTE.proceedOnFrameEnd = true;\n        },\n\n        /**\n         * Hide a DrawEngine Element\n         * @private\n         * @method hideSingleEle\n         * @param curEle {Object}\n         */\n        hideSingleEle: function(curEle, timestamp) {\n            curEle.displayOffset = QRTE.projectedRefresh;\n            curEle.displayOffsetTime = window.requestAnimationFrame.now();\n            curEle.el.style.display = 'none';\n            curEle.keep = false;\n            curEle.hide = true;\n            //delete QRTE.currentStack[key];\n            curEle.displayDuration = curEle.displayOffsetTime - curEle.displayOnsetTime;\n            if (curEle.onHideFn !== undefined) {\n                curEle.onHideFn(curEle, timestamp);\n            }\n\n            return curEle;\n\n        },\n\n\n        /**\n         * Display a DrawEngine Element\n         * @private\n         * @method dispSingleEle\n         * @param curEle {Object}\n         */\n        dispSingleEle: function(curEle, timestamp) {\n            curEle.el.style.display = 'block';\n            curEle.displayOnset = QRTE.projectedRefresh;\n            curEle.displayOnsetTime = window.requestAnimationFrame.now();\n            curEle.shown = true;\n            if (curEle.onDisplayFn !== undefined) {\n                //Added try-catch block to catch the error that's causing the OnsetTime not to get saved.\n                try {\n                    curEle.onDisplayFn(curEle, timestamp);\n                } catch (e) {\n                    QRTE.setTrialData('Error[OnsetError]', JSON.stringify(e));\n                }\n            }\n            return curEle;\n        },\n\n        checkEngineCompatibility: function() {\n            return window.requestAnimationFrame.method === 'native-highres';\n        },\n    };\n\n    if (typeof QRTEController == 'undefined') {\n        //QRTE SurveySlider controller layer\n        //Takes care of progressing through the survey. Catches all qualtrics native ways of submitting the form and replaces that by\n        //its own asynchronous ajax stuff.\n        QRTEController = {\n\n\n            //This plug-in to QRTEngine has been developed under the name SurveySlider\n            // for general Qualtrics Surveys. It has been adapted to work with QRTEngine\n            nextTrialContainer: null,\n            nextTrialText: '',\n            currentForm: null,\n            previousForm: null,\n            handlingSubmit: false,\n            onSubmitStack: [],\n            inited: false,\n            childInputs: [],\n            loadUponCallback: false,\n            setEmbeddedData: function() {},\n            tempED: {},\n\n\n\n            //Initialize thecontroller\n            init: function() {\n                this.nextTrialContainer = new Element('div', {\n                    id: 'nextTrialContainer'\n                });\n                this.currentForm = $$('form')[0];\n\n                //Catch submits and change it with our own submit function (which does AJAX submissions)\n                //this.currentForm.observe('QRTE:submit', QRTE.handleSubmit);\n                this.currentElements = $$('.QuestionOuter');\n\n                //Initial SSload firing\n                Qualtrics.SurveyEngine.addOnload(function() {\n                    QRTEController.currentForm.fire('QRTE:load');\n                });\n                //Change SurveyEngine.OnLoad to trigger on SSload, rather than page load\n                Qualtrics.SurveyEngine.addOnload = function(f) {\n                        var questions = $$('.QuestionOuter'),\n                            currentCount = QRTEController.count(Qualtrics.SurveyEngine.QuestionInfo),\n                            id = questions[currentCount - 1].id;\n                        if ($('body') && $('body').hasClassName('EditSection')) return;\n                        try {\n                            var obj = new Qualtrics.SurveyEngine.QuestionData(id);\n                            obj.onload = f;\n\n                            QRTEController.currentForm.observe('QRTE:load', obj.onload.bind(obj));\n                            //Event.observe(this.currentForm, 'SSload', obj.onload.bind(obj));\n                        } catch (e) {\n                            console.error('SE API Error: ' + e);\n                        }\n                    }\n                    //Set the Qualtrics setEmbeddedData to inside the QRTEController\n                QRTEController.setEmbeddedData = Qualtrics.SurveyEngine.setEmbeddedData;\n                Qualtrics.SurveyEngine.setEmbeddedData = function(key, value) {\n                    QRTEController.tempED[key] = value;\n                }\n                this.submitPage = this.requestNextTrial;\n                this.inited = true;\n            },\n\n            /**\n             * Requests the next trial from the Qualtrics server.\n             *\n             *\n             */\n            requestNextTrial: function(isLastTrial) {\n\n                //If this is the last trial of a block, DON'T request the next page, let qualtrics handle it themselves\n                if (this.handlingSubmit === false && isLastTrial === false) {\n                    //Load next trial means that current page is a trial and has been inited\n                    //Need to remove relevant input elements from current form before submitting\n                    //After that add them back\n                    this.handlingSubmit = true\n                    var childs = $$('form input[type=text]'),\n                        childInputs = [];\n                    //remove current input elements from the form\n                    for (var i = 0; i < childs.length; i += 1) {\n                        childInputs[i] = {\n                            ele: childs[i],\n                            parent: childs[i].up()\n                        };\n                        childs[i].remove();\n                    }\n                    //add previous input elements to form\n                    //Text inputs\n                    for (var i = 0; i < this.childInputs.length; i += 1) {\n                        this.childInputs[i].ele.style.display = 'none';\n                        this.currentForm.insert(this.childInputs[i].ele);\n                    }\n\n\n                    //And embedded data\n                    for (var key in this.tempED) {\n                        if (this.tempED.hasOwnProperty(key)) {\n                            QRTEController.setEmbeddedData(key, this.tempED[key]);\n                        }\n                    }\n                    //Reset stored embedded data\n                    this.tempED = {};\n                    //set new childs\n                    this.childInputs = childInputs;\n\n                    //Loop over submit stack, or callbacks that need to be finished before submitting\n                    for (var i = 0; i < QRTEController.onSubmitStack.length; i += 1) {\n                        QRTE.onSubmitStack[i]();\n                    }\n                    QRTEController.onSubmitStack = [];\n                    debugger;\n                    this.currentForm.request({\n                        onComplete: this.requestNextTrialCallback\n                    });\n\n                    //Set server comm onset for the next trial\n                    QRTE.setBlockData('ServerCommOnset', window.requestAnimationFrame.now());\n\n                    QRTEController.betweenSubmits = true;\n\n                    for (var i = 0; i < this.childInputs.length; i += 1) {\n                        this.childInputs[i].parent.insert(this.childInputs[i].ele);\n                        this.childInputs[i].ele.style.display = 'none';\n                    }\n                } else if (isLastTrial === true) {\n                    //Just add the previous trial's childInputs to the form \n                    for (var i = 0; i < this.childInputs.length; i += 1) {\n\n                        this.currentForm.insert(this.childInputs[i].ele);\n                        this.childInputs[i].ele.style.display = 'none';\n                    }\n\n                    this.loadNextTrial = function() {\n                        //Directly submitting the form doesn't seem to work? Let's do it through NextButton click\n                        $('NextButton').click();\n                    };\n                }\n            },\n\n            loadNextTrial: function() {\n                if (this.handlingSubmit === true) {\n                    //The submit still hasn't returned..\n                    this.loadUponCallback = true;\n                    return;\n\n                }\n                //Set handling submit to false (as page has been returned)\n                //Save the previous form\n                this.previousForm = this.currentForm;\n                //Reset the QuestionInfo object, this is for Qualtrics to correctly initiate its own page\n                Qualtrics.SurveyEngine.QuestionInfo = {}\n                    //Parse the HTML that was returned earlier and set it as the current trial container's contents\n                this.nextTrialContainer = jQuery(this.nextTrialContainer).html(this.nextTrialText)[0];\n                //Filter out the 'form' field, and append it back.\n                this.currentForm = jQuery(this.nextTrialContainer).find('form')[0];\n                jQuery(this.previousForm).replaceWith(jQuery(this.currentForm));\n\n                jQuery(this.currentForm).show();\n\n                if (this.currentForm.select('.END_OF_SURVEY').length === 0) {\n                    this.currentForm.fire('QRTE:load');\n                    this.submitPage = this.requestNextTrial;\n                } else {\n                    this.submitPage = this.currentForm.submit;\n                }\n\n            },\n\n            requestNextTrialCallback: function(e) {\n                QRTEController.nextTrialText = e.responseText;\n                QRTEController.handlingSubmit = false;\n                QRTE.setBlockData('ServerCommOffset', window.requestAnimationFrame.now());\n\n                if (QRTEController.loadUponCallback === true) {\n                    QRTEController.loadUponCallback = false;\n                    QRTEController.loadNextTrial();\n                }\n            },\n\n            submitPage: function() {\n                console.log('Not yet initialised');\n            },\n\n            count: function(obj) {\n                var count = 0;\n\n                for (var prop in obj) {\n                    if (obj.hasOwnProperty(prop))\n                        ++count;\n                }\n\n                return count;\n            },\n\n            BDCache: {},\n            storeBlockData: function(blockData) {\n                this.BDCache = blockData;\n            },\n\n            loadBlockData: function() {\n                return this.BDCache;\n            }\n        };\n\n        document.observe('dom:loaded', QRTEController.init.bind(QRTEController));\n\n\n        (function() {\n            var lastFrame, method, now, queue, requestAnimationFrame, timer, vendor, _i, _len, _ref, _ref1;\n            method = 'native';\n            now = Date.now || function() {\n                return new Date().getTime();\n            };\n            requestAnimationFrame = window.requestAnimationFrame;\n            _ref = ['webkit', 'moz', 'o', 'ms'];\n            for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n                vendor = _ref[_i];\n                if (!(requestAnimationFrame != null)) {\n                    requestAnimationFrame = window[vendor + \"RequestAnimationFrame\"];\n                }\n            }\n            if (!(requestAnimationFrame != null)) {\n                method = 'timer';\n                lastFrame = 0;\n                queue = timer = null;\n                requestAnimationFrame = function(callback) {\n                    var fire, nextFrame, time;\n                    if (queue != null) {\n                        queue.push(callback);\n                        return;\n                    }\n                    time = now();\n                    nextFrame = Math.max(0, 16.66 - (time - lastFrame));\n                    queue = [callback];\n                    lastFrame = time + nextFrame;\n                    fire = function() {\n                        var cb, q, _j, _len1;\n                        q = queue;\n                        queue = null;\n                        for (_j = 0, _len1 = q.length; _j < _len1; _j++) {\n                            cb = q[_j];\n                            cb(lastFrame);\n                        }\n                    };\n                    timer = setTimeout(fire, nextFrame);\n                };\n            }\n            requestAnimationFrame(function(time) {\n                var _ref1;\n                if ((((_ref1 = window.performance) != null ? _ref1.now : void 0) != null) && time < 1e12) {\n                    requestAnimationFrame.now = function() {\n                        return window.performance.now() + window.performance.timing.navigationStart;\n                    };\n                    requestAnimationFrame.method = 'native-highres';\n                } else {\n                    requestAnimationFrame.now = now;\n                }\n            });\n            requestAnimationFrame.now = ((_ref1 = window.performance) != null ? _ref1.now : void 0) != null ? (function() {\n                return window.performance.now() + window.performance.timing.navigationStart;\n            }) : now;\n            requestAnimationFrame.method = method;\n            window.requestAnimationFrame = requestAnimationFrame;\n        })();\n\n        function loadScript(url, callback) {\n\n            var script = document.createElement(\"script\")\n            script.type = \"text/javascript\";\n\n            if (script.readyState) { //IE\n                script.onreadystatechange = function() {\n                    if (script.readyState == \"loaded\" || script.readyState == \"complete\") {\n                        script.onreadystatechange = null;\n                        callback();\n                    }\n\n                };\n            } else { //Others\n                script.onload = function() {\n                    callback();\n                };\n            }\n\n            script.src = url;\n            document.getElementsByTagName(\"head\")[0].appendChild(script);\n        }\n\n        (function() {\n\n            //jQuery is only required for the Fixation flash fix. prototypejs is unable to efficiently replace elements\n            //and introduces a 10 ms delay between loading element and firing off the scripts. Unacceptable\n            //First time jQuery should be used is the second trial\n\n            loadScript(\"https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js\", function() {\n\n                $.noConflict();\n\n            });\n\n        })();\n\n        //If preview mode is run (PreviewBanner element exists, add a QRTEngine plug with id QRTEPlug)\n\n        if ($('PreviewBanner')) {\n            var plug, row, banner = $('PreviewBanner');\n            //Go down to the first table row inside that banner\n            row = banner.children[0].children[0].children[0];\n            //Insert new cell    \n            plug = row.insertCell(2);\n            plug.id = \"QRTEPlug\";\n            plug.width = \"20%\";\n            plug.innerHTML = 'This survey is proudly and successfully powered by <a href=\"http://qrtengine.com\" target=\"_blank\"><i><b>QRTEngine</b></i></a>';\n            plug.style.textAlign = \"center\";\n        }\n    }\n</script>\n<script>\n    QRTE.debug = true;\n\n    QRTLib = QRTE;\n</script>\n<style type=\"text/css\">\n    #Plug {\n        display: none;\n    }\n    #NextButton {\n        display: none;\n    }\n    #PreviousButton {\n        display: none;\n    }\n    html {\n        height: 100%;\n    }\n    body {\n        height: 100%;\n        padding: 0;\n        padding-top: 0 !important;\n        margin: 0;\n    }\n    .Skin {\n        display: table;\n        margin: auto;\n        min-height: 100%;\n        height: 100%;\n    }\n    #Page {\n        height: 100%;\n        min-height: 100%;\n    }\n    .SkinInner {\n        min-height: 100%;\n        display: table-cell;\n        vertical-align: middle;\n    }\n    .QuestionText {\n        border: 0px !important;\n        border-bottom: 0px !important;\n    }\n    .QuestionOuter {\n        display: none;\n    }\n    .Separator {\n        display: none !important;\n    }\n    #SkinContent > #Buttons,    /** ==========================================================\n     * QRTEngine.js v16\n     * ==========================================================\n     * Copyright 2013-2014 Erwin Haasnoot\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     * http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     *\n     *\n     *\n     * ========================================================== */\n    /**\n     * Qualtrics Reaction Time Engine or QRTE is an add-on providing an interface\n     * for easy reaction time experiment creation in the Qualtrics survey research suite (tm).\n     * For instructions on how to use this add-on, see xxxx\n     *\n     * QRTE was developed by Erwin Haasnoot\n     * Email: erwinhaasnoot[at]gmail.com\n     * @class QRTE\n     *\n     */\n     \n    var QRTE = {\n        version: 'v16',\n        columnsField: 'QRTE_columns',\n        blockDataField: 'QRTE_blockData',\n        idField: 'QRTE_idData',\n        exitQuestions: 'QRTE_exitQuestions',\n        inited: false,\n        /**\n         * TDCache contains the Trial-Level Data in an Object. DO NOT directly manipulate this Object. It might cause inconsistencies in the data file and cause unexpected once parsed.\n         * Use QRTE.setTrialData and QRTE.getTrialData instead.\n         *\n         * @property TDCache\n         * @private\n         * @type Object\n         */\n        TDCache: {},\n\n        /**\n         * ColumnCache contains all the mappings from QID to Columns\n         * @property columnCache\n         * @private\n         * @type Object\n         */\n        columnCache: {},\n\n        /**\n         * BDCache contains the BlockLevel Data in an Object. Directly manipulating this Object might cause inconsistencies\n         * @property BDCache\n         * @private\n         * @type Object\n         */\n        BDCache: {},\n\n        /**\n         * SDCache is a cache for speeding up retrieval of Survey level Data,\n         * All Survey data is saved to both Embedded Data and Survey Data\n         * @private\n         * @property SDCache\n         * @type Object\n         */\n        SDCache: {},\n\n        /**\n         * idCache is a cache for quickly retrieving the Qualtrics QID to QRTLib Id mappings.\n         * Saved in the idData embedded data field after every trial.\n         * @private\n         * @property idCache\n         * @type Object\n         */\n        idCache: {},\n\n        /**\n         * questionQueue contains Objects (stimuli) that are waiting to be presented\n         * @private\n         * @property questionQueue\n         * @type Array\n         */\n        questionQueue: [],\n\n        /**\n         * currentPageQuestions contains the Question Objects that are\n         * displayed at any given time.\n         * @private\n         * @property currentPageQuestions\n         * @type Array\n         */\n        currentPageQuestions: [],\n\n        /**\n         * Contains Trial Data Columns that were 'newly' added in this trial run.\n         * @private\n         * @property newlyAddedColumns\n         * @type Array\n         */\n        newlyAddedColumns: [],\n\n        /**\n         * Contains the Post-Initialization Element.\n         * @private\n         * @property postInitElement\n         * @type Object\n         */\n        postInitElement: {},\n\n        /**\n         * Setter function for Trial-Level Data.\n         * @method setTrialData\n         * @param key {String} Key\n         * @param value {Value} Value\n         */\n        setTrialData: function(key, value) {\n            //Store value in trial cache\n            this.TDCache[key] = value;\n            if (this.BDCache.QRTLib_trialColumns[key] === undefined) {\n                //Add column to overall trial data\n                this.BDCache.QRTLib_trialColumns[key] = '';\n                this.newlyAddedColumns.push(key);\n            }\n        },\n\n        /**\n         * Gets the value of Trial-Level Data field 'key\n         * @method getTrialData\n         * @param key {String} Key\n         */\n        getTrialData: function(key) {\n            return this.TDCache[key];\n        },\n\n        /**\n         * Setter function for Block-Level Data.\n         * @method setBlockData\n         * @param key {String} Key\n         * @param value {Value} Value\n         */\n        setBlockData: function(key, value) {\n            this.BDCache[key] = value;\n        },\n\n\n        /**\n         * Gets the value of Block-Level Data field 'key\n         * @method getBlockData\n         * @param key {String} Key\n         */\n        getBlockData: function(key) {\n            return this.BDCache[key];\n        },\n\n\n\n\n        /**\n         * Stringify the Block Data and store it in the Embedded Data Field. This preserves the values stored on Block Level for use in later trials\n         * @method saveBlockData\n         * @param key {String} Key\n         */\n        saveBlockData: function() {\n            //Store blockData in ED so that we can use it next trial\n            QRTEController.storeBlockData(QRTE.BDCache);\n            Qualtrics.SurveyEngine.setEmbeddedData(QRTE.blockDataField, Object.toJSON(QRTE.BDCache));\n        },\n\n\n\n        /**\n         * Setter function for Survey-Level Data (Embedded Data).\n         * @method setSurveyData\n         * @param key {String} Key\n         * @param value {Value} Value\n         */\n        setSurveyData: function(key, value) {\n            this.SDCache[key] = value;\n            Qualtrics.SurveyEngine.setEmbeddedData(key, value);\n        },\n\n\n\n        /**\n         * Gets the value of Survey-Level Data (Embedded Data) 'key'\n         * @method getSurveyData\n         * @param key {String} Key\n         */\n\n        getSurveyData: function(key) {\n            if (this.SDCache[key] !== undefined) {\n                return this.SDCache[key];\n            }\n            //This only works if the Survey Data has been set during the same trial due to a bug in Qualtrics.\n            return Qualtrics.SurveyEngine.getEmbeddedData(key);\n        },\n\n        /**\n         * Sets a configuration for a question\n         * @method setConfig\n         * @param QID {String} The QRTE Question Id of the Question you want the configuration to apply to\n         * @param option {String} The type of configuration you want to set, Allowed options: 'cresp', 'allowable', 'duration', 'endaction', 'delay'. Refer to website for documentation on these configs\n         * @param value {String} The value the configuration needs to be set to. Differs per option.\n         */\n        setConfig: function(QID, option, value) {\n            var setterFunc;\n            if (typeof QID === 'string') {\n                setterFunc = function(QID, option, value) {\n                    this.setTrialData(QID + \"[\" + option + \"]\", value);\n                };\n            } else {\n                setterFunc = function(QID, option, value) {\n                    this.setTrialData(QID.questionId + \"[\" + option + \"]\", value);\n                    QID['_' + option] = value;\n                };\n\n            }\n\n            this._setConfig(QID, option, value, setterFunc);\n        },\n\n\n        /**\n         * Loads the configuration for a question.\n         * @private\n         * @method loadConfig\n         * @param question {Object} Question for which the configuration needs to be loaded.\n         */\n        loadConfig: function(question) {\n            if (this.idCache[question.questionId] !== undefined) {\n                question.QRTLib_configId = this.idCache[question.questionId];\n            } else {\n                question.QRTLib_configId = question.question;\n            }\n            question.duration = this.getDuration(question);\n            question.allowable = this.getAllowable(question);\n            question.cresp = this.getCResp(question);\n            question.offset = this.getOffset(question);\n            question.endAction = this.getEndAction(question);\n        },\n\n        /**\n         * Stores the accuracy of a trial\n         * @private\n         * @method saveAcc\n         * @param question {Object} Question for which accuracy needs to be stored\n         * @param acc {Integer} Accuracy of question\n         */\n\n        saveAcc: function(question, acc) {\n            if (acc === 0 || acc === 1) {\n                this.setTrialData(question.QRTLibId + \"[ACC]\", acc);\n                this.setSurveyData(\"ACC\", acc);\n            }\n        },\n\n\n\n        /**\n         * Check whether the given response was a correct response\n         * @method isCorrectResponse\n         * @param question {Object} Question for which correct response needs to be checked\n         * @param resp {String} Given response\n         */\n        isCorrectResponse: function(question, resp) {\n            return question.cresp.indexOf(resp) >= 0;\n        },\n\n        /**\n         * Check whether the given response was an allowable response\n         * @method isAllowableResponse\n         * @param question {Object} Question for which allowable response needs to be checked\n         * @param resp {String} Given response\n         */\n        isAllowableResponse: function(question, resp) {\n            return question.allowable.indexOf(resp) >= 0;\n        },\n\n\n\n        /**\n         * Check whether the given response was an allowable response\n         * @private\n         * @method keycode2string\n         * @param e {Object} KeyPress event from which to retrieve the response\n         */\n        keycode2string: function(e) {\n            return String.fromCharCode(e.charCode);\n        },\n\n        /** \n         * Wait for images to load before starting trial.\n         * @property waitForImageLoad\n         * @private\n         * @type Boolean\n         */\n\n        waitForImageLoad: true,\n\n        /** \n         * Trial Start waiting list - initialised with waiting for TrialStart\n         * @property loadWaitingList\n         * @private\n         * @type Array\n         */\n\n        loadWaitingList: [false],\n\n        /**\n         * Initializes the Engine, called at the start of the 'Init' question.\n         * @private\n         * @method initLib\n         * @param blockDataString {String} JSON string containing information saved for this block (block-level data)\n         * @param blockId {String} Id of the current block\n         * @param columns {String} JSON string containing information about the columns that have been defined in this block\n         * @param idData {String} JSON string containing information about the mapping of the QID to the name of the question\n         * @param exitQuestions {String} String containing the currently defined QuestionTags of the Exit questions\n         * @param exitItemTag {String} String containing the Tag of this block's Exit question.\n         */\n\n\n        initLib: function(blockDataString, blockId, columns, idData, exitQuestions, exitItemTag) {\n            //var blockDataString = Qualtrics.SurveyEngine.getEmbeddedData(QRTE.blockDataField),\n            //columns = Qualtrics.SurveyEngine.getEmbeddedData(QRTE.columnsField),\n            //idData = Qualtrics.SurveyEngine.getEmbeddedData(QRTE.idField);\n            var glue;\n            QRTE.fixSetEmbeddedDataBug();\n            //Initialise block Data\n            if (blockDataString === undefined || blockDataString === null || blockDataString === '') {\n                blockDataString = '{}';\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.blockDataField, blockDataString);\n            }\n\n            this.BDCache = QRTEController.loadBlockData(blockDataString);\n\n            if (this.BDCache.QRTLib_currentBlock !== blockId) {\n                //If this is a new block, initialise a new block\n                this.BDCache = {\n                    QRTLib_currentBlock: blockId,\n                    QRTLib_blockCounter: 1,\n                    QRTLib_trialColumns: {}\n                };\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.blockDataField, Object.toJSON(this.BDCache));\n                if (exitQuestions === null) {exitQuestions = '';}\n                glue = '';\n                if (exitQuestions !== '') {\n                    glue = ';';\n                }\n                //And update the exit questions\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.exitQuestions, exitQuestions + glue + exitItemTag);\n\n            }\n            QRTE.TDCache = Object.toJSON(QRTE.getBlockData('QRTLib_trialColumns')).evalJSON();\n            if (columns === undefined || columns === null || columns === '') {\n                columns = '{}';\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.columnsField, columns);\n            }\n            QRTE.SDCache[QRTE.columnsField] = columns.evalJSON();\n            if (idData === undefined || idData === null || idData === '') {\n                idData = '{}';\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.idField, idData);\n            }\n            QRTE.idCache = idData.evalJSON();\n        },\n\n        /**\n         * Init initializes the QRTEngine, expects are params object with possible fields defined with parameters.\n         * @method Init\n         * @param paramObj {Object} object containing parameters of Init function\n         *  @param paramObj.blockData {String} blockData string in json format (from embedded data)\n         *  @param paramObj.columnData {String} columnData string in json format (from embedded data)\n         *  @param paramObj.exitQuestions {String} exitQuestions string (from embedded data)\n         *  @param paramObj.exitItemTag {String} Tag of the Exit question of this block\n         *  @param paramObj.blockId {String} Identificaton of the block\n         *  @param [paramObj.onLoadFn] {Function} Function to be called when this Question is displayed\n         *  @param [paramObj.interTrialDelay] {Integer|Array} Specify millisecond delay between end of previous trial and beginning of new trial\n         *  @param [paramObj.preTrialDelay] {Integer|Array} Specify millisecond (ms) delay before the start of the first trial of the block. //NYI\n         *  @param [paramObj.initQuestionIndex] {Integer} Specify index of the Init question in the Question Block (defaults to 1)\n         *  @param [paramObj.waitForImages] {Boolean} Specify whether we should wait for images or not. Is on by default, but could be turned off if all images are pre-loaded in cache, or are very small in general.\n         */\n        Init: function(paramObj) {\n            var validationArray, qArray, initIndex;\n            //init the library\n            QRTE.init();\n\n            //set the initIndex (if the Init question is not the first question of the block)\n            QRTE.initIndex = paramObj.initQuestionIndex - 1 || 0;\n\n\n            validationArray = [{\n                name: 'blockData',\n                type: ['JSON', 'Empty'],\n                required: true\n            }, {\n                name: 'columnData',\n                type: ['JSON', 'Empty'],\n                required: true\n            }, {\n                name: 'idData',\n                type: ['JSON', 'Empty'],\n                required: true\n            }, {\n                name: 'blockId',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'onLoadFn',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'interTrialDelay',\n                type: ['Integer', 'Array'],\n                required: false\n            }, {\n                name: 'exitQuestions',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'exitItemTag',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'waitForImages',\n                type: ['Boolean'],\n                required: false\n            }];\n\n            //Validate Parameter Object, outputs stuff to console\n            QRTE.validateParams(paramObj, validationArray, 'Init');\n\n\n            //Initialize the library itself (necessary for each trial)\n            QRTE.initLib(paramObj.blockData, paramObj.blockId, paramObj.columnData, paramObj.idData, paramObj.exitQuestions, paramObj.exitItemTag);\n\n\n            if (paramObj.waitForImages !== undefined) {\n                QRTE.waitForImageLoad = paramObj.waitForImages;\n            }\n            //calculate server communication delay\n            QRTE.setTrialData('InitPre[OnsetTime]', QRTE.getBlockData('QRTLib_previousStorageDone'));\n\n            QRTE.setTrialData('InitPre[OffsetTime]', window.requestAnimationFrame.now());\n            QRTE.setTrialData('InitPre[CalculatedDuration]', QRTE.getTrialData('InitPre[OffsetTime]') - QRTE.getTrialData('InitPre[OnsetTime]'));\n            QRTE.setTrialData('Init[OnsetTime]', window.requestAnimationFrame.now());\n\n\n\n            Qualtrics.SurveyEngine.addOnload(function() {\n                this.qHTML = document.getElementById(this.questionId);\n                this.QRTLib_isActive = false;\n                this.hideChoices();\n                this.proceed = QRTE.proceed;\n                this.QRTLibId = 'InitPost';\n\n                paramObj.onLoadFn.apply(this);\n                var QuestionStackElement = {\n                    questionElement: this,\n                    onShowFunc: function() {},\n                    type: 'Stimulus',\n                    loadConfig: true,\n                    id: 'InitPost',\n                    conditional: function() {\n                        return true;\n                    },\n                    proceedOnHide: true\n\n                };\n                QRTE.setConfig(QuestionStackElement.id, 'duration', 0);\n                QRTE.postInitElement = QuestionStackElement;\n                QRTE.questionQueue.push(QuestionStackElement);\n            });\n\n            if (paramObj.interTrialDelay instanceof Array) {\n                paramObj.interTrialDelay = paramObj.interTrialDelay[Math.floor(Math.random() * paramObj.interTrialDelay.length)];\n            }\n            QRTE.setTrialData(paramObj.blockId + '[InterTrialDelay]', paramObj.interTrialDelay);\n            if (paramObj.interTrialDelay > 0) {\n                QRTE.setBlockData('QRTLib_intraTrialDelay', paramObj.interTrialDelay);\n            } else {\n                QRTE.setBlockData('QRTLib_intraTrialDelay', -1);\n            }\n        },\n\n        /**\n         * Create a Stimulus question\n         * @method Stimulus\n         * @param paramObj {Object}\n         *  @param paramObj.id {String} Id of the Question\n         *  @param paramObj.onShowFn {Function} Function to be called upon showing the question (not the same as upon loading)\n         *  @param [paramObj.conditional] {Function} Function to be called with which to decide whether to present this question or not, should return a boolean.\n         *  @param [paramObj.loadConfig] {Boolean} Load predefined config for this question (defaults to true)\n         *  @param [paramObj.stimContinue] {Boolean} Continue looking for stimuli after having seen this one, only if set to true (defaults to false)\n         *  @param [paramObj.onKeyPress] {Function} Function to be called upon receiving a key press while this Question is active (called next to onAllowableKey or onCorrectKey)\n         *  @param [paramObj.onAllowableKey] {Function} Function to be called upon receiving a key press on a key defined as 'allowable' \n         *  @param [paramObj.onCorrectKey] {Function} Function to be called upon receiving a key press on a key defined as 'correct'\n         *  @param [paramObj.onIncorrectKey] {Function} Function to be called upon receiving an allowable key that is not defined as correct (only if correct responses are defined)\n         *  @param [paramObj.proceedOnHide] {Boolean} Set whether all currently displayed elements should be removed on hide, or if only this should be removed from display (Defaults to True). This allows the user to decouple presentation of a stimulus from proceeding of a slide.\n         *  @param [paramObj.onHideFn] {Function} Function to be called upon Stimulus being hidden\n         *  @param [paramObj.duringDisplayFn] {Function} Function to be called during each frame that the Stimulus is being displayed\n         \n         */\n        Stimulus: function(paramObj) {\n            var validationArray = [{\n                name: 'id',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'onShowFn',\n                type: ['Function'],\n                required: true\n            }, {\n                name: 'conditional',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'loadConfig',\n                type: ['Boolean'],\n                required: false\n            }, {\n                name: 'duringDisplayFn',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'continue',\n                type: ['Boolean'],\n                required: false\n            }, {\n                name: 'onAllowableKey',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'onCorrectKey',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'onKeyPress',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'onIncorrectKey',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'proceedOnHide',\n                type: ['Boolean'],\n                required: false\n            }, {\n                name: 'onHideFn',\n                type: ['Function'],\n                required: false\n            }];\n\n            //Validate Parameter Object, outputs stuff to console\n            QRTE.validateParams(paramObj, validationArray, 'Stimulus');\n\n\n            if (paramObj.conditional === undefined) {\n                paramObj.conditional = function() {\n                    return true;\n                };\n            }\n            if (paramObj.loadConfig === undefined) {\n                paramObj.loadConfig = true;\n            }\n\n            if (paramObj.stimContinue === undefined) {\n                paramObj.stimContinue = false;\n            }\n\n            if (paramObj.proceedOnHide === undefined) {\n                paramObj.proceedOnHide = true;\n            }\n            Qualtrics.SurveyEngine.addOnload(function() {\n                this.QRTLib_isActive = false;\n                this.proceed = QRTE.proceed;\n                this.QRTLibId = paramObj.id;\n                var QuestionStackElement = {\n                    questionElement: this,\n                    onShowFunc: paramObj.onShowFn,\n                    duringDisplayFn: paramObj.duringDisplayFn,\n                    onHideFn: paramObj.onHideFn,\n                    type: 'Stimulus',\n                    loadConfig: paramObj.loadConfig,\n                    id: paramObj.id,\n                    conditional: paramObj.conditional,\n                    stimContinue: paramObj.stimContinue,\n                    onAllowableKey: paramObj.onAllowableKey,\n                    onCorrectKey: paramObj.onCorrectKey,\n                    onKeyPress: paramObj.onKeyPress,\n                    onIncorrectKey: paramObj.onIncorrectKey,\n                    proceedOnHide: paramObj.proceedOnHide\n                };\n                QRTE.questionQueue.push(QuestionStackElement);\n            });\n        },\n\n        /**\n         * Exit denotes the end of the block. Important for the initialization phase and the exit phase.\n         * Make the question a Form question with precisely 2 answer fields (more is unnecessary, those will get ignored)\n         * @method Exit\n         */\n        Exit: function() {\n\n\n            qArray = $('Questions').getElementsByClassName('QuestionOuter');\n            for (var i = 0; i < qArray.length && i < QRTE.initIndex + 1; i += 1) {\n                qArray[i].style.display = 'block';\n            }\n            Qualtrics.SurveyEngine.addOnload(function() {\n                //Hide all choice\n                this.hideChoices();\n                //display the question\n                //this.questionContainer.style.display = 'none';\n                var QuestionStackElement, onShowFn;\n                onShowFn = function() {\n\n                    //Create and/or store standard information about the trial\n                    var blockId = QRTE.getBlockData('QRTLib_currentBlock'),\n                        tempTD = {},\n                        key,\n                        i;\n\n                    QRTE.setBlockData('QRTLib_previousEndTime', window.requestAnimationFrame.now());\n                    QRTE.setTrialData(blockId + '[TrialNr]', QRTE.getBlockData('QRTLib_blockCounter'));\n                    QRTE.setTrialData(blockId + '[RefreshPeriod]', QRTE.refreshPeriod);\n                    QRTE.setTrialData('BlockId', blockId);\n                    QRTE.setTrialData('EngineType', window.requestAnimationFrame.method);\n                    QRTE.setTrialData('Exit[OnsetTime]', window.requestAnimationFrame.now());\n                    QRTE.setTrialData('QRTEngine[Version]', QRTE.version);\n\n                    //CHECK IF ATLEAST TWO FORM FIELDS HAVE BEEN DEFINED\n                    this.setChoiceValue(2, 'testtest');\n                    if (this.getChoiceValue(2) !== 'testtest') {\n                        //alert('You need to define two answer form fields in the Exit question!!');\n                    }\n\n                    for (key in QRTE.TDCache) {\n                        if (QRTE.TDCache.hasOwnProperty(key) && key !== '') {\n                            //Change QID thingies to entered ID's, also force every value to a string so that the Parser handles high numerical values correctly\n                            tempTD[QRTE.getOutputKey(key)] = String(QRTE.TDCache[key]);\n                        }\n                    }\n\n                    this.setChoiceValue(1, Object.toJSON(tempTD));\n                    this.setChoiceValue(2, blockId);\n                    if (QRTE.SDCache[QRTE.columnsField][blockId] === undefined) {\n                        QRTE.SDCache[QRTE.columnsField][blockId] = [];\n                    }\n                    for (i = 0; i < QRTE.newlyAddedColumns.length; i += 1) {\n                        QRTE.SDCache[QRTE.columnsField][blockId].push(QRTE.getOutputKey(QRTE.newlyAddedColumns[i]));\n                    }\n\n                    QRTE.setSurveyData(QRTE.columnsField, Object.toJSON(QRTE.SDCache[QRTE.columnsField]));\n                    QRTE.setBlockData('QRTLib_blockCounter', QRTE.getBlockData('QRTLib_blockCounter') + 1);\n                    QRTE.setBlockData('QRTLib_previousStorageDone', window.requestAnimationFrame.now());\n                    QRTE.saveBlockData();\n\n                    //If wanting to test, uncomment this line and comment the one after that to enforce manual nextbutton clicks\n                    //$('NextButton').style.display = 'block';\n                    //QRTE.submitPage();\n                    QRTEController.loadNextTrial();\n                };\n\n                QuestionStackElement = {\n                    questionElement: this,\n                    onShowFunc: onShowFn,\n                    type: 'Storage',\n                    loadConfig: true,\n                    conditional: function() {\n                        return true;\n                    }\n                };\n                QRTE.questionQueue.push(QuestionStackElement);\n\n                QRTE.startTrial(0);\n\n            });\n\n            QRTE.loadWaitingList = [false];\n            if (QRTE.waitForImageLoad === true) {\n                //set wait for image load queues.\n                var loadIndex = 1,\n                    images = $$('.QuestionOuter img'),\n                    i = 0;\n\n                var l = images.length;\n                for (; i < l; i += 1) {\n                    images[i].observe('load', function(e) {\n                        QRTE.startTrial(e.path[0].QRTELoadIndex);\n                    })\n                    images[i].QRTELoadIndex = i + 1;\n                    QRTE.loadWaitingList[i + 1] = false;\n                }\n\n            }\n\n        },\n\n        /**\n         * Remove the padding Qualtrics adds between Questions (causes question presentation to drift downwards if not called).\n         * DEPRECATED: Separators hidden through CSS now\n         * @method removeSeparators\n         * @private\n         */\n        removeSeparators: function() {\n            var questionElement = document.getElementById('Questions'),\n                index;\n            for (index = 0; index < questionElement.children.length; index += 1) {\n                if (questionElement.children[index].className === \"Separator\") {\n                    questionElement.children[index].parentNode.removeChild(questionElement.children[index]);\n                }\n            }\n        },\n        /**\n         * Notifies the engine the first trial is ready to be started. Called at the end of the 'exit' question\n         * @private\n         * @method startTrial\n         */\n        startTrial: function(startId) {\n            var duringDisplayFn, onHideFn, onDisplayFn, serverCommDelay, remainingDelay;\n            //All questions have been hidden, so display the parent block again\n            //$('Questions').style.display = 'block';\n\n            QRTE.loadWaitingList[startId] = true;\n            if (!QRTE.loadWaitingList.every()) {\n                QRTE.log('Process ' + startId + 'finished, waiting for other processes to finish')\n                return;\n            }\n\n            //Save the absolute time of when onLoad part of library was finished\n            serverCommDelay = window.requestAnimationFrame.now() - QRTE.getBlockData('QRTLib_previousEndTime'); //Calculate the remaining time based on the lib initialization + server delay times\n            remainingDelay = QRTE.getBlockData('QRTLib_intraTrialDelay') - serverCommDelay;\n\n\n            if (isNaN(remainingDelay)) {\n                remainingDelay = QRTE.getBlockData('QRTLib_intraTrialDelay') * 3;\n                //If this init call is the first one of the block (first trial), calculate the estimated refreshdelay during the pre-trial interval\n                onDisplayFn = function(ele, time) {\n                    QRTE.setTrialData('Init[OffsetTime]', ele.displayOnsetTime);\n                    QRTE.setTrialData('Init[CalculatedDuration]', ele.displayOnsetTime - QRTE.getTrialData('Init[OnsetTime]'));\n                    QRTE.refreshPeriodEstimationStack = [];\n                };\n                duringDisplayFn = function(ele, time) {\n                    //Get current time, required for \n                    QRTE.refreshPeriodEstimationStack.push(time);\n                };\n                onHideFn = function(ele, timestamp) {\n                    var diffs = [];\n\n                    for (i = 1; i < QRTE.refreshPeriodEstimationStack.length; i += 1) {\n                        diffs[i - 1] = QRTE.refreshPeriodEstimationStack[i] - QRTE.refreshPeriodEstimationStack[i - 1];\n                    }\n                    QRTE.refreshPeriod = QRTE.median(diffs);\n                    QRTE.log('Estimated refresh delay = ' + QRTE.refreshPeriod);\n                    QRTE.setBlockData('QRTE_refreshPeriod', QRTE.refreshPeriod);\n                    QRTE.referenceTime = timestamp;\n                    QRTE.framesSinceReference = 0;\n                };\n            } else {\n                onDisplayFn = function(ele, time) {\n                    QRTE.setTrialData('Init[OffsetTime]', ele.displayOnsetTime);\n                    QRTE.setTrialData('Init[CalculatedDuration]', ele.displayOnsetTime - QRTE.getTrialData('Init[OnsetTime]'));\n                };\n\n                QRTE.refreshPeriod = QRTE.getBlockData('QRTE_refreshPeriod');\n            }\n\n            //QRTE.setTrialData('ITI[Duration]', (remainingDelay > 0) ? remainingDelay : 0);\n            QRTE.initTime = window.requestAnimationFrame.now();\n\n            QRTE.postInitElement.onHideFn = onHideFn;\n            QRTE.postInitElement.onDisplayFn = onDisplayFn;\n            QRTE.postInitElement.duringDisplayFn = duringDisplayFn;\n            QRTE.setConfig('InitPost', 'duration', (remainingDelay > 0) ? remainingDelay : 0);\n            //UNCOMMENT\n            //QRTE.setConfig('InitPost', 'duration', (remainingDelay > 0) ? remainingDelay : Infinity);\n            QRTE.inited = true;\n\n            //Set initial trial data related to loading of this trial\n            QRTE.setTrialData('InitServerComm[Onset]', QRTE.getBlockData('ServerCommOnset'));\n            QRTE.setTrialData('InitServerComm[Offset]', QRTE.getBlockData('ServerCommOffset'));\n            QRTE.setTrialData('InitServerComm[CalculatedDuration]', QRTE.getBlockData('ServerCommOffset') - QRTE.getBlockData('ServerCommOnset'));\n\n            //<Load next trial here>\n            var currentLoops = '${lm://CurrentLoopNumber}',\n                totalLoops = '${lm://TotalLoops}';\n            //Check if last trial, currentloops === totalLoops;\n            QRTEController.requestNextTrial(currentLoops !== '' && currentLoops === totalLoops);\n\n            QRTE.proceed();\n        },\n\n\n\n        proceed: function() {\n            QRTE.log(\"proceed called after \" + window.requestAnimationFrame.now() - QRTE.initTime);\n            QRTE.hideAllElements();\n        },\n\n        proceedPage: function() {\n            var currentQ;\n            QRTE.log(\"Proceeding page..\");\n            while (QRTE.currentPageQuestions.length > 0) {\n                currentQ = QRTE.currentPageQuestions.shift();\n\n                //Disable\n                currentQ.questionElement.QRTLib_isActive = false;\n            }\n\n\n            //Go to next question\n            QRTE.showNextPage();\n        },\n\n        disableQuestion: function(disableQ) {},\n\n        /**\n         * Determine and show the next page/slide\n         * @private\n         * @method showNextPage\n         */\n        showNextPage: function() {\n            var continueSearch = true,\n                shownQ = false,\n                nextQ,\n                shown;\n            while (continueSearch === true) {\n                continueSearch = false;\n                nextQ = QRTE.questionQueue.shift();\n                if (nextQ !== undefined && (nextQ.type === 'Stimulus' || nextQ.type === 'Storage')) {\n                    QRTE.currentPageQuestions.push(nextQ);\n                    shown = QRTE.showStimulusQuestion.apply(nextQ.questionElement, [nextQ]);\n\n                    if (nextQ.stimContinue) {\n                        continueSearch = true;\n                        if (shown === true) {\n                            shownQ = true;\n                        }\n                    }\n                    QRTE.log('shown ' + nextQ.id + ': ' + shown);\n                    QRTE.log('continue ' + nextQ.id + ': ' + continueSearch);\n                    if (shown === false && shownQ === false) {\n                        continueSearch = true;\n                    }\n                }\n            }\n\n        },\n\n        /**\n         * Show Question\n         * Handles the activation of that question, which includes:\n         * The loading of the configuration (duration, allowable keys etc).\n         * Sets the event handler to respond to any key presses during the event.\n         * @private\n         * @method showStimulusQuestion\n         * @param question {Object} question to be shown.\n         *  @param id {String} Id of question.\n         *  @param onShowFunc {Function} Function to be called when showing question\n         *  @param loadConfig {Boolean} If true, config is loaded from the current block data (which has been defined elsewhere)\n         *  @param questionElement {Object} This Qualtrics question element\n         *  @param duringDisplayFn {Function} Function to be called each frame that the question is presented\n         */\n        showStimulusQuestion: function(question) {\n            //Save the loading start time\n            //QRTE.setTrialData(question.questionElement.QRTLibId + '[LoadStartTime]', window.requestAnimationFrame.now());\n            //Set mapping of the QID -> QRTE Id\n            QRTE.setId(this, question.id);\n\n            //Initialize variables\n            var stimulusShown = false,\n                questionScope = this,\n                dispEle;\n            QRTE.log(question);\n\n            //Check whether question should be shown or not, if not skip to the next question (implicitly)\n            if (question.conditional() === true) {\n                this.QRTLib_isActive = true;\n\n\n                if (question.loadConfig === true) {\n                    //Load the Configuration of the Question, important!\n                    QRTE.loadConfig(this);\n                }\n\n                //Check if KeyPress listener is required (one or more of the following fields are defined: onKeyPress, onCorrectKey or onAllowableKey)\n                //If so, add keypress listener.\n                if (question.onKeyPress !== undefined || question.questionElement.allowable !== '' || question.questionElement.cresp !== '') {\n                    //Initialize the fields used for storing data about RT timing.\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[RTTime]', '');\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[RT]', '');\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[RESP]', '');\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[ACC]', 0);\n\n                    //Add the key listener\n                    QRTE.addKeyListener(function(e) {\n\n                        //Get the Key of the response\n                        var RT, RESP = QRTE.keycode2string(e),\n                            RTTime = window.requestAnimationFrame.now();\n                        RT = RTTime - QRTE.getTrialData(question.questionElement.QRTLibId + '[OnsetTime]');\n\n                        //Store the Time of the Key Press and calculate the RT and ACC if correct\n\n                        if ((QRTE.isAllowableResponse(question.questionElement, RESP) || QRTE.isCorrectResponse(question.questionElement, RESP)) && QRTE.getTrialData(question.questionElement.QRTLibId + '[RTTime]') === '') {\n                            QRTE.setTrialData(question.questionElement.QRTLibId + '[RTTime]', RTTime);\n                            QRTE.setTrialData(question.questionElement.QRTLibId + '[RT]', RT);\n                            QRTE.setTrialData(question.questionElement.QRTLibId + '[RESP]', RESP);\n                            if (QRTE.isCorrectResponse(question.questionElement, RESP)) {\n                                QRTE.saveAcc(question.questionElement, 1);\n                            } else {\n                                QRTE.saveAcc(question.questionElement, 0);\n                            }\n                        }\n\n                        //Store the RT and the Response\n\n                        //Set Handling Key Press to true, this lets the engine know that a keypress is currently being handled. Necessary when there is a timer (response deadline)\n                        question.handlingKeyPress = true;\n\n                        if (question.onCorrectKey !== undefined && QRTE.isCorrectResponse(question.questionElement, RESP)) {\n                            question.onCorrectKey.apply(question.questionElement, [e, RESP]);\n                        } else if (question.onIncorrectKey !== undefined && QRTE.isAllowableResponse(question.questionElement, RESP)) {\n                            question.onIncorrectKey.apply(question.questionElement, [e, RESP]);\n                        }\n\n                        if (question.onAllowableKey !== undefined && QRTE.isAllowableResponse(question.questionElement, RESP)) {\n                            question.onAllowableKey.apply(question.questionElement, [e, RESP]);\n                        }\n\n                        if (question.onKeyPress !== undefined) {\n                            question.onKeyPress.apply(question.questionElement, [e, RESP]);\n                        }\n\n                        if (question.questionElement.endAction === 'TERMINATE') {\n                            //Proceed to the next Question Page if the response is allowable\n                            if (QRTE.isAllowableResponse(question.questionElement, RESP) && question.questionElement.QRTLib_isActive === true) {\n                                question.questionElement.proceed();\n                            }\n                        }\n                        question.handlingKeyPress = false;\n\n                    }, this);\n                }\n\n                //Build the display Element. Stimuli Questions have to take into account the possibility of being associated with a key press. \n                //OnDisplayFn therefore logs the displayOnsetTime, so that the RT can be calculated.\n                dispEle = {\n                    el: this.questionContainer,\n                    duration: this.duration,\n                    delay: this.offset,\n                    duringDisplayFn: question.duringDisplayFn,\n                    onDisplayFn: function(displayEl, timestamp) {\n                        if (question.onDisplayFn !== undefined) {\n                            question.onDisplayFn(displayEl, timestamp);\n                        }\n                        QRTE.setTrialData(questionScope.QRTLibId + '[OnsetTime]', displayEl.displayOnsetTime);\n                    },\n                    proceedOnHide: question.proceedOnHide,\n                    id: question.id\n                };\n\n                //Set the OnHide Function\n                dispEle.onHideFn = function(displayEl, timestamp) {\n                    if (question.onHideFn !== undefined) {\n                        question.onHideFn(displayEl, timestamp);\n                    }\n                    QRTE.setTrialData(questionScope.QRTLibId + '[OffsetTime]', displayEl.displayOffsetTime);\n                    QRTE.setTrialData(questionScope.QRTLibId + '[CalculatedDuration]', displayEl.displayDuration);\n                };\n\n\n                this.QRTLib_timer = QRTE.displayElement(dispEle);\n\n                question.onShowFunc.apply(this);\n\n                stimulusShown = true;\n            }\n\n            //QRTE.setTrialData(question.questionElement.QRTLibId + '[LoadEndTime]', window.requestAnimationFrame.now());\n            return stimulusShown;\n        },\n\n        setId: function(question, desc) {\n\n            this.idCache[question.questionId] = desc;\n            question.qId = desc;\n\n            Qualtrics.SurveyEngine.setEmbeddedData(QRTE.idField, Object.toJSON(this.idCache));\n        },\n\n        getOutputKey: function(key) {\n            var oldKey;\n            for (oldKey in this.idCache) {\n                if (this.idCache.hasOwnProperty(oldKey) && oldKey === key.substring(0, oldKey.length)) {\n\n                    return QRTE.getBlockData('QRTLib_currentBlock') + this.idCache[oldKey] + key.substring(oldKey.length, key.length);\n                }\n            }\n            return key;\n        },\n\n\n        OnKeyPress: function(fn, qScope) {\n\n            qScope = qScope || window;\n\n            var keyFn = function(e) {\n                QRTE.setTrialData(qScope.QRTLibId + '[RTTime]', window.requestAnimationFrame.now());\n                var RT = QRTE.getTrialData(qScope.QRTLibId + '[RTTime]') - QRTE.getTrialData(qScope.QRTLibId + '[OnsetTime]');\n                QRTE.setTrialData(qScope.QRTLibId + '[RT]', RT);\n                QRTE.setTrialData(qScope.QRTLibId + '[RESP]', QRTE.keycode2string(e));\n                QRTE.log(qScope);\n                fn.apply(qScope, [e]);\n            }\n\n            QRTE.addKeyListener(keyFn, qScope);\n        },\n\n        addKeyListener: function(fn, listenerScope) {\n            Event.observe(document, 'keypress', function(e) {\n                if (listenerScope.QRTLib_isActive === true) {\n                    fn.apply(listenerScope, [e]);\n                }\n            });\n        },\n\n        /*  \n         **************Methods below this line are support methods*******************\n         */\n\n        hideQuestions: function() {\n            qArray = $('Questions').getElementsByClassName('QuestionOuter');\n            for (var i = 0; i < qArray.length; i += 1) {\n                qArray[i].style.display = 'none';\n            }\n        },\n\n        unhideQuestions: function() {\n            //Redisplay outer questions\n            qArray = $('Questions').getElementsByClassName('QuestionOuter');\n            for (var i = 0; i < qArray.length; i += 1) {\n                qArray[i].style.display = 'block';\n            }\n            //Redisplay separators\n            qArray = $('Questions').getElementsByClassName('Separator');\n            for (var i = 0; i < qArray.length; i += 1) {\n                qArray[i].style.display = 'block';\n            }\n\n\n        },\n\n        _handleKeyPressEvent: function() {\n\n        },\n\n        _setConfig: function(QID, option, value, setterFunc) {\n            var qidString = QID;\n            if (typeof QID !== 'string') {\n                qidString = QID.questionId;\n            }\n            option = option.toLowerCase();\n\n            switch (option) {\n                case 'duration':\n                    if (value instanceof Array) {\n                        value = value[Math.floor(Math.random() * value.length)];\n                    }\n                    setterFunc.apply(this, [qidString, 'Duration', value]);\n                    break;\n                case 'allowable':\n                    setterFunc.apply(this, [qidString, 'Allowable', value]);\n                    break;\n                case 'cresp':\n                    setterFunc.apply(this, [qidString, 'CRESP', value]);\n                    break;\n                case 'delay':\n                    setterFunc.apply(this, [qidString, 'Offset', value]);\n                    break;\n                case 'endaction':\n                    setterFunc.apply(this, [qidString, 'EndAction', value]);\n                    break;\n                default:\n                    QRTE.log('No such configuration: ' + option);\n                    break;\n            }\n        },\n        getDuration: function(question) {\n            var duration = Infinity,\n                edDuration = this.getTrialData(question.QRTLib_configId + '[Duration]');\n            if (edDuration !== undefined && edDuration !== '' && !isNaN(edDuration)) {\n                duration = edDuration;\n            }\n            if (question._Duration !== undefined && question._Duration !== '' && !isNaN(question._Duration)) {\n                duration = question._Duration;\n            }\n\n            return duration;\n        },\n        getAllowable: function(question) {\n            var allowable = \"\",\n                edAllowable = this.getTrialData(question.QRTLib_configId + '[Allowable]');\n            if (edAllowable !== undefined) {\n                allowable = edAllowable;\n            }\n            if (question._Allowable !== undefined) {\n                allowable = question._Allowable;\n            }\n\n            if (allowable === '{ANY}') {\n                allowable = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890-=[]\\\\;',./`\";\n            }\n            //allowable = allowable.toUpperCase();\n            return allowable;\n        },\n        getCResp: function(question) {\n            var cresp = '',\n                edcresp = this.getTrialData(question.QRTLib_configId + '[CRESP]');\n            if (edcresp !== undefined) {\n                cresp = edcresp;\n            }\n            if (question._cresp !== undefined) {\n                cresp = question._CRESP;\n            }\n\n            if (cresp === '{ANY}') {\n                cresp = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890-=[]\\\\;',./`\";\n            }\n            //cresp = cresp.toUpperCase();\n\n            return cresp;\n        },\n\n        getOffset: function(question) {\n            var offset = 0,\n                edOffset = this.getTrialData(question.QRTLib_configId + '[Offset]');\n            if (edOffset !== undefined && edOffset !== '' && !isNaN(edOffset)) {\n                offset = edOffset;\n            }\n            if (question._Offset !== undefined && question._Offset !== '' && !isNaN(question._Offset)) {\n                offset = question._Offset;\n            }\n\n            return offset;\n\n        },\n\n        getEndAction: function(question) {\n            var endAction = 'NONE',\n                edEndAction = this.getTrialData(question.QRTLib_configId + '[EndAction]');\n            if (edEndAction !== undefined && edEndAction !== '') {\n                endAction = edEndAction;\n            }\n            if (question._EndAction !== undefined && question._EndAction !== '') {\n                endAction = question._EndAction;\n            }\n\n            return endAction;\n\n        },\n        evaluateConditional: function(conditional) {\n            QRTE.log('Conditional: ', conditional);\n            return conditional === '' || conditional();\n        },\n        log: function() {\n            if (QRTE.debug === true) {\n                for (var i = 0; i < arguments.length; i += 1) {\n                    console.log(arguments[i]);\n                }\n            }\n        },\n\n        median: function(values) {\n\n            values.sort(function(a, b) {\n                return a - b;\n            });\n\n            var half = Math.floor(values.length / 2);\n\n            if (values.length % 2) return values[half];\n            else return (values[half - 1] + values[half]) / 2.0;\n        },\n\n        waitForKey: function(question, keys) {\n            Event.observe(document, 'keypress', function(e) {\n                var resp = QRTE.keycode2string(e);\n                if (keys.indexOf(resp) >= 0) {\n                    question.clickNextButton();\n                }\n            });\n        },\n\n        validateParams: function(paramObj, validationArray) {\n            var valObj, val, index, typeCheck = true,\n                indexType;\n            //Loop over validationArray to check whether parameters suffice\n            for (index = 0; index < validationArray.length; index += 1) {\n                valObj = validationArray[index];\n                if (paramObj[valObj.name] === undefined && valObj.required === true) {\n                    alert('Required parameter: ' + valObj.name + ' seems to be missing');\n                    QRTE.log('Required parameter: ' + valObj.name + ' seems to be missing');\n                    break;\n                }\n\n                val = paramObj[valObj.name];\n\n                //Loop over type checkers\n                for (indexType = 0; indexType < valObj.type.length; indexType += 1) {\n                    typeCheck = QRTE.validateType(val, valObj.type[indexType]);\n                    if (typeCheck === true) {\n                        break;\n                    }\n                }\n                if (typeCheck === false && valObj.required === true) {\n                    alert('Parameter: ' + valObj.name + ' is of the wrong type, expected type: ' + valObj.type + ', type received: ' + (typeof val) + \"\\n\" + \"Please open the console for detailed error messages\");\n                    QRTE.log('Parameter: ' + valObj.name + ' is of the wrong type, expected type: ' + valObj.type + ', type received: ' + (typeof val));\n                    QRTE.log('Faulty parameter ' + valObj.name + ': ', val);\n                    QRTE.log('Proper functioning of QRTE is no longer guaranteed, please fix the above error');\n                }\n\n            }\n        },\n\n        validateType: function(val, type) {\n            switch (type) {\n                case 'JSON':\n                    return val.isJSON();\n                case 'String':\n                    return (typeof val === 'string' || val instanceof String);\n                case 'Number':\n                    return (!isNaN(parseFloat(val)) && isFinite(val));\n                case 'Array':\n                    return val instanceof Array;\n                case 'Object':\n                    return typeof val === 'object';\n                case 'Function':\n                    return typeof val === 'function';\n                case 'Boolean':\n                    return (val === true || val === false);\n                case 'Empty':\n                    return val === '';\n                default:\n                    return false;\n            }\n        },\n\n        fixSetEmbeddedDataBug: function() {\n            Qualtrics.SurveyEngine.setEmbeddedData = function(key, value) {\n                var fieldName = 'ED~' + key;\n                if ($(fieldName)) {\n                    $(fieldName).value = value;\n                } else {\n                    $('Header').appendChild(QBuilder('input', {\n                        type: 'hidden',\n                        id: fieldName,\n                        name: fieldName,\n                        value: value\n                    }));\n                    Qualtrics.SurveyEngine.setEmbeddedData(key, value);\n                }\n            }\n        },\n\n        //DisplayEngine part\n\n        //Since it's impossible to know when a screen refresh has happened, we assume that the first timestamp is the actual screen refresh.\n        //Based on the difference between the current timestamp Tn and the root timestamp Tn-1, we estimate the amount of frames that have passed since. \n        //Based on the amount of frames we estimate the previous screen refresh. Although not perfect, it's the best we can do.\n\n        refreshRate: 60, //hertz\n        refreshPeriod: 1000 / 60,\n        lastRefresh: 0,\n        currentRefresh: 0,\n        previousTimestamp: 0,\n        referenceTime: 0,\n        framesSinceReference: 0,\n        currentStack: [],\n        proceedOnFrameEnd: false,\n\n        init: function() {\n            window.requestAnimationFrame(QRTE.draw);\n        },\n\n        draw: function(timestamp) {\n            var curEle, newStack = [];\n            timestamp = window.requestAnimationFrame.now();\n\n\n            if (timestamp < 1e12) {\n                timestamp += window.performance.timing.navigationStart;\n            }\n\n            if (QRTE.referenceTime === 0) {\n                QRTE.referenceTime = timestamp;\n                QRTE.previousTimestamp = timestamp;\n                QRTE.framesSinceReference = 0;\n            } else {\n                //QRTE.framesSinceReference += QRTE.calcFrames(QRTE.referenceTime, timestamp);\n                QRTE.prevFrames = QRTE.framesSinceReference;\n                //frameDiff =  QRTE.calcFrames(QRTE.referenceTime, timestamp) - QRTE.prevFrames;\n                QRTE.framesSinceReference = QRTE.calcFrames(QRTE.referenceTime, timestamp);\n            }\n            QRTE.currentRefresh = (QRTE.framesSinceReference * QRTE.refreshPeriod) + QRTE.referenceTime;\n            QRTE.projectedRefresh = QRTE.currentRefresh + QRTE.refreshPeriod;\n            curEle = QRTE.currentStack.shift();\n\n            while (curEle) {\n                curEle.keep = true;\n\n                //Call duringDisplay callback function, with the current element and the timestamp as arguments.\n                if (curEle.shown === true && typeof curEle.duringDisplayFn === 'function') {\n                    curEle.duringDisplayFn(curEle, timestamp);\n                }\n\n                if (QRTE.proceedOnFrameEnd === true || curEle.hide === true || (curEle.shown === true && curEle.displayOnset !== undefined && (curEle.displayOnset + curEle.duration < QRTE.projectedRefresh))) {\n                    //If the next refresh makes it go beyond the duration, hide the element again!\n                    curEle = QRTE.hideSingleEle(curEle, timestamp);\n                } else if (curEle.shown === false && curEle.requestedAt + curEle.delay < QRTE.projectedRefresh) {\n                    curEle = QRTE.dispSingleEle(curEle, timestamp);\n                }\n\n                if (curEle.keep === false && curEle.proceedOnHide === true) {\n                    //Behold! We have found an element that commands us to proceed to the next page.\n                    QRTE.proceedOnFrameEnd = true;\n                    //Every element that has been processed so far needs to be re-processed (sadly), so that they properly hide.\n                    for (var ind = 0; ind < newStack.length; ind += 1) {\n                        if (newStack[ind].hide !== true) {\n                            newStack[ind].hide = true;\n                            QRTE.currentStack.push(newStack[ind]);\n                        }\n                    }\n                } else {\n                    //Push it to the newStack, for it to be processed next time.\n                    newStack.push(curEle);\n                }\n\n                curEle = QRTE.currentStack.shift();\n            }\n            QRTE.currentStack = newStack;\n            QRTE.lastRefresh = QRTE.currentRefresh;\n            QRTE.previousTimestamp = timestamp;\n            window.requestAnimationFrame(QRTE.draw);\n            if ((newStack.length === 0 || QRTE.proceedOnFrameEnd) && QRTE.inited === true) {\n                QRTE.proceedOnFrameEnd = false;\n                QRTE.proceedPage();\n            }\n\n\n        },\n\n        calcFrames: function(previous, current) {\n            var diff = current - previous,\n                frames = 0;\n\n            if (diff < QRTE.refreshPeriod) {\n                frames = 1;\n            } else {\n                frames = Math.floor(diff / QRTE.refreshPeriod);\n                if (diff % QRTE.refreshPeriod >= (QRTE.refreshPeriod * 0.9)) {\n                    frames += 1;\n                }\n            }\n\n            return frames;\n        },\n\n        /**\n         * Display an element for a specified duration with a specified delay. Vsyncs the display duration using requestAnimationFrame (if possible in the browser)\n         * and allows for high-precision control over its duration. Please start any custom attributes for the paramObj with the 'custom_' header, to avoid collisions.\n         * @private\n         * @method displayElement\n         * @param paramObj {Object}\n         *  @param el {Object} HTML element to be displayed\n         *  @param [onHideFn] {Function} Function to be called upon removing the element from display, is passed one argument containing all information about the display element.\n         *  @param [duration] {Number} Number of milliseconds (ms) the element should be displayed.\n         *  @param [delay] {Number} Number of milliseconds (ms) the Engine should wait before displaying the element.\n         *  @param [duringDisplayFn] {Function} Function to be called upon displaying the element for another screen refresh. Careful: Keep this function simple, could seriously hamper performance as it's called about every 16-17 ms.  is passed one argument containing all information about the display element.\n         *  @param [onDisplayfn] {Function} Function to be called upon starting to display the element. Is passed one argument containing all information about the display element.\n         */\n\n        //displayElement: function(el, callback, duration, offset, duringDisplaycb) {\n        displayElement: function(paramObj) {\n            var reqAt,\n                id = String(Math.random());\n            //QRTE.log(arguments);\n            if (paramObj.delay === undefined) {\n                paramObj.delay = 0;\n            }\n\n\n\n            if (paramObj.duration === undefined) {\n                paramObj = Infinity;\n            }\n\n            if (isNaN(QRTE.lastRefresh)) {\n                reqAt = window.requestAnimationFrame.now();\n            } else {\n                reqAt = QRTE.lastRefresh;\n            }\n            paramObj.userId = paramObj.id;\n            paramObj.id = id;\n            paramObj.shown = false;\n            paramObj.requestedAt = reqAt;\n            paramObj.hide = false;\n\n            QRTE.currentStack.push(paramObj);\n            if (paramObj.delay === 0) {\n                //This element needs to be displayed as soon as possible\n                QRTE.dispSingleEle(paramObj, QRTE.previousTimestamp);\n            }\n            QRTE.log('Added element to display stack:', paramObj);\n            //console.log('paramObj: ', paramObj.userId, ', duration: ', paramObj.duration);\n\n            return id;\n        },\n\n        hideElement: function(id) {\n            var found = false,\n                i;\n            for (i = 0; i < QRTE.currentStack.length; i += 1) {\n                if (QRTE.currentStack[i].id === id) {\n                    found = true;\n                    QRTE.currentStack[i].hide = true;\n                    this.log('Element to be hidden: ', QRTE.currentStack[i]);\n                }\n            }\n            return found;\n        },\n\n        hideAllElements: function() {\n            for (i = 0; i < QRTE.currentStack.length; i += 1) {\n                QRTE.currentStack[i].hide = true;\n            }\n            QRTE.proceedOnFrameEnd = true;\n        },\n\n        /**\n         * Hide a DrawEngine Element\n         * @private\n         * @method hideSingleEle\n         * @param curEle {Object}\n         */\n        hideSingleEle: function(curEle, timestamp) {\n            curEle.displayOffset = QRTE.projectedRefresh;\n            curEle.displayOffsetTime = window.requestAnimationFrame.now();\n            curEle.el.style.display = 'none';\n            curEle.keep = false;\n            curEle.hide = true;\n            //delete QRTE.currentStack[key];\n            curEle.displayDuration = curEle.displayOffsetTime - curEle.displayOnsetTime;\n            if (curEle.onHideFn !== undefined) {\n                curEle.onHideFn(curEle, timestamp);\n            }\n\n            return curEle;\n\n        },\n\n\n        /**\n         * Display a DrawEngine Element\n         * @private\n         * @method dispSingleEle\n         * @param curEle {Object}\n         */\n        dispSingleEle: function(curEle, timestamp) {\n            curEle.el.style.display = 'block';\n            curEle.displayOnset = QRTE.projectedRefresh;\n            curEle.displayOnsetTime = window.requestAnimationFrame.now();\n            curEle.shown = true;\n            if (curEle.onDisplayFn !== undefined) {\n                //Added try-catch block to catch the error that's causing the OnsetTime not to get saved.\n                try {\n                    curEle.onDisplayFn(curEle, timestamp);\n                } catch (e) {\n                    QRTE.setTrialData('Error[OnsetError]', JSON.stringify(e));\n                }\n            }\n            return curEle;\n        },\n\n        checkEngineCompatibility: function() {\n            return window.requestAnimationFrame.method === 'native-highres';\n        },\n    };\n\n    if (typeof QRTEController == 'undefined') {\n        //QRTE SurveySlider controller layer\n        //Takes care of progressing through the survey. Catches all qualtrics native ways of submitting the form and replaces that by\n        //its own asynchronous ajax stuff.\n        QRTEController = {\n\n\n            //This plug-in to QRTEngine has been developed under the name SurveySlider\n            // for general Qualtrics Surveys. It has been adapted to work with QRTEngine\n            nextTrialContainer: null,\n            nextTrialText: '',\n            currentForm: null,\n            previousForm: null,\n            handlingSubmit: false,\n            onSubmitStack: [],\n            inited: false,\n            childInputs: [],\n            loadUponCallback: false,\n            setEmbeddedData: function() {},\n            tempED: {},\n\n\n\n            //Initialize thecontroller\n            init: function() {\n                this.nextTrialContainer = new Element('div', {\n                    id: 'nextTrialContainer'\n                });\n                this.currentForm = $$('form')[0];\n\n                //Catch submits and change it with our own submit function (which does AJAX submissions)\n                //this.currentForm.observe('QRTE:submit', QRTE.handleSubmit);\n                this.currentElements = $$('.QuestionOuter');\n\n                //Initial SSload firing\n                Qualtrics.SurveyEngine.addOnload(function() {\n                    QRTEController.currentForm.fire('QRTE:load');\n                });\n                //Change SurveyEngine.OnLoad to trigger on SSload, rather than page load\n                Qualtrics.SurveyEngine.addOnload = function(f) {\n                        var questions = $$('.QuestionOuter'),\n                            currentCount = QRTEController.count(Qualtrics.SurveyEngine.QuestionInfo),\n                            id = questions[currentCount - 1].id;\n                        if ($('body') && $('body').hasClassName('EditSection')) return;\n                        try {\n                            var obj = new Qualtrics.SurveyEngine.QuestionData(id);\n                            obj.onload = f;\n\n                            QRTEController.currentForm.observe('QRTE:load', obj.onload.bind(obj));\n                            //Event.observe(this.currentForm, 'SSload', obj.onload.bind(obj));\n                        } catch (e) {\n                            console.error('SE API Error: ' + e);\n                        }\n                    }\n                    //Set the Qualtrics setEmbeddedData to inside the QRTEController\n                QRTEController.setEmbeddedData = Qualtrics.SurveyEngine.setEmbeddedData;\n                Qualtrics.SurveyEngine.setEmbeddedData = function(key, value) {\n                    QRTEController.tempED[key] = value;\n                }\n                this.submitPage = this.requestNextTrial;\n                this.inited = true;\n            },\n\n            /**\n             * Requests the next trial from the Qualtrics server.\n             *\n             *\n             */\n            requestNextTrial: function(isLastTrial) {\n\n                //If this is the last trial of a block, DON'T request the next page, let qualtrics handle it themselves\n                if (this.handlingSubmit === false && isLastTrial === false) {\n                    //Load next trial means that current page is a trial and has been inited\n                    //Need to remove relevant input elements from current form before submitting\n                    //After that add them back\n                    this.handlingSubmit = true\n                    var childs = $$('form input[type=text]'),\n                        childInputs = [];\n                    //remove current input elements from the form\n                    for (var i = 0; i < childs.length; i += 1) {\n                        childInputs[i] = {\n                            ele: childs[i],\n                            parent: childs[i].up()\n                        };\n                        childs[i].remove();\n                    }\n                    //add previous input elements to form\n                    //Text inputs\n                    for (var i = 0; i < this.childInputs.length; i += 1) {\n                        this.childInputs[i].ele.style.display = 'none';\n                        this.currentForm.insert(this.childInputs[i].ele);\n                    }\n\n\n                    //And embedded data\n                    for (var key in this.tempED) {\n                        if (this.tempED.hasOwnProperty(key)) {\n                            QRTEController.setEmbeddedData(key, this.tempED[key]);\n                        }\n                    }\n                    //Reset stored embedded data\n                    this.tempED = {};\n                    //set new childs\n                    this.childInputs = childInputs;\n\n                    //Loop over submit stack, or callbacks that need to be finished before submitting\n                    for (var i = 0; i < QRTEController.onSubmitStack.length; i += 1) {\n                        QRTE.onSubmitStack[i]();\n                    }\n                    QRTEController.onSubmitStack = [];\n                    debugger;\n                    this.currentForm.request({\n                        onComplete: this.requestNextTrialCallback\n                    });\n\n                    //Set server comm onset for the next trial\n                    QRTE.setBlockData('ServerCommOnset', window.requestAnimationFrame.now());\n\n                    QRTEController.betweenSubmits = true;\n\n                    for (var i = 0; i < this.childInputs.length; i += 1) {\n                        this.childInputs[i].parent.insert(this.childInputs[i].ele);\n                        this.childInputs[i].ele.style.display = 'none';\n                    }\n                } else if (isLastTrial === true) {\n                    //Just add the previous trial's childInputs to the form \n                    for (var i = 0; i < this.childInputs.length; i += 1) {\n\n                        this.currentForm.insert(this.childInputs[i].ele);\n                        this.childInputs[i].ele.style.display = 'none';\n                    }\n\n                    this.loadNextTrial = function() {\n                        //Directly submitting the form doesn't seem to work? Let's do it through NextButton click\n                        $('NextButton').click();\n                    };\n                }\n            },\n\n            loadNextTrial: function() {\n                if (this.handlingSubmit === true) {\n                    //The submit still hasn't returned..\n                    this.loadUponCallback = true;\n                    return;\n\n                }\n                //Set handling submit to false (as page has been returned)\n                //Save the previous form\n                this.previousForm = this.currentForm;\n                //Reset the QuestionInfo object, this is for Qualtrics to correctly initiate its own page\n                Qualtrics.SurveyEngine.QuestionInfo = {}\n                    //Parse the HTML that was returned earlier and set it as the current trial container's contents\n                this.nextTrialContainer = jQuery(this.nextTrialContainer).html(this.nextTrialText)[0];\n                //Filter out the 'form' field, and append it back.\n                this.currentForm = jQuery(this.nextTrialContainer).find('form')[0];\n                jQuery(this.previousForm).replaceWith(jQuery(this.currentForm));\n\n                jQuery(this.currentForm).show();\n\n                if (this.currentForm.select('.END_OF_SURVEY').length === 0) {\n                    this.currentForm.fire('QRTE:load');\n                    this.submitPage = this.requestNextTrial;\n                } else {\n                    this.submitPage = this.currentForm.submit;\n                }\n\n            },\n\n            requestNextTrialCallback: function(e) {\n                QRTEController.nextTrialText = e.responseText;\n                QRTEController.handlingSubmit = false;\n                QRTE.setBlockData('ServerCommOffset', window.requestAnimationFrame.now());\n\n                if (QRTEController.loadUponCallback === true) {\n                    QRTEController.loadUponCallback = false;\n                    QRTEController.loadNextTrial();\n                }\n            },\n\n            submitPage: function() {\n                console.log('Not yet initialised');\n            },\n\n            count: function(obj) {\n                var count = 0;\n\n                for (var prop in obj) {\n                    if (obj.hasOwnProperty(prop))\n                        ++count;\n                }\n\n                return count;\n            },\n\n            BDCache: {},\n            storeBlockData: function(blockData) {\n                this.BDCache = blockData;\n            },\n\n            loadBlockData: function() {\n                return this.BDCache;\n            }\n        };\n\n        document.observe('dom:loaded', QRTEController.init.bind(QRTEController));\n\n\n        (function() {\n            var lastFrame, method, now, queue, requestAnimationFrame, timer, vendor, _i, _len, _ref, _ref1;\n            method = 'native';\n            now = Date.now || function() {\n                return new Date().getTime();\n            };\n            requestAnimationFrame = window.requestAnimationFrame;\n            _ref = ['webkit', 'moz', 'o', 'ms'];\n            for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n                vendor = _ref[_i];\n                if (!(requestAnimationFrame != null)) {\n                    requestAnimationFrame = window[vendor + \"RequestAnimationFrame\"];\n                }\n            }\n            if (!(requestAnimationFrame != null)) {\n                method = 'timer';\n                lastFrame = 0;\n                queue = timer = null;\n                requestAnimationFrame = function(callback) {\n                    var fire, nextFrame, time;\n                    if (queue != null) {\n                        queue.push(callback);\n                        return;\n                    }\n                    time = now();\n                    nextFrame = Math.max(0, 16.66 - (time - lastFrame));\n                    queue = [callback];\n                    lastFrame = time + nextFrame;\n                    fire = function() {\n                        var cb, q, _j, _len1;\n                        q = queue;\n                        queue = null;\n                        for (_j = 0, _len1 = q.length; _j < _len1; _j++) {\n                            cb = q[_j];\n                            cb(lastFrame);\n                        }\n                    };\n                    timer = setTimeout(fire, nextFrame);\n                };\n            }\n            requestAnimationFrame(function(time) {\n                var _ref1;\n                if ((((_ref1 = window.performance) != null ? _ref1.now : void 0) != null) && time < 1e12) {\n                    requestAnimationFrame.now = function() {\n                        return window.performance.now() + window.performance.timing.navigationStart;\n                    };\n                    requestAnimationFrame.method = 'native-highres';\n                } else {\n                    requestAnimationFrame.now = now;\n                }\n            });\n            requestAnimationFrame.now = ((_ref1 = window.performance) != null ? _ref1.now : void 0) != null ? (function() {\n                return window.performance.now() + window.performance.timing.navigationStart;\n            }) : now;\n            requestAnimationFrame.method = method;\n            window.requestAnimationFrame = requestAnimationFrame;\n        })();\n\n        function loadScript(url, callback) {\n\n            var script = document.createElement(\"script\")\n            script.type = \"text/javascript\";\n\n            if (script.readyState) { //IE\n                script.onreadystatechange = function() {\n                    if (script.readyState == \"loaded\" || script.readyState == \"complete\") {\n                        script.onreadystatechange = null;\n                        callback();\n                    }\n\n                };\n            } else { //Others\n                script.onload = function() {\n                    callback();\n                };\n            }\n\n            script.src = url;\n            document.getElementsByTagName(\"head\")[0].appendChild(script);\n        }\n\n        (function() {\n\n            //jQuery is only required for the Fixation flash fix. prototypejs is unable to efficiently replace elements\n            //and introduces a 10 ms delay between loading element and firing off the scripts. Unacceptable\n            //First time jQuery should be used is the second trial\n\n            loadScript(\"https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js\", function() {\n\n                $.noConflict();\n\n            });\n\n        })();\n\n        //If preview mode is run (PreviewBanner element exists, add a QRTEngine plug with id QRTEPlug)\n\n        if ($('PreviewBanner')) {\n            var plug, row, banner = $('PreviewBanner');\n            //Go down to the first table row inside that banner\n            row = banner.children[0].children[0].children[0];\n            //Insert new cell    \n            plug = row.insertCell(2);\n            plug.id = \"QRTEPlug\";\n            plug.width = \"20%\";\n            plug.innerHTML = 'This survey is proudly and successfully powered by <a href=\"http://qrtengine.com\" target=\"_blank\"><i><b>QRTEngine</b></i></a>';\n            plug.style.textAlign = \"center\";\n        }\n    }\n    .SkinInner > #Header {\n        padding: 0 !important;\n    }\n</style>","<script>\n    /** ==========================================================\n     * QRTEngine.js v16\n     * ==========================================================\n     * Copyright 2013-2014 Erwin Haasnoot\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     * http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     *\n     *\n     *\n     * ========================================================== */\n    /**\n     * Qualtrics Reaction Time Engine or QRTE is an add-on providing an interface\n     * for easy reaction time experiment creation in the Qualtrics survey research suite (tm).\n     * For instructions on how to use this add-on, see xxxx\n     *\n     * QRTE was developed by Erwin Haasnoot\n     * Email: erwinhaasnoot[at]gmail.com\n     * @class QRTE\n     *\n     */\n     \n    var QRTE = {\n        version: 'v16',\n        columnsField: 'QRTE_columns',\n        blockDataField: 'QRTE_blockData',\n        idField: 'QRTE_idData',\n        exitQuestions: 'QRTE_exitQuestions',\n        inited: false,\n        /**\n         * TDCache contains the Trial-Level Data in an Object. DO NOT directly manipulate this Object. It might cause inconsistencies in the data file and cause unexpected once parsed.\n         * Use QRTE.setTrialData and QRTE.getTrialData instead.\n         *\n         * @property TDCache\n         * @private\n         * @type Object\n         */\n        TDCache: {},\n\n        /**\n         * ColumnCache contains all the mappings from QID to Columns\n         * @property columnCache\n         * @private\n         * @type Object\n         */\n        columnCache: {},\n\n        /**\n         * BDCache contains the BlockLevel Data in an Object. Directly manipulating this Object might cause inconsistencies\n         * @property BDCache\n         * @private\n         * @type Object\n         */\n        BDCache: {},\n\n        /**\n         * SDCache is a cache for speeding up retrieval of Survey level Data,\n         * All Survey data is saved to both Embedded Data and Survey Data\n         * @private\n         * @property SDCache\n         * @type Object\n         */\n        SDCache: {},\n\n        /**\n         * idCache is a cache for quickly retrieving the Qualtrics QID to QRTLib Id mappings.\n         * Saved in the idData embedded data field after every trial.\n         * @private\n         * @property idCache\n         * @type Object\n         */\n        idCache: {},\n\n        /**\n         * questionQueue contains Objects (stimuli) that are waiting to be presented\n         * @private\n         * @property questionQueue\n         * @type Array\n         */\n        questionQueue: [],\n\n        /**\n         * currentPageQuestions contains the Question Objects that are\n         * displayed at any given time.\n         * @private\n         * @property currentPageQuestions\n         * @type Array\n         */\n        currentPageQuestions: [],\n\n        /**\n         * Contains Trial Data Columns that were 'newly' added in this trial run.\n         * @private\n         * @property newlyAddedColumns\n         * @type Array\n         */\n        newlyAddedColumns: [],\n\n        /**\n         * Contains the Post-Initialization Element.\n         * @private\n         * @property postInitElement\n         * @type Object\n         */\n        postInitElement: {},\n\n        /**\n         * Setter function for Trial-Level Data.\n         * @method setTrialData\n         * @param key {String} Key\n         * @param value {Value} Value\n         */\n        setTrialData: function(key, value) {\n            //Store value in trial cache\n            this.TDCache[key] = value;\n            if (this.BDCache.QRTLib_trialColumns[key] === undefined) {\n                //Add column to overall trial data\n                this.BDCache.QRTLib_trialColumns[key] = '';\n                this.newlyAddedColumns.push(key);\n            }\n        },\n\n        /**\n         * Gets the value of Trial-Level Data field 'key\n         * @method getTrialData\n         * @param key {String} Key\n         */\n        getTrialData: function(key) {\n            return this.TDCache[key];\n        },\n\n        /**\n         * Setter function for Block-Level Data.\n         * @method setBlockData\n         * @param key {String} Key\n         * @param value {Value} Value\n         */\n        setBlockData: function(key, value) {\n            this.BDCache[key] = value;\n        },\n\n\n        /**\n         * Gets the value of Block-Level Data field 'key\n         * @method getBlockData\n         * @param key {String} Key\n         */\n        getBlockData: function(key) {\n            return this.BDCache[key];\n        },\n\n\n\n\n        /**\n         * Stringify the Block Data and store it in the Embedded Data Field. This preserves the values stored on Block Level for use in later trials\n         * @method saveBlockData\n         * @param key {String} Key\n         */\n        saveBlockData: function() {\n            //Store blockData in ED so that we can use it next trial\n            QRTEController.storeBlockData(QRTE.BDCache);\n            Qualtrics.SurveyEngine.setEmbeddedData(QRTE.blockDataField, Object.toJSON(QRTE.BDCache));\n        },\n\n\n\n        /**\n         * Setter function for Survey-Level Data (Embedded Data).\n         * @method setSurveyData\n         * @param key {String} Key\n         * @param value {Value} Value\n         */\n        setSurveyData: function(key, value) {\n            this.SDCache[key] = value;\n            Qualtrics.SurveyEngine.setEmbeddedData(key, value);\n        },\n\n\n\n        /**\n         * Gets the value of Survey-Level Data (Embedded Data) 'key'\n         * @method getSurveyData\n         * @param key {String} Key\n         */\n\n        getSurveyData: function(key) {\n            if (this.SDCache[key] !== undefined) {\n                return this.SDCache[key];\n            }\n            //This only works if the Survey Data has been set during the same trial due to a bug in Qualtrics.\n            return Qualtrics.SurveyEngine.getEmbeddedData(key);\n        },\n\n        /**\n         * Sets a configuration for a question\n         * @method setConfig\n         * @param QID {String} The QRTE Question Id of the Question you want the configuration to apply to\n         * @param option {String} The type of configuration you want to set, Allowed options: 'cresp', 'allowable', 'duration', 'endaction', 'delay'. Refer to website for documentation on these configs\n         * @param value {String} The value the configuration needs to be set to. Differs per option.\n         */\n        setConfig: function(QID, option, value) {\n            var setterFunc;\n            if (typeof QID === 'string') {\n                setterFunc = function(QID, option, value) {\n                    this.setTrialData(QID + \"[\" + option + \"]\", value);\n                };\n            } else {\n                setterFunc = function(QID, option, value) {\n                    this.setTrialData(QID.questionId + \"[\" + option + \"]\", value);\n                    QID['_' + option] = value;\n                };\n\n            }\n\n            this._setConfig(QID, option, value, setterFunc);\n        },\n\n\n        /**\n         * Loads the configuration for a question.\n         * @private\n         * @method loadConfig\n         * @param question {Object} Question for which the configuration needs to be loaded.\n         */\n        loadConfig: function(question) {\n            if (this.idCache[question.questionId] !== undefined) {\n                question.QRTLib_configId = this.idCache[question.questionId];\n            } else {\n                question.QRTLib_configId = question.question;\n            }\n            question.duration = this.getDuration(question);\n            question.allowable = this.getAllowable(question);\n            question.cresp = this.getCResp(question);\n            question.offset = this.getOffset(question);\n            question.endAction = this.getEndAction(question);\n        },\n\n        /**\n         * Stores the accuracy of a trial\n         * @private\n         * @method saveAcc\n         * @param question {Object} Question for which accuracy needs to be stored\n         * @param acc {Integer} Accuracy of question\n         */\n\n        saveAcc: function(question, acc) {\n            if (acc === 0 || acc === 1) {\n                this.setTrialData(question.QRTLibId + \"[ACC]\", acc);\n                this.setSurveyData(\"ACC\", acc);\n            }\n        },\n\n\n\n        /**\n         * Check whether the given response was a correct response\n         * @method isCorrectResponse\n         * @param question {Object} Question for which correct response needs to be checked\n         * @param resp {String} Given response\n         */\n        isCorrectResponse: function(question, resp) {\n            return question.cresp.indexOf(resp) >= 0;\n        },\n\n        /**\n         * Check whether the given response was an allowable response\n         * @method isAllowableResponse\n         * @param question {Object} Question for which allowable response needs to be checked\n         * @param resp {String} Given response\n         */\n        isAllowableResponse: function(question, resp) {\n            return question.allowable.indexOf(resp) >= 0;\n        },\n\n\n\n        /**\n         * Check whether the given response was an allowable response\n         * @private\n         * @method keycode2string\n         * @param e {Object} KeyPress event from which to retrieve the response\n         */\n        keycode2string: function(e) {\n            return String.fromCharCode(e.charCode);\n        },\n\n        /** \n         * Wait for images to load before starting trial.\n         * @property waitForImageLoad\n         * @private\n         * @type Boolean\n         */\n\n        waitForImageLoad: true,\n\n        /** \n         * Trial Start waiting list - initialised with waiting for TrialStart\n         * @property loadWaitingList\n         * @private\n         * @type Array\n         */\n\n        loadWaitingList: [false],\n\n        /**\n         * Initializes the Engine, called at the start of the 'Init' question.\n         * @private\n         * @method initLib\n         * @param blockDataString {String} JSON string containing information saved for this block (block-level data)\n         * @param blockId {String} Id of the current block\n         * @param columns {String} JSON string containing information about the columns that have been defined in this block\n         * @param idData {String} JSON string containing information about the mapping of the QID to the name of the question\n         * @param exitQuestions {String} String containing the currently defined QuestionTags of the Exit questions\n         * @param exitItemTag {String} String containing the Tag of this block's Exit question.\n         */\n\n\n        initLib: function(blockDataString, blockId, columns, idData, exitQuestions, exitItemTag) {\n            //var blockDataString = Qualtrics.SurveyEngine.getEmbeddedData(QRTE.blockDataField),\n            //columns = Qualtrics.SurveyEngine.getEmbeddedData(QRTE.columnsField),\n            //idData = Qualtrics.SurveyEngine.getEmbeddedData(QRTE.idField);\n            var glue;\n            QRTE.fixSetEmbeddedDataBug();\n            //Initialise block Data\n            if (blockDataString === undefined || blockDataString === null || blockDataString === '') {\n                blockDataString = '{}';\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.blockDataField, blockDataString);\n            }\n\n            this.BDCache = QRTEController.loadBlockData(blockDataString);\n\n            if (this.BDCache.QRTLib_currentBlock !== blockId) {\n                //If this is a new block, initialise a new block\n                this.BDCache = {\n                    QRTLib_currentBlock: blockId,\n                    QRTLib_blockCounter: 1,\n                    QRTLib_trialColumns: {}\n                };\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.blockDataField, Object.toJSON(this.BDCache));\n                if (exitQuestions === null) {exitQuestions = '';}\n                glue = '';\n                if (exitQuestions !== '') {\n                    glue = ';';\n                }\n                //And update the exit questions\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.exitQuestions, exitQuestions + glue + exitItemTag);\n\n            }\n            QRTE.TDCache = Object.toJSON(QRTE.getBlockData('QRTLib_trialColumns')).evalJSON();\n            if (columns === undefined || columns === null || columns === '') {\n                columns = '{}';\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.columnsField, columns);\n            }\n            QRTE.SDCache[QRTE.columnsField] = columns.evalJSON();\n            if (idData === undefined || idData === null || idData === '') {\n                idData = '{}';\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.idField, idData);\n            }\n            QRTE.idCache = idData.evalJSON();\n        },\n\n        /**\n         * Init initializes the QRTEngine, expects are params object with possible fields defined with parameters.\n         * @method Init\n         * @param paramObj {Object} object containing parameters of Init function\n         *  @param paramObj.blockData {String} blockData string in json format (from embedded data)\n         *  @param paramObj.columnData {String} columnData string in json format (from embedded data)\n         *  @param paramObj.exitQuestions {String} exitQuestions string (from embedded data)\n         *  @param paramObj.exitItemTag {String} Tag of the Exit question of this block\n         *  @param paramObj.blockId {String} Identificaton of the block\n         *  @param [paramObj.onLoadFn] {Function} Function to be called when this Question is displayed\n         *  @param [paramObj.interTrialDelay] {Integer|Array} Specify millisecond delay between end of previous trial and beginning of new trial\n         *  @param [paramObj.preTrialDelay] {Integer|Array} Specify millisecond (ms) delay before the start of the first trial of the block. //NYI\n         *  @param [paramObj.initQuestionIndex] {Integer} Specify index of the Init question in the Question Block (defaults to 1)\n         *  @param [paramObj.waitForImages] {Boolean} Specify whether we should wait for images or not. Is on by default, but could be turned off if all images are pre-loaded in cache, or are very small in general.\n         */\n        Init: function(paramObj) {\n            var validationArray, qArray, initIndex;\n            //init the library\n            QRTE.init();\n\n            //set the initIndex (if the Init question is not the first question of the block)\n            QRTE.initIndex = paramObj.initQuestionIndex - 1 || 0;\n\n\n            validationArray = [{\n                name: 'blockData',\n                type: ['JSON', 'Empty'],\n                required: true\n            }, {\n                name: 'columnData',\n                type: ['JSON', 'Empty'],\n                required: true\n            }, {\n                name: 'idData',\n                type: ['JSON', 'Empty'],\n                required: true\n            }, {\n                name: 'blockId',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'onLoadFn',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'interTrialDelay',\n                type: ['Integer', 'Array'],\n                required: false\n            }, {\n                name: 'exitQuestions',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'exitItemTag',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'waitForImages',\n                type: ['Boolean'],\n                required: false\n            }];\n\n            //Validate Parameter Object, outputs stuff to console\n            QRTE.validateParams(paramObj, validationArray, 'Init');\n\n\n            //Initialize the library itself (necessary for each trial)\n            QRTE.initLib(paramObj.blockData, paramObj.blockId, paramObj.columnData, paramObj.idData, paramObj.exitQuestions, paramObj.exitItemTag);\n\n\n            if (paramObj.waitForImages !== undefined) {\n                QRTE.waitForImageLoad = paramObj.waitForImages;\n            }\n            //calculate server communication delay\n            QRTE.setTrialData('InitPre[OnsetTime]', QRTE.getBlockData('QRTLib_previousStorageDone'));\n\n            QRTE.setTrialData('InitPre[OffsetTime]', window.requestAnimationFrame.now());\n            QRTE.setTrialData('InitPre[CalculatedDuration]', QRTE.getTrialData('InitPre[OffsetTime]') - QRTE.getTrialData('InitPre[OnsetTime]'));\n            QRTE.setTrialData('Init[OnsetTime]', window.requestAnimationFrame.now());\n\n\n\n            Qualtrics.SurveyEngine.addOnload(function() {\n                this.qHTML = document.getElementById(this.questionId);\n                this.QRTLib_isActive = false;\n                this.hideChoices();\n                this.proceed = QRTE.proceed;\n                this.QRTLibId = 'InitPost';\n\n                paramObj.onLoadFn.apply(this);\n                var QuestionStackElement = {\n                    questionElement: this,\n                    onShowFunc: function() {},\n                    type: 'Stimulus',\n                    loadConfig: true,\n                    id: 'InitPost',\n                    conditional: function() {\n                        return true;\n                    },\n                    proceedOnHide: true\n\n                };\n                QRTE.setConfig(QuestionStackElement.id, 'duration', 0);\n                QRTE.postInitElement = QuestionStackElement;\n                QRTE.questionQueue.push(QuestionStackElement);\n            });\n\n            if (paramObj.interTrialDelay instanceof Array) {\n                paramObj.interTrialDelay = paramObj.interTrialDelay[Math.floor(Math.random() * paramObj.interTrialDelay.length)];\n            }\n            QRTE.setTrialData(paramObj.blockId + '[InterTrialDelay]', paramObj.interTrialDelay);\n            if (paramObj.interTrialDelay > 0) {\n                QRTE.setBlockData('QRTLib_intraTrialDelay', paramObj.interTrialDelay);\n            } else {\n                QRTE.setBlockData('QRTLib_intraTrialDelay', -1);\n            }\n        },\n\n        /**\n         * Create a Stimulus question\n         * @method Stimulus\n         * @param paramObj {Object}\n         *  @param paramObj.id {String} Id of the Question\n         *  @param paramObj.onShowFn {Function} Function to be called upon showing the question (not the same as upon loading)\n         *  @param [paramObj.conditional] {Function} Function to be called with which to decide whether to present this question or not, should return a boolean.\n         *  @param [paramObj.loadConfig] {Boolean} Load predefined config for this question (defaults to true)\n         *  @param [paramObj.stimContinue] {Boolean} Continue looking for stimuli after having seen this one, only if set to true (defaults to false)\n         *  @param [paramObj.onKeyPress] {Function} Function to be called upon receiving a key press while this Question is active (called next to onAllowableKey or onCorrectKey)\n         *  @param [paramObj.onAllowableKey] {Function} Function to be called upon receiving a key press on a key defined as 'allowable' \n         *  @param [paramObj.onCorrectKey] {Function} Function to be called upon receiving a key press on a key defined as 'correct'\n         *  @param [paramObj.onIncorrectKey] {Function} Function to be called upon receiving an allowable key that is not defined as correct (only if correct responses are defined)\n         *  @param [paramObj.proceedOnHide] {Boolean} Set whether all currently displayed elements should be removed on hide, or if only this should be removed from display (Defaults to True). This allows the user to decouple presentation of a stimulus from proceeding of a slide.\n         *  @param [paramObj.onHideFn] {Function} Function to be called upon Stimulus being hidden\n         *  @param [paramObj.duringDisplayFn] {Function} Function to be called during each frame that the Stimulus is being displayed\n         \n         */\n        Stimulus: function(paramObj) {\n            var validationArray = [{\n                name: 'id',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'onShowFn',\n                type: ['Function'],\n                required: true\n            }, {\n                name: 'conditional',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'loadConfig',\n                type: ['Boolean'],\n                required: false\n            }, {\n                name: 'duringDisplayFn',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'continue',\n                type: ['Boolean'],\n                required: false\n            }, {\n                name: 'onAllowableKey',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'onCorrectKey',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'onKeyPress',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'onIncorrectKey',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'proceedOnHide',\n                type: ['Boolean'],\n                required: false\n            }, {\n                name: 'onHideFn',\n                type: ['Function'],\n                required: false\n            }];\n\n            //Validate Parameter Object, outputs stuff to console\n            QRTE.validateParams(paramObj, validationArray, 'Stimulus');\n\n\n            if (paramObj.conditional === undefined) {\n                paramObj.conditional = function() {\n                    return true;\n                };\n            }\n            if (paramObj.loadConfig === undefined) {\n                paramObj.loadConfig = true;\n            }\n\n            if (paramObj.stimContinue === undefined) {\n                paramObj.stimContinue = false;\n            }\n\n            if (paramObj.proceedOnHide === undefined) {\n                paramObj.proceedOnHide = true;\n            }\n            Qualtrics.SurveyEngine.addOnload(function() {\n                this.QRTLib_isActive = false;\n                this.proceed = QRTE.proceed;\n                this.QRTLibId = paramObj.id;\n                var QuestionStackElement = {\n                    questionElement: this,\n                    onShowFunc: paramObj.onShowFn,\n                    duringDisplayFn: paramObj.duringDisplayFn,\n                    onHideFn: paramObj.onHideFn,\n                    type: 'Stimulus',\n                    loadConfig: paramObj.loadConfig,\n                    id: paramObj.id,\n                    conditional: paramObj.conditional,\n                    stimContinue: paramObj.stimContinue,\n                    onAllowableKey: paramObj.onAllowableKey,\n                    onCorrectKey: paramObj.onCorrectKey,\n                    onKeyPress: paramObj.onKeyPress,\n                    onIncorrectKey: paramObj.onIncorrectKey,\n                    proceedOnHide: paramObj.proceedOnHide\n                };\n                QRTE.questionQueue.push(QuestionStackElement);\n            });\n        },\n\n        /**\n         * Exit denotes the end of the block. Important for the initialization phase and the exit phase.\n         * Make the question a Form question with precisely 2 answer fields (more is unnecessary, those will get ignored)\n         * @method Exit\n         */\n        Exit: function() {\n\n\n            qArray = $('Questions').getElementsByClassName('QuestionOuter');\n            for (var i = 0; i < qArray.length && i < QRTE.initIndex + 1; i += 1) {\n                qArray[i].style.display = 'block';\n            }\n            Qualtrics.SurveyEngine.addOnload(function() {\n                //Hide all choice\n                this.hideChoices();\n                //display the question\n                //this.questionContainer.style.display = 'none';\n                var QuestionStackElement, onShowFn;\n                onShowFn = function() {\n\n                    //Create and/or store standard information about the trial\n                    var blockId = QRTE.getBlockData('QRTLib_currentBlock'),\n                        tempTD = {},\n                        key,\n                        i;\n\n                    QRTE.setBlockData('QRTLib_previousEndTime', window.requestAnimationFrame.now());\n                    QRTE.setTrialData(blockId + '[TrialNr]', QRTE.getBlockData('QRTLib_blockCounter'));\n                    QRTE.setTrialData(blockId + '[RefreshPeriod]', QRTE.refreshPeriod);\n                    QRTE.setTrialData('BlockId', blockId);\n                    QRTE.setTrialData('EngineType', window.requestAnimationFrame.method);\n                    QRTE.setTrialData('Exit[OnsetTime]', window.requestAnimationFrame.now());\n                    QRTE.setTrialData('QRTEngine[Version]', QRTE.version);\n\n                    //CHECK IF ATLEAST TWO FORM FIELDS HAVE BEEN DEFINED\n                    this.setChoiceValue(2, 'testtest');\n                    if (this.getChoiceValue(2) !== 'testtest') {\n                        //alert('You need to define two answer form fields in the Exit question!!');\n                    }\n\n                    for (key in QRTE.TDCache) {\n                        if (QRTE.TDCache.hasOwnProperty(key) && key !== '') {\n                            //Change QID thingies to entered ID's, also force every value to a string so that the Parser handles high numerical values correctly\n                            tempTD[QRTE.getOutputKey(key)] = String(QRTE.TDCache[key]);\n                        }\n                    }\n\n                    this.setChoiceValue(1, Object.toJSON(tempTD));\n                    this.setChoiceValue(2, blockId);\n                    if (QRTE.SDCache[QRTE.columnsField][blockId] === undefined) {\n                        QRTE.SDCache[QRTE.columnsField][blockId] = [];\n                    }\n                    for (i = 0; i < QRTE.newlyAddedColumns.length; i += 1) {\n                        QRTE.SDCache[QRTE.columnsField][blockId].push(QRTE.getOutputKey(QRTE.newlyAddedColumns[i]));\n                    }\n\n                    QRTE.setSurveyData(QRTE.columnsField, Object.toJSON(QRTE.SDCache[QRTE.columnsField]));\n                    QRTE.setBlockData('QRTLib_blockCounter', QRTE.getBlockData('QRTLib_blockCounter') + 1);\n                    QRTE.setBlockData('QRTLib_previousStorageDone', window.requestAnimationFrame.now());\n                    QRTE.saveBlockData();\n\n                    //If wanting to test, uncomment this line and comment the one after that to enforce manual nextbutton clicks\n                    //$('NextButton').style.display = 'block';\n                    //QRTE.submitPage();\n                    QRTEController.loadNextTrial();\n                };\n\n                QuestionStackElement = {\n                    questionElement: this,\n                    onShowFunc: onShowFn,\n                    type: 'Storage',\n                    loadConfig: true,\n                    conditional: function() {\n                        return true;\n                    }\n                };\n                QRTE.questionQueue.push(QuestionStackElement);\n\n                QRTE.startTrial(0);\n\n            });\n\n            QRTE.loadWaitingList = [false];\n            if (QRTE.waitForImageLoad === true) {\n                //set wait for image load queues.\n                var loadIndex = 1,\n                    images = $$('.QuestionOuter img'),\n                    i = 0;\n\n                var l = images.length;\n                for (; i < l; i += 1) {\n                    images[i].observe('load', function(e) {\n                        QRTE.startTrial(e.path[0].QRTELoadIndex);\n                    })\n                    images[i].QRTELoadIndex = i + 1;\n                    QRTE.loadWaitingList[i + 1] = false;\n                }\n\n            }\n\n        },\n\n        /**\n         * Remove the padding Qualtrics adds between Questions (causes question presentation to drift downwards if not called).\n         * DEPRECATED: Separators hidden through CSS now\n         * @method removeSeparators\n         * @private\n         */\n        removeSeparators: function() {\n            var questionElement = document.getElementById('Questions'),\n                index;\n            for (index = 0; index < questionElement.children.length; index += 1) {\n                if (questionElement.children[index].className === \"Separator\") {\n                    questionElement.children[index].parentNode.removeChild(questionElement.children[index]);\n                }\n            }\n        },\n        /**\n         * Notifies the engine the first trial is ready to be started. Called at the end of the 'exit' question\n         * @private\n         * @method startTrial\n         */\n        startTrial: function(startId) {\n            var duringDisplayFn, onHideFn, onDisplayFn, serverCommDelay, remainingDelay;\n            //All questions have been hidden, so display the parent block again\n            //$('Questions').style.display = 'block';\n\n            QRTE.loadWaitingList[startId] = true;\n            if (!QRTE.loadWaitingList.every()) {\n                QRTE.log('Process ' + startId + 'finished, waiting for other processes to finish')\n                return;\n            }\n\n            //Save the absolute time of when onLoad part of library was finished\n            serverCommDelay = window.requestAnimationFrame.now() - QRTE.getBlockData('QRTLib_previousEndTime'); //Calculate the remaining time based on the lib initialization + server delay times\n            remainingDelay = QRTE.getBlockData('QRTLib_intraTrialDelay') - serverCommDelay;\n\n\n            if (isNaN(remainingDelay)) {\n                remainingDelay = QRTE.getBlockData('QRTLib_intraTrialDelay') * 3;\n                //If this init call is the first one of the block (first trial), calculate the estimated refreshdelay during the pre-trial interval\n                onDisplayFn = function(ele, time) {\n                    QRTE.setTrialData('Init[OffsetTime]', ele.displayOnsetTime);\n                    QRTE.setTrialData('Init[CalculatedDuration]', ele.displayOnsetTime - QRTE.getTrialData('Init[OnsetTime]'));\n                    QRTE.refreshPeriodEstimationStack = [];\n                };\n                duringDisplayFn = function(ele, time) {\n                    //Get current time, required for \n                    QRTE.refreshPeriodEstimationStack.push(time);\n                };\n                onHideFn = function(ele, timestamp) {\n                    var diffs = [];\n\n                    for (i = 1; i < QRTE.refreshPeriodEstimationStack.length; i += 1) {\n                        diffs[i - 1] = QRTE.refreshPeriodEstimationStack[i] - QRTE.refreshPeriodEstimationStack[i - 1];\n                    }\n                    QRTE.refreshPeriod = QRTE.median(diffs);\n                    QRTE.log('Estimated refresh delay = ' + QRTE.refreshPeriod);\n                    QRTE.setBlockData('QRTE_refreshPeriod', QRTE.refreshPeriod);\n                    QRTE.referenceTime = timestamp;\n                    QRTE.framesSinceReference = 0;\n                };\n            } else {\n                onDisplayFn = function(ele, time) {\n                    QRTE.setTrialData('Init[OffsetTime]', ele.displayOnsetTime);\n                    QRTE.setTrialData('Init[CalculatedDuration]', ele.displayOnsetTime - QRTE.getTrialData('Init[OnsetTime]'));\n                };\n\n                QRTE.refreshPeriod = QRTE.getBlockData('QRTE_refreshPeriod');\n            }\n\n            //QRTE.setTrialData('ITI[Duration]', (remainingDelay > 0) ? remainingDelay : 0);\n            QRTE.initTime = window.requestAnimationFrame.now();\n\n            QRTE.postInitElement.onHideFn = onHideFn;\n            QRTE.postInitElement.onDisplayFn = onDisplayFn;\n            QRTE.postInitElement.duringDisplayFn = duringDisplayFn;\n            QRTE.setConfig('InitPost', 'duration', (remainingDelay > 0) ? remainingDelay : 0);\n            //UNCOMMENT\n            //QRTE.setConfig('InitPost', 'duration', (remainingDelay > 0) ? remainingDelay : Infinity);\n            QRTE.inited = true;\n\n            //Set initial trial data related to loading of this trial\n            QRTE.setTrialData('InitServerComm[Onset]', QRTE.getBlockData('ServerCommOnset'));\n            QRTE.setTrialData('InitServerComm[Offset]', QRTE.getBlockData('ServerCommOffset'));\n            QRTE.setTrialData('InitServerComm[CalculatedDuration]', QRTE.getBlockData('ServerCommOffset') - QRTE.getBlockData('ServerCommOnset'));\n\n            //<Load next trial here>\n            var currentLoops = '${lm://CurrentLoopNumber}',\n                totalLoops = '${lm://TotalLoops}';\n            //Check if last trial, currentloops === totalLoops;\n            QRTEController.requestNextTrial(currentLoops !== '' && currentLoops === totalLoops);\n\n            QRTE.proceed();\n        },\n\n\n\n        proceed: function() {\n            QRTE.log(\"proceed called after \" + window.requestAnimationFrame.now() - QRTE.initTime);\n            QRTE.hideAllElements();\n        },\n\n        proceedPage: function() {\n            var currentQ;\n            QRTE.log(\"Proceeding page..\");\n            while (QRTE.currentPageQuestions.length > 0) {\n                currentQ = QRTE.currentPageQuestions.shift();\n\n                //Disable\n                currentQ.questionElement.QRTLib_isActive = false;\n            }\n\n\n            //Go to next question\n            QRTE.showNextPage();\n        },\n\n        disableQuestion: function(disableQ) {},\n\n        /**\n         * Determine and show the next page/slide\n         * @private\n         * @method showNextPage\n         */\n        showNextPage: function() {\n            var continueSearch = true,\n                shownQ = false,\n                nextQ,\n                shown;\n            while (continueSearch === true) {\n                continueSearch = false;\n                nextQ = QRTE.questionQueue.shift();\n                if (nextQ !== undefined && (nextQ.type === 'Stimulus' || nextQ.type === 'Storage')) {\n                    QRTE.currentPageQuestions.push(nextQ);\n                    shown = QRTE.showStimulusQuestion.apply(nextQ.questionElement, [nextQ]);\n\n                    if (nextQ.stimContinue) {\n                        continueSearch = true;\n                        if (shown === true) {\n                            shownQ = true;\n                        }\n                    }\n                    QRTE.log('shown ' + nextQ.id + ': ' + shown);\n                    QRTE.log('continue ' + nextQ.id + ': ' + continueSearch);\n                    if (shown === false && shownQ === false) {\n                        continueSearch = true;\n                    }\n                }\n            }\n\n        },\n\n        /**\n         * Show Question\n         * Handles the activation of that question, which includes:\n         * The loading of the configuration (duration, allowable keys etc).\n         * Sets the event handler to respond to any key presses during the event.\n         * @private\n         * @method showStimulusQuestion\n         * @param question {Object} question to be shown.\n         *  @param id {String} Id of question.\n         *  @param onShowFunc {Function} Function to be called when showing question\n         *  @param loadConfig {Boolean} If true, config is loaded from the current block data (which has been defined elsewhere)\n         *  @param questionElement {Object} This Qualtrics question element\n         *  @param duringDisplayFn {Function} Function to be called each frame that the question is presented\n         */\n        showStimulusQuestion: function(question) {\n            //Save the loading start time\n            //QRTE.setTrialData(question.questionElement.QRTLibId + '[LoadStartTime]', window.requestAnimationFrame.now());\n            //Set mapping of the QID -> QRTE Id\n            QRTE.setId(this, question.id);\n\n            //Initialize variables\n            var stimulusShown = false,\n                questionScope = this,\n                dispEle;\n            QRTE.log(question);\n\n            //Check whether question should be shown or not, if not skip to the next question (implicitly)\n            if (question.conditional() === true) {\n                this.QRTLib_isActive = true;\n\n\n                if (question.loadConfig === true) {\n                    //Load the Configuration of the Question, important!\n                    QRTE.loadConfig(this);\n                }\n\n                //Check if KeyPress listener is required (one or more of the following fields are defined: onKeyPress, onCorrectKey or onAllowableKey)\n                //If so, add keypress listener.\n                if (question.onKeyPress !== undefined || question.questionElement.allowable !== '' || question.questionElement.cresp !== '') {\n                    //Initialize the fields used for storing data about RT timing.\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[RTTime]', '');\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[RT]', '');\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[RESP]', '');\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[ACC]', 0);\n\n                    //Add the key listener\n                    QRTE.addKeyListener(function(e) {\n\n                        //Get the Key of the response\n                        var RT, RESP = QRTE.keycode2string(e),\n                            RTTime = window.requestAnimationFrame.now();\n                        RT = RTTime - QRTE.getTrialData(question.questionElement.QRTLibId + '[OnsetTime]');\n\n                        //Store the Time of the Key Press and calculate the RT and ACC if correct\n\n                        if ((QRTE.isAllowableResponse(question.questionElement, RESP) || QRTE.isCorrectResponse(question.questionElement, RESP)) && QRTE.getTrialData(question.questionElement.QRTLibId + '[RTTime]') === '') {\n                            QRTE.setTrialData(question.questionElement.QRTLibId + '[RTTime]', RTTime);\n                            QRTE.setTrialData(question.questionElement.QRTLibId + '[RT]', RT);\n                            QRTE.setTrialData(question.questionElement.QRTLibId + '[RESP]', RESP);\n                            if (QRTE.isCorrectResponse(question.questionElement, RESP)) {\n                                QRTE.saveAcc(question.questionElement, 1);\n                            } else {\n                                QRTE.saveAcc(question.questionElement, 0);\n                            }\n                        }\n\n                        //Store the RT and the Response\n\n                        //Set Handling Key Press to true, this lets the engine know that a keypress is currently being handled. Necessary when there is a timer (response deadline)\n                        question.handlingKeyPress = true;\n\n                        if (question.onCorrectKey !== undefined && QRTE.isCorrectResponse(question.questionElement, RESP)) {\n                            question.onCorrectKey.apply(question.questionElement, [e, RESP]);\n                        } else if (question.onIncorrectKey !== undefined && QRTE.isAllowableResponse(question.questionElement, RESP)) {\n                            question.onIncorrectKey.apply(question.questionElement, [e, RESP]);\n                        }\n\n                        if (question.onAllowableKey !== undefined && QRTE.isAllowableResponse(question.questionElement, RESP)) {\n                            question.onAllowableKey.apply(question.questionElement, [e, RESP]);\n                        }\n\n                        if (question.onKeyPress !== undefined) {\n                            question.onKeyPress.apply(question.questionElement, [e, RESP]);\n                        }\n\n                        if (question.questionElement.endAction === 'TERMINATE') {\n                            //Proceed to the next Question Page if the response is allowable\n                            if (QRTE.isAllowableResponse(question.questionElement, RESP) && question.questionElement.QRTLib_isActive === true) {\n                                question.questionElement.proceed();\n                            }\n                        }\n                        question.handlingKeyPress = false;\n\n                    }, this);\n                }\n\n                //Build the display Element. Stimuli Questions have to take into account the possibility of being associated with a key press. \n                //OnDisplayFn therefore logs the displayOnsetTime, so that the RT can be calculated.\n                dispEle = {\n                    el: this.questionContainer,\n                    duration: this.duration,\n                    delay: this.offset,\n                    duringDisplayFn: question.duringDisplayFn,\n                    onDisplayFn: function(displayEl, timestamp) {\n                        if (question.onDisplayFn !== undefined) {\n                            question.onDisplayFn(displayEl, timestamp);\n                        }\n                        QRTE.setTrialData(questionScope.QRTLibId + '[OnsetTime]', displayEl.displayOnsetTime);\n                    },\n                    proceedOnHide: question.proceedOnHide,\n                    id: question.id\n                };\n\n                //Set the OnHide Function\n                dispEle.onHideFn = function(displayEl, timestamp) {\n                    if (question.onHideFn !== undefined) {\n                        question.onHideFn(displayEl, timestamp);\n                    }\n                    QRTE.setTrialData(questionScope.QRTLibId + '[OffsetTime]', displayEl.displayOffsetTime);\n                    QRTE.setTrialData(questionScope.QRTLibId + '[CalculatedDuration]', displayEl.displayDuration);\n                };\n\n\n                this.QRTLib_timer = QRTE.displayElement(dispEle);\n\n                question.onShowFunc.apply(this);\n\n                stimulusShown = true;\n            }\n\n            //QRTE.setTrialData(question.questionElement.QRTLibId + '[LoadEndTime]', window.requestAnimationFrame.now());\n            return stimulusShown;\n        },\n\n        setId: function(question, desc) {\n\n            this.idCache[question.questionId] = desc;\n            question.qId = desc;\n\n            Qualtrics.SurveyEngine.setEmbeddedData(QRTE.idField, Object.toJSON(this.idCache));\n        },\n\n        getOutputKey: function(key) {\n            var oldKey;\n            for (oldKey in this.idCache) {\n                if (this.idCache.hasOwnProperty(oldKey) && oldKey === key.substring(0, oldKey.length)) {\n\n                    return QRTE.getBlockData('QRTLib_currentBlock') + this.idCache[oldKey] + key.substring(oldKey.length, key.length);\n                }\n            }\n            return key;\n        },\n\n\n        OnKeyPress: function(fn, qScope) {\n\n            qScope = qScope || window;\n\n            var keyFn = function(e) {\n                QRTE.setTrialData(qScope.QRTLibId + '[RTTime]', window.requestAnimationFrame.now());\n                var RT = QRTE.getTrialData(qScope.QRTLibId + '[RTTime]') - QRTE.getTrialData(qScope.QRTLibId + '[OnsetTime]');\n                QRTE.setTrialData(qScope.QRTLibId + '[RT]', RT);\n                QRTE.setTrialData(qScope.QRTLibId + '[RESP]', QRTE.keycode2string(e));\n                QRTE.log(qScope);\n                fn.apply(qScope, [e]);\n            }\n\n            QRTE.addKeyListener(keyFn, qScope);\n        },\n\n        addKeyListener: function(fn, listenerScope) {\n            Event.observe(document, 'keypress', function(e) {\n                if (listenerScope.QRTLib_isActive === true) {\n                    fn.apply(listenerScope, [e]);\n                }\n            });\n        },\n\n        /*  \n         **************Methods below this line are support methods*******************\n         */\n\n        hideQuestions: function() {\n            qArray = $('Questions').getElementsByClassName('QuestionOuter');\n            for (var i = 0; i < qArray.length; i += 1) {\n                qArray[i].style.display = 'none';\n            }\n        },\n\n        unhideQuestions: function() {\n            //Redisplay outer questions\n            qArray = $('Questions').getElementsByClassName('QuestionOuter');\n            for (var i = 0; i < qArray.length; i += 1) {\n                qArray[i].style.display = 'block';\n            }\n            //Redisplay separators\n            qArray = $('Questions').getElementsByClassName('Separator');\n            for (var i = 0; i < qArray.length; i += 1) {\n                qArray[i].style.display = 'block';\n            }\n\n\n        },\n\n        _handleKeyPressEvent: function() {\n\n        },\n\n        _setConfig: function(QID, option, value, setterFunc) {\n            var qidString = QID;\n            if (typeof QID !== 'string') {\n                qidString = QID.questionId;\n            }\n            option = option.toLowerCase();\n\n            switch (option) {\n                case 'duration':\n                    if (value instanceof Array) {\n                        value = value[Math.floor(Math.random() * value.length)];\n                    }\n                    setterFunc.apply(this, [qidString, 'Duration', value]);\n                    break;\n                case 'allowable':\n                    setterFunc.apply(this, [qidString, 'Allowable', value]);\n                    break;\n                case 'cresp':\n                    setterFunc.apply(this, [qidString, 'CRESP', value]);\n                    break;\n                case 'delay':\n                    setterFunc.apply(this, [qidString, 'Offset', value]);\n                    break;\n                case 'endaction':\n                    setterFunc.apply(this, [qidString, 'EndAction', value]);\n                    break;\n                default:\n                    QRTE.log('No such configuration: ' + option);\n                    break;\n            }\n        },\n        getDuration: function(question) {\n            var duration = Infinity,\n                edDuration = this.getTrialData(question.QRTLib_configId + '[Duration]');\n            if (edDuration !== undefined && edDuration !== '' && !isNaN(edDuration)) {\n                duration = edDuration;\n            }\n            if (question._Duration !== undefined && question._Duration !== '' && !isNaN(question._Duration)) {\n                duration = question._Duration;\n            }\n\n            return duration;\n        },\n        getAllowable: function(question) {\n            var allowable = \"\",\n                edAllowable = this.getTrialData(question.QRTLib_configId + '[Allowable]');\n            if (edAllowable !== undefined) {\n                allowable = edAllowable;\n            }\n            if (question._Allowable !== undefined) {\n                allowable = question._Allowable;\n            }\n\n            if (allowable === '{ANY}') {\n                allowable = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890-=[]\\\\;',./`\";\n            }\n            //allowable = allowable.toUpperCase();\n            return allowable;\n        },\n        getCResp: function(question) {\n            var cresp = '',\n                edcresp = this.getTrialData(question.QRTLib_configId + '[CRESP]');\n            if (edcresp !== undefined) {\n                cresp = edcresp;\n            }\n            if (question._cresp !== undefined) {\n                cresp = question._CRESP;\n            }\n\n            if (cresp === '{ANY}') {\n                cresp = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890-=[]\\\\;',./`\";\n            }\n            //cresp = cresp.toUpperCase();\n\n            return cresp;\n        },\n\n        getOffset: function(question) {\n            var offset = 0,\n                edOffset = this.getTrialData(question.QRTLib_configId + '[Offset]');\n            if (edOffset !== undefined && edOffset !== '' && !isNaN(edOffset)) {\n                offset = edOffset;\n            }\n            if (question._Offset !== undefined && question._Offset !== '' && !isNaN(question._Offset)) {\n                offset = question._Offset;\n            }\n\n            return offset;\n\n        },\n\n        getEndAction: function(question) {\n            var endAction = 'NONE',\n                edEndAction = this.getTrialData(question.QRTLib_configId + '[EndAction]');\n            if (edEndAction !== undefined && edEndAction !== '') {\n                endAction = edEndAction;\n            }\n            if (question._EndAction !== undefined && question._EndAction !== '') {\n                endAction = question._EndAction;\n            }\n\n            return endAction;\n\n        },\n        evaluateConditional: function(conditional) {\n            QRTE.log('Conditional: ', conditional);\n            return conditional === '' || conditional();\n        },\n        log: function() {\n            if (QRTE.debug === true) {\n                for (var i = 0; i < arguments.length; i += 1) {\n                    console.log(arguments[i]);\n                }\n            }\n        },\n\n        median: function(values) {\n\n            values.sort(function(a, b) {\n                return a - b;\n            });\n\n            var half = Math.floor(values.length / 2);\n\n            if (values.length % 2) return values[half];\n            else return (values[half - 1] + values[half]) / 2.0;\n        },\n\n        waitForKey: function(question, keys) {\n            Event.observe(document, 'keypress', function(e) {\n                var resp = QRTE.keycode2string(e);\n                if (keys.indexOf(resp) >= 0) {\n                    question.clickNextButton();\n                }\n            });\n        },\n\n        validateParams: function(paramObj, validationArray) {\n            var valObj, val, index, typeCheck = true,\n                indexType;\n            //Loop over validationArray to check whether parameters suffice\n            for (index = 0; index < validationArray.length; index += 1) {\n                valObj = validationArray[index];\n                if (paramObj[valObj.name] === undefined && valObj.required === true) {\n                    alert('Required parameter: ' + valObj.name + ' seems to be missing');\n                    QRTE.log('Required parameter: ' + valObj.name + ' seems to be missing');\n                    break;\n                }\n\n                val = paramObj[valObj.name];\n\n                //Loop over type checkers\n                for (indexType = 0; indexType < valObj.type.length; indexType += 1) {\n                    typeCheck = QRTE.validateType(val, valObj.type[indexType]);\n                    if (typeCheck === true) {\n                        break;\n                    }\n                }\n                if (typeCheck === false && valObj.required === true) {\n                    alert('Parameter: ' + valObj.name + ' is of the wrong type, expected type: ' + valObj.type + ', type received: ' + (typeof val) + \"\\n\" + \"Please open the console for detailed error messages\");\n                    QRTE.log('Parameter: ' + valObj.name + ' is of the wrong type, expected type: ' + valObj.type + ', type received: ' + (typeof val));\n                    QRTE.log('Faulty parameter ' + valObj.name + ': ', val);\n                    QRTE.log('Proper functioning of QRTE is no longer guaranteed, please fix the above error');\n                }\n\n            }\n        },\n\n        validateType: function(val, type) {\n            switch (type) {\n                case 'JSON':\n                    return val.isJSON();\n                case 'String':\n                    return (typeof val === 'string' || val instanceof String);\n                case 'Number':\n                    return (!isNaN(parseFloat(val)) && isFinite(val));\n                case 'Array':\n                    return val instanceof Array;\n                case 'Object':\n                    return typeof val === 'object';\n                case 'Function':\n                    return typeof val === 'function';\n                case 'Boolean':\n                    return (val === true || val === false);\n                case 'Empty':\n                    return val === '';\n                default:\n                    return false;\n            }\n        },\n\n        fixSetEmbeddedDataBug: function() {\n            Qualtrics.SurveyEngine.setEmbeddedData = function(key, value) {\n                var fieldName = 'ED~' + key;\n                if ($(fieldName)) {\n                    $(fieldName).value = value;\n                } else {\n                    $('Header').appendChild(QBuilder('input', {\n                        type: 'hidden',\n                        id: fieldName,\n                        name: fieldName,\n                        value: value\n                    }));\n                    Qualtrics.SurveyEngine.setEmbeddedData(key, value);\n                }\n            }\n        },\n\n        //DisplayEngine part\n\n        //Since it's impossible to know when a screen refresh has happened, we assume that the first timestamp is the actual screen refresh.\n        //Based on the difference between the current timestamp Tn and the root timestamp Tn-1, we estimate the amount of frames that have passed since. \n        //Based on the amount of frames we estimate the previous screen refresh. Although not perfect, it's the best we can do.\n\n        refreshRate: 60, //hertz\n        refreshPeriod: 1000 / 60,\n        lastRefresh: 0,\n        currentRefresh: 0,\n        previousTimestamp: 0,\n        referenceTime: 0,\n        framesSinceReference: 0,\n        currentStack: [],\n        proceedOnFrameEnd: false,\n\n        init: function() {\n            window.requestAnimationFrame(QRTE.draw);\n        },\n\n        draw: function(timestamp) {\n            var curEle, newStack = [];\n            timestamp = window.requestAnimationFrame.now();\n\n\n            if (timestamp < 1e12) {\n                timestamp += window.performance.timing.navigationStart;\n            }\n\n            if (QRTE.referenceTime === 0) {\n                QRTE.referenceTime = timestamp;\n                QRTE.previousTimestamp = timestamp;\n                QRTE.framesSinceReference = 0;\n            } else {\n                //QRTE.framesSinceReference += QRTE.calcFrames(QRTE.referenceTime, timestamp);\n                QRTE.prevFrames = QRTE.framesSinceReference;\n                //frameDiff =  QRTE.calcFrames(QRTE.referenceTime, timestamp) - QRTE.prevFrames;\n                QRTE.framesSinceReference = QRTE.calcFrames(QRTE.referenceTime, timestamp);\n            }\n            QRTE.currentRefresh = (QRTE.framesSinceReference * QRTE.refreshPeriod) + QRTE.referenceTime;\n            QRTE.projectedRefresh = QRTE.currentRefresh + QRTE.refreshPeriod;\n            curEle = QRTE.currentStack.shift();\n\n            while (curEle) {\n                curEle.keep = true;\n\n                //Call duringDisplay callback function, with the current element and the timestamp as arguments.\n                if (curEle.shown === true && typeof curEle.duringDisplayFn === 'function') {\n                    curEle.duringDisplayFn(curEle, timestamp);\n                }\n\n                if (QRTE.proceedOnFrameEnd === true || curEle.hide === true || (curEle.shown === true && curEle.displayOnset !== undefined && (curEle.displayOnset + curEle.duration < QRTE.projectedRefresh))) {\n                    //If the next refresh makes it go beyond the duration, hide the element again!\n                    curEle = QRTE.hideSingleEle(curEle, timestamp);\n                } else if (curEle.shown === false && curEle.requestedAt + curEle.delay < QRTE.projectedRefresh) {\n                    curEle = QRTE.dispSingleEle(curEle, timestamp);\n                }\n\n                if (curEle.keep === false && curEle.proceedOnHide === true) {\n                    //Behold! We have found an element that commands us to proceed to the next page.\n                    QRTE.proceedOnFrameEnd = true;\n                    //Every element that has been processed so far needs to be re-processed (sadly), so that they properly hide.\n                    for (var ind = 0; ind < newStack.length; ind += 1) {\n                        if (newStack[ind].hide !== true) {\n                            newStack[ind].hide = true;\n                            QRTE.currentStack.push(newStack[ind]);\n                        }\n                    }\n                } else {\n                    //Push it to the newStack, for it to be processed next time.\n                    newStack.push(curEle);\n                }\n\n                curEle = QRTE.currentStack.shift();\n            }\n            QRTE.currentStack = newStack;\n            QRTE.lastRefresh = QRTE.currentRefresh;\n            QRTE.previousTimestamp = timestamp;\n            window.requestAnimationFrame(QRTE.draw);\n            if ((newStack.length === 0 || QRTE.proceedOnFrameEnd) && QRTE.inited === true) {\n                QRTE.proceedOnFrameEnd = false;\n                QRTE.proceedPage();\n            }\n\n\n        },\n\n        calcFrames: function(previous, current) {\n            var diff = current - previous,\n                frames = 0;\n\n            if (diff < QRTE.refreshPeriod) {\n                frames = 1;\n            } else {\n                frames = Math.floor(diff / QRTE.refreshPeriod);\n                if (diff % QRTE.refreshPeriod >= (QRTE.refreshPeriod * 0.9)) {\n                    frames += 1;\n                }\n            }\n\n            return frames;\n        },\n\n        /**\n         * Display an element for a specified duration with a specified delay. Vsyncs the display duration using requestAnimationFrame (if possible in the browser)\n         * and allows for high-precision control over its duration. Please start any custom attributes for the paramObj with the 'custom_' header, to avoid collisions.\n         * @private\n         * @method displayElement\n         * @param paramObj {Object}\n         *  @param el {Object} HTML element to be displayed\n         *  @param [onHideFn] {Function} Function to be called upon removing the element from display, is passed one argument containing all information about the display element.\n         *  @param [duration] {Number} Number of milliseconds (ms) the element should be displayed.\n         *  @param [delay] {Number} Number of milliseconds (ms) the Engine should wait before displaying the element.\n         *  @param [duringDisplayFn] {Function} Function to be called upon displaying the element for another screen refresh. Careful: Keep this function simple, could seriously hamper performance as it's called about every 16-17 ms.  is passed one argument containing all information about the display element.\n         *  @param [onDisplayfn] {Function} Function to be called upon starting to display the element. Is passed one argument containing all information about the display element.\n         */\n\n        //displayElement: function(el, callback, duration, offset, duringDisplaycb) {\n        displayElement: function(paramObj) {\n            var reqAt,\n                id = String(Math.random());\n            //QRTE.log(arguments);\n            if (paramObj.delay === undefined) {\n                paramObj.delay = 0;\n            }\n\n\n\n            if (paramObj.duration === undefined) {\n                paramObj = Infinity;\n            }\n\n            if (isNaN(QRTE.lastRefresh)) {\n                reqAt = window.requestAnimationFrame.now();\n            } else {\n                reqAt = QRTE.lastRefresh;\n            }\n            paramObj.userId = paramObj.id;\n            paramObj.id = id;\n            paramObj.shown = false;\n            paramObj.requestedAt = reqAt;\n            paramObj.hide = false;\n\n            QRTE.currentStack.push(paramObj);\n            if (paramObj.delay === 0) {\n                //This element needs to be displayed as soon as possible\n                QRTE.dispSingleEle(paramObj, QRTE.previousTimestamp);\n            }\n            QRTE.log('Added element to display stack:', paramObj);\n            //console.log('paramObj: ', paramObj.userId, ', duration: ', paramObj.duration);\n\n            return id;\n        },\n\n        hideElement: function(id) {\n            var found = false,\n                i;\n            for (i = 0; i < QRTE.currentStack.length; i += 1) {\n                if (QRTE.currentStack[i].id === id) {\n                    found = true;\n                    QRTE.currentStack[i].hide = true;\n                    this.log('Element to be hidden: ', QRTE.currentStack[i]);\n                }\n            }\n            return found;\n        },\n\n        hideAllElements: function() {\n            for (i = 0; i < QRTE.currentStack.length; i += 1) {\n                QRTE.currentStack[i].hide = true;\n            }\n            QRTE.proceedOnFrameEnd = true;\n        },\n\n        /**\n         * Hide a DrawEngine Element\n         * @private\n         * @method hideSingleEle\n         * @param curEle {Object}\n         */\n        hideSingleEle: function(curEle, timestamp) {\n            curEle.displayOffset = QRTE.projectedRefresh;\n            curEle.displayOffsetTime = window.requestAnimationFrame.now();\n            curEle.el.style.display = 'none';\n            curEle.keep = false;\n            curEle.hide = true;\n            //delete QRTE.currentStack[key];\n            curEle.displayDuration = curEle.displayOffsetTime - curEle.displayOnsetTime;\n            if (curEle.onHideFn !== undefined) {\n                curEle.onHideFn(curEle, timestamp);\n            }\n\n            return curEle;\n\n        },\n\n\n        /**\n         * Display a DrawEngine Element\n         * @private\n         * @method dispSingleEle\n         * @param curEle {Object}\n         */\n        dispSingleEle: function(curEle, timestamp) {\n            curEle.el.style.display = 'block';\n            curEle.displayOnset = QRTE.projectedRefresh;\n            curEle.displayOnsetTime = window.requestAnimationFrame.now();\n            curEle.shown = true;\n            if (curEle.onDisplayFn !== undefined) {\n                //Added try-catch block to catch the error that's causing the OnsetTime not to get saved.\n                try {\n                    curEle.onDisplayFn(curEle, timestamp);\n                } catch (e) {\n                    QRTE.setTrialData('Error[OnsetError]', JSON.stringify(e));\n                }\n            }\n            return curEle;\n        },\n\n        checkEngineCompatibility: function() {\n            return window.requestAnimationFrame.method === 'native-highres';\n        },\n    };\n\n    if (typeof QRTEController == 'undefined') {\n        //QRTE SurveySlider controller layer\n        //Takes care of progressing through the survey. Catches all qualtrics native ways of submitting the form and replaces that by\n        //its own asynchronous ajax stuff.\n        QRTEController = {\n\n\n            //This plug-in to QRTEngine has been developed under the name SurveySlider\n            // for general Qualtrics Surveys. It has been adapted to work with QRTEngine\n            nextTrialContainer: null,\n            nextTrialText: '',\n            currentForm: null,\n            previousForm: null,\n            handlingSubmit: false,\n            onSubmitStack: [],\n            inited: false,\n            childInputs: [],\n            loadUponCallback: false,\n            setEmbeddedData: function() {},\n            tempED: {},\n\n\n\n            //Initialize thecontroller\n            init: function() {\n                this.nextTrialContainer = new Element('div', {\n                    id: 'nextTrialContainer'\n                });\n                this.currentForm = $$('form')[0];\n\n                //Catch submits and change it with our own submit function (which does AJAX submissions)\n                //this.currentForm.observe('QRTE:submit', QRTE.handleSubmit);\n                this.currentElements = $$('.QuestionOuter');\n\n                //Initial SSload firing\n                Qualtrics.SurveyEngine.addOnload(function() {\n                    QRTEController.currentForm.fire('QRTE:load');\n                });\n                //Change SurveyEngine.OnLoad to trigger on SSload, rather than page load\n                Qualtrics.SurveyEngine.addOnload = function(f) {\n                        var questions = $$('.QuestionOuter'),\n                            currentCount = QRTEController.count(Qualtrics.SurveyEngine.QuestionInfo),\n                            id = questions[currentCount - 1].id;\n                        if ($('body') && $('body').hasClassName('EditSection')) return;\n                        try {\n                            var obj = new Qualtrics.SurveyEngine.QuestionData(id);\n                            obj.onload = f;\n\n                            QRTEController.currentForm.observe('QRTE:load', obj.onload.bind(obj));\n                            //Event.observe(this.currentForm, 'SSload', obj.onload.bind(obj));\n                        } catch (e) {\n                            console.error('SE API Error: ' + e);\n                        }\n                    }\n                    //Set the Qualtrics setEmbeddedData to inside the QRTEController\n                QRTEController.setEmbeddedData = Qualtrics.SurveyEngine.setEmbeddedData;\n                Qualtrics.SurveyEngine.setEmbeddedData = function(key, value) {\n                    QRTEController.tempED[key] = value;\n                }\n                this.submitPage = this.requestNextTrial;\n                this.inited = true;\n            },\n\n            /**\n             * Requests the next trial from the Qualtrics server.\n             *\n             *\n             */\n            requestNextTrial: function(isLastTrial) {\n\n                //If this is the last trial of a block, DON'T request the next page, let qualtrics handle it themselves\n                if (this.handlingSubmit === false && isLastTrial === false) {\n                    //Load next trial means that current page is a trial and has been inited\n                    //Need to remove relevant input elements from current form before submitting\n                    //After that add them back\n                    this.handlingSubmit = true\n                    var childs = $$('form input[type=text]'),\n                        childInputs = [];\n                    //remove current input elements from the form\n                    for (var i = 0; i < childs.length; i += 1) {\n                        childInputs[i] = {\n                            ele: childs[i],\n                            parent: childs[i].up()\n                        };\n                        childs[i].remove();\n                    }\n                    //add previous input elements to form\n                    //Text inputs\n                    for (var i = 0; i < this.childInputs.length; i += 1) {\n                        this.childInputs[i].ele.style.display = 'none';\n                        this.currentForm.insert(this.childInputs[i].ele);\n                    }\n\n\n                    //And embedded data\n                    for (var key in this.tempED) {\n                        if (this.tempED.hasOwnProperty(key)) {\n                            QRTEController.setEmbeddedData(key, this.tempED[key]);\n                        }\n                    }\n                    //Reset stored embedded data\n                    this.tempED = {};\n                    //set new childs\n                    this.childInputs = childInputs;\n\n                    //Loop over submit stack, or callbacks that need to be finished before submitting\n                    for (var i = 0; i < QRTEController.onSubmitStack.length; i += 1) {\n                        QRTE.onSubmitStack[i]();\n                    }\n                    QRTEController.onSubmitStack = [];\n                    debugger;\n                    this.currentForm.request({\n                        onComplete: this.requestNextTrialCallback\n                    });\n\n                    //Set server comm onset for the next trial\n                    QRTE.setBlockData('ServerCommOnset', window.requestAnimationFrame.now());\n\n                    QRTEController.betweenSubmits = true;\n\n                    for (var i = 0; i < this.childInputs.length; i += 1) {\n                        this.childInputs[i].parent.insert(this.childInputs[i].ele);\n                        this.childInputs[i].ele.style.display = 'none';\n                    }\n                } else if (isLastTrial === true) {\n                    //Just add the previous trial's childInputs to the form \n                    for (var i = 0; i < this.childInputs.length; i += 1) {\n\n                        this.currentForm.insert(this.childInputs[i].ele);\n                        this.childInputs[i].ele.style.display = 'none';\n                    }\n\n                    this.loadNextTrial = function() {\n                        //Directly submitting the form doesn't seem to work? Let's do it through NextButton click\n                        $('NextButton').click();\n                    };\n                }\n            },\n\n            loadNextTrial: function() {\n                if (this.handlingSubmit === true) {\n                    //The submit still hasn't returned..\n                    this.loadUponCallback = true;\n                    return;\n\n                }\n                //Set handling submit to false (as page has been returned)\n                //Save the previous form\n                this.previousForm = this.currentForm;\n                //Reset the QuestionInfo object, this is for Qualtrics to correctly initiate its own page\n                Qualtrics.SurveyEngine.QuestionInfo = {}\n                    //Parse the HTML that was returned earlier and set it as the current trial container's contents\n                this.nextTrialContainer = jQuery(this.nextTrialContainer).html(this.nextTrialText)[0];\n                //Filter out the 'form' field, and append it back.\n                this.currentForm = jQuery(this.nextTrialContainer).find('form')[0];\n                jQuery(this.previousForm).replaceWith(jQuery(this.currentForm));\n\n                jQuery(this.currentForm).show();\n\n                if (this.currentForm.select('.END_OF_SURVEY').length === 0) {\n                    this.currentForm.fire('QRTE:load');\n                    this.submitPage = this.requestNextTrial;\n                } else {\n                    this.submitPage = this.currentForm.submit;\n                }\n\n            },\n\n            requestNextTrialCallback: function(e) {\n                QRTEController.nextTrialText = e.responseText;\n                QRTEController.handlingSubmit = false;\n                QRTE.setBlockData('ServerCommOffset', window.requestAnimationFrame.now());\n\n                if (QRTEController.loadUponCallback === true) {\n                    QRTEController.loadUponCallback = false;\n                    QRTEController.loadNextTrial();\n                }\n            },\n\n            submitPage: function() {\n                console.log('Not yet initialised');\n            },\n\n            count: function(obj) {\n                var count = 0;\n\n                for (var prop in obj) {\n                    if (obj.hasOwnProperty(prop))\n                        ++count;\n                }\n\n                return count;\n            },\n\n            BDCache: {},\n            storeBlockData: function(blockData) {\n                this.BDCache = blockData;\n            },\n\n            loadBlockData: function() {\n                return this.BDCache;\n            }\n        };\n\n        document.observe('dom:loaded', QRTEController.init.bind(QRTEController));\n\n\n        (function() {\n            var lastFrame, method, now, queue, requestAnimationFrame, timer, vendor, _i, _len, _ref, _ref1;\n            method = 'native';\n            now = Date.now || function() {\n                return new Date().getTime();\n            };\n            requestAnimationFrame = window.requestAnimationFrame;\n            _ref = ['webkit', 'moz', 'o', 'ms'];\n            for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n                vendor = _ref[_i];\n                if (!(requestAnimationFrame != null)) {\n                    requestAnimationFrame = window[vendor + \"RequestAnimationFrame\"];\n                }\n            }\n            if (!(requestAnimationFrame != null)) {\n                method = 'timer';\n                lastFrame = 0;\n                queue = timer = null;\n                requestAnimationFrame = function(callback) {\n                    var fire, nextFrame, time;\n                    if (queue != null) {\n                        queue.push(callback);\n                        return;\n                    }\n                    time = now();\n                    nextFrame = Math.max(0, 16.66 - (time - lastFrame));\n                    queue = [callback];\n                    lastFrame = time + nextFrame;\n                    fire = function() {\n                        var cb, q, _j, _len1;\n                        q = queue;\n                        queue = null;\n                        for (_j = 0, _len1 = q.length; _j < _len1; _j++) {\n                            cb = q[_j];\n                            cb(lastFrame);\n                        }\n                    };\n                    timer = setTimeout(fire, nextFrame);\n                };\n            }\n            requestAnimationFrame(function(time) {\n                var _ref1;\n                if ((((_ref1 = window.performance) != null ? _ref1.now : void 0) != null) && time < 1e12) {\n                    requestAnimationFrame.now = function() {\n                        return window.performance.now() + window.performance.timing.navigationStart;\n                    };\n                    requestAnimationFrame.method = 'native-highres';\n                } else {\n                    requestAnimationFrame.now = now;\n                }\n            });\n            requestAnimationFrame.now = ((_ref1 = window.performance) != null ? _ref1.now : void 0) != null ? (function() {\n                return window.performance.now() + window.performance.timing.navigationStart;\n            }) : now;\n            requestAnimationFrame.method = method;\n            window.requestAnimationFrame = requestAnimationFrame;\n        })();\n\n        function loadScript(url, callback) {\n\n            var script = document.createElement(\"script\")\n            script.type = \"text/javascript\";\n\n            if (script.readyState) { //IE\n                script.onreadystatechange = function() {\n                    if (script.readyState == \"loaded\" || script.readyState == \"complete\") {\n                        script.onreadystatechange = null;\n                        callback();\n                    }\n\n                };\n            } else { //Others\n                script.onload = function() {\n                    callback();\n                };\n            }\n\n            script.src = url;\n            document.getElementsByTagName(\"head\")[0].appendChild(script);\n        }\n\n        (function() {\n\n            //jQuery is only required for the Fixation flash fix. prototypejs is unable to efficiently replace elements\n            //and introduces a 10 ms delay between loading element and firing off the scripts. Unacceptable\n            //First time jQuery should be used is the second trial\n\n            loadScript(\"https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js\", function() {\n\n                $.noConflict();\n\n            });\n\n        })();\n\n        //If preview mode is run (PreviewBanner element exists, add a QRTEngine plug with id QRTEPlug)\n\n        if ($('PreviewBanner')) {\n            var plug, row, banner = $('PreviewBanner');\n            //Go down to the first table row inside that banner\n            row = banner.children[0].children[0].children[0];\n            //Insert new cell    \n            plug = row.insertCell(2);\n            plug.id = \"QRTEPlug\";\n            plug.width = \"20%\";\n            plug.innerHTML = 'This survey is proudly and successfully powered by <a href=\"http://qrtengine.com\" target=\"_blank\"><i><b>QRTEngine</b></i></a>';\n            plug.style.textAlign = \"center\";\n        }\n    }\n</script>\n<script>\n    QRTE.debug = true;\n\n    QRTLib = QRTE;\n</script>\n<style type=\"text/css\">\n    #Plug {\n        display: none;\n    }\n    #NextButton {\n        display: none;\n    }\n    #PreviousButton {\n        display: none;\n    }\n    html {\n        height: 100%;\n    }\n    body {\n        height: 100%;\n        padding: 0;\n        padding-top: 0 !important;\n        margin: 0;\n    }\n    .Skin {\n        display: table;\n        margin: auto;\n        min-height: 100%;\n        height: 100%;\n    }\n    #Page {\n        height: 100%;\n        min-height: 100%;\n    }\n    .SkinInner {\n        min-height: 100%;\n        display: table-cell;\n        vertical-align: middle;\n    }\n    .QuestionText {\n        border: 0px !important;\n        border-bottom: 0px !important;\n    }\n    .QuestionOuter {\n        display: none;\n    }\n    .Separator {\n        display: none !important;\n    }\n    #SkinContent > #Buttons,\n    .SkinInner > #Header {\n        padding: 0 !important;\n    }\n</style>","\n    /* ==========================================================\n     * QRTEngine.js v16\n     * ==========================================================\n     * Copyright 2013-2014 Erwin Haasnoot\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     * http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     *\n     *\n     *\n     * ========================================================== */\n    /**\n     * Qualtrics Reaction Time Engine or QRTE is an add-on providing an interface\n     * for easy reaction time experiment creation in the Qualtrics survey research suite (tm).\n     * For instructions on how to use this add-on, see xxxx\n     *\n     * QRTE was developed by Erwin Haasnoot\n     * Email: erwinhaasnoot[at]gmail.com\n     * @class QRTE\n     *\n     */\n    var QRTE = {\n        version: 'v16',\n        columnsField: 'QRTE_columns',\n        blockDataField: 'QRTE_blockData',\n        idField: 'QRTE_idData',\n        exitQuestions: 'QRTE_exitQuestions',\n        inited: false,\n        /**\n         * TDCache contains the Trial-Level Data in an Object. DO NOT directly manipulate this Object. It might cause inconsistencies in the data file and cause unexpected once parsed.\n         * Use QRTE.setTrialData and QRTE.getTrialData instead.\n         *\n         * @property TDCache\n         * @private\n         * @type Object\n         */\n        TDCache: {},\n\n        /**\n         * ColumnCache contains all the mappings from QID to Columns\n         * @property columnCache\n         * @private\n         * @type Object\n         */\n        columnCache: {},\n\n        /**\n         * BDCache contains the BlockLevel Data in an Object. Directly manipulating this Object might cause inconsistencies\n         * @property BDCache\n         * @private\n         * @type Object\n         */\n        BDCache: {},\n\n        /**\n         * SDCache is a cache for speeding up retrieval of Survey level Data,\n         * All Survey data is saved to both Embedded Data and Survey Data\n         * @private\n         * @property SDCache\n         * @type Object\n         */\n        SDCache: {},\n\n        /**\n         * idCache is a cache for quickly retrieving the Qualtrics QID to QRTLib Id mappings.\n         * Saved in the idData embedded data field after every trial.\n         * @private\n         * @property idCache\n         * @type Object\n         */\n        idCache: {},\n\n        /**\n         * questionQueue contains Objects (stimuli) that are waiting to be presented\n         * @private\n         * @property questionQueue\n         * @type Array\n         */\n        questionQueue: [],\n\n        /**\n         * currentPageQuestions contains the Question Objects that are\n         * displayed at any given time.\n         * @private\n         * @property currentPageQuestions\n         * @type Array\n         */\n        currentPageQuestions: [],\n\n        /**\n         * Contains Trial Data Columns that were 'newly' added in this trial run.\n         * @private\n         * @property newlyAddedColumns\n         * @type Array\n         */\n        newlyAddedColumns: [],\n\n        /**\n         * Contains the Post-Initialization Element.\n         * @private\n         * @property postInitElement\n         * @type Object\n         */\n        postInitElement: {},\n\n        /**\n         * Setter function for Trial-Level Data.\n         * @method setTrialData\n         * @param key {String} Key\n         * @param value {Value} Value\n         */\n        setTrialData: function(key, value) {\n            //Store value in trial cache\n            this.TDCache[key] = value;\n            if (this.BDCache.QRTLib_trialColumns[key] === undefined) {\n                //Add column to overall trial data\n                this.BDCache.QRTLib_trialColumns[key] = '';\n                this.newlyAddedColumns.push(key);\n            }\n        },\n\n        /**\n         * Gets the value of Trial-Level Data field 'key\n         * @method getTrialData\n         * @param key {String} Key\n         */\n        getTrialData: function(key) {\n            return this.TDCache[key];\n        },\n\n        /**\n         * Setter function for Block-Level Data.\n         * @method setBlockData\n         * @param key {String} Key\n         * @param value {Value} Value\n         */\n        setBlockData: function(key, value) {\n            this.BDCache[key] = value;\n        },\n\n\n        /**\n         * Gets the value of Block-Level Data field 'key\n         * @method getBlockData\n         * @param key {String} Key\n         */\n        getBlockData: function(key) {\n            return this.BDCache[key];\n        },\n\n\n\n\n        /**\n         * Stringify the Block Data and store it in the Embedded Data Field. This preserves the values stored on Block Level for use in later trials\n         * @method saveBlockData\n         * @param key {String} Key\n         */\n        saveBlockData: function() {\n            //Store blockData in ED so that we can use it next trial\n            QRTEController.storeBlockData(QRTE.BDCache);\n            Qualtrics.SurveyEngine.setEmbeddedData(QRTE.blockDataField, Object.toJSON(QRTE.BDCache));\n        },\n\n\n\n        /**\n         * Setter function for Survey-Level Data (Embedded Data).\n         * @method setSurveyData\n         * @param key {String} Key\n         * @param value {Value} Value\n         */\n        setSurveyData: function(key, value) {\n            this.SDCache[key] = value;\n            Qualtrics.SurveyEngine.setEmbeddedData(key, value);\n        },\n\n\n\n        /**\n         * Gets the value of Survey-Level Data (Embedded Data) 'key'\n         * @method getSurveyData\n         * @param key {String} Key\n         */\n\n        getSurveyData: function(key) {\n            if (this.SDCache[key] !== undefined) {\n                return this.SDCache[key];\n            }\n            //This only works if the Survey Data has been set during the same trial due to a bug in Qualtrics.\n            return Qualtrics.SurveyEngine.getEmbeddedData(key);\n        },\n\n        /**\n         * Sets a configuration for a question\n         * @method setConfig\n         * @param QID {String} The QRTE Question Id of the Question you want the configuration to apply to\n         * @param option {String} The type of configuration you want to set, Allowed options: 'cresp', 'allowable', 'duration', 'endaction', 'delay'. Refer to website for documentation on these configs\n         * @param value {String} The value the configuration needs to be set to. Differs per option.\n         */\n        setConfig: function(QID, option, value) {\n            var setterFunc;\n            if (typeof QID === 'string') {\n                setterFunc = function(QID, option, value) {\n                    this.setTrialData(QID + \"[\" + option + \"]\", value);\n                };\n            } else {\n                setterFunc = function(QID, option, value) {\n                    this.setTrialData(QID.questionId + \"[\" + option + \"]\", value);\n                    QID['_' + option] = value;\n                };\n\n            }\n\n            this._setConfig(QID, option, value, setterFunc);\n        },\n\n\n        /**\n         * Loads the configuration for a question.\n         * @private\n         * @method loadConfig\n         * @param question {Object} Question for which the configuration needs to be loaded.\n         */\n        loadConfig: function(question) {\n            if (this.idCache[question.questionId] !== undefined) {\n                question.QRTLib_configId = this.idCache[question.questionId];\n            } else {\n                question.QRTLib_configId = question.question;\n            }\n            question.duration = this.getDuration(question);\n            question.allowable = this.getAllowable(question);\n            question.cresp = this.getCResp(question);\n            question.offset = this.getOffset(question);\n            question.endAction = this.getEndAction(question);\n        },\n\n        /**\n         * Stores the accuracy of a trial\n         * @private\n         * @method saveAcc\n         * @param question {Object} Question for which accuracy needs to be stored\n         * @param acc {Integer} Accuracy of question\n         */\n\n        saveAcc: function(question, acc) {\n            if (acc === 0 || acc === 1) {\n                this.setTrialData(question.QRTLibId + \"[ACC]\", acc);\n                this.setSurveyData(\"ACC\", acc);\n            }\n        },\n\n\n\n        /**\n         * Check whether the given response was a correct response\n         * @method isCorrectResponse\n         * @param question {Object} Question for which correct response needs to be checked\n         * @param resp {String} Given response\n         */\n        isCorrectResponse: function(question, resp) {\n            return question.cresp.indexOf(resp) >= 0;\n        },\n\n        /**\n         * Check whether the given response was an allowable response\n         * @method isAllowableResponse\n         * @param question {Object} Question for which allowable response needs to be checked\n         * @param resp {String} Given response\n         */\n        isAllowableResponse: function(question, resp) {\n            return question.allowable.indexOf(resp) >= 0;\n        },\n\n\n\n        /**\n         * Check whether the given response was an allowable response\n         * @private\n         * @method keycode2string\n         * @param e {Object} KeyPress event from which to retrieve the response\n         */\n        keycode2string: function(e) {\n            return String.fromCharCode(e.charCode);\n        },\n\n        /** \n         * Wait for images to load before starting trial.\n         * @property waitForImageLoad\n         * @private\n         * @type Boolean\n         */\n\n        waitForImageLoad: true,\n\n        /** \n         * Trial Start waiting list - initialised with waiting for TrialStart\n         * @property loadWaitingList\n         * @private\n         * @type Array\n         */\n\n        loadWaitingList: [false],\n\n        /**\n         * Initializes the Engine, called at the start of the 'Init' question.\n         * @private\n         * @method initLib\n         * @param blockDataString {String} JSON string containing information saved for this block (block-level data)\n         * @param blockId {String} Id of the current block\n         * @param columns {String} JSON string containing information about the columns that have been defined in this block\n         * @param idData {String} JSON string containing information about the mapping of the QID to the name of the question\n         * @param exitQuestions {String} String containing the currently defined QuestionTags of the Exit questions\n         * @param exitItemTag {String} String containing the Tag of this block's Exit question.\n         */\n\n\n        initLib: function(blockDataString, blockId, columns, idData, exitQuestions, exitItemTag) {\n            //var blockDataString = Qualtrics.SurveyEngine.getEmbeddedData(QRTE.blockDataField),\n            //columns = Qualtrics.SurveyEngine.getEmbeddedData(QRTE.columnsField),\n            //idData = Qualtrics.SurveyEngine.getEmbeddedData(QRTE.idField);\n            var glue;\n            QRTE.fixSetEmbeddedDataBug();\n            //Initialise block Data\n            if (blockDataString === undefined columnData || blockDataString === '') {\n                blockDataString = '{}';\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.blockDataField, blockDataString);\n            }\n\n            this.BDCache = QRTEController.loadBlockData(blockDataString);\n\n            if (this.BDCache.QRTLib_currentBlock !== blockId) {\n                //If this is a new block, initialise a new block\n                this.BDCache = {\n                    QRTLib_currentBlock: blockId,\n                    QRTLib_blockCounter: 1,\n                    QRTLib_trialColumns: {}\n                };\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.blockDataField, Object.toJSON(this.BDCache));\n                if (exitQuestions === null) {exitQuestions = '';}\n                glue = '';\n                if (exitQuestions !== '') {\n                    glue = ';';\n                }\n                //And update the exit questions\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.exitQuestions, exitQuestions + glue + exitItemTag);\n\n            }\n            QRTE.TDCache = Object.toJSON(QRTE.getBlockData('QRTLib_trialColumns')).evalJSON();\n            if (columns === undefined || columns === null || columns === '') {\n                columns = '{}';\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.columnsField, columns);\n            }\n            QRTE.SDCache[QRTE.columnsField] = columns.evalJSON();\n            if (idData === undefined || idData === null || idData === '') {\n                idData = '{}';\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.idField, idData);\n            }\n            QRTE.idCache = idData.evalJSON();\n        },\n\n        /**\n         * Init initializes the QRTEngine, expects are params object with possible fields defined with parameters.\n         * @method Init\n         * @param paramObj {Object} object containing parameters of Init function\n         *  @param paramObj.blockData {String} blockData string in json format (from embedded data)\n         *  @param paramObj.columnData {String} columnData string in json format (from embedded data)\n         *  @param paramObj.exitQuestions {String} exitQuestions string (from embedded data)\n         *  @param paramObj.exitItemTag {String} Tag of the Exit question of this block\n         *  @param paramObj.blockId {String} Identificaton of the block\n         *  @param [paramObj.onLoadFn] {Function} Function to be called when this Question is displayed\n         *  @param [paramObj.interTrialDelay] {Integer|Array} Specify millisecond delay between end of previous trial and beginning of new trial\n         *  @param [paramObj.preTrialDelay] {Integer|Array} Specify millisecond (ms) delay before the start of the first trial of the block. //NYI\n         *  @param [paramObj.initQuestionIndex] {Integer} Specify index of the Init question in the Question Block (defaults to 1)\n         *  @param [paramObj.waitForImages] {Boolean} Specify whether we should wait for images or not. Is on by default, but could be turned off if all images are pre-loaded in cache, or are very small in general.\n         */\n        Init: function(paramObj) {\n            var validationArray, qArray, initIndex;\n            //init the library\n            QRTE.init();\n\n            //set the initIndex (if the Init question is not the first question of the block)\n            QRTE.initIndex = paramObj.initQuestionIndex - 1 || 0;\n\n\n            validationArray = [{\n                name: 'blockData',\n                type: ['JSON', 'Empty'],\n                required: true\n            }, {\n                name: 'columnData',\n                type: ['JSON', 'Empty'],\n                required: true\n            }, {\n                name: 'idData',\n                type: ['JSON', 'Empty'],\n                required: true\n            }, {\n                name: 'blockId',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'onLoadFn',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'interTrialDelay',\n                type: ['Integer', 'Array'],\n                required: false\n            }, {\n                name: 'exitQuestions',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'exitItemTag',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'waitForImages',\n                type: ['Boolean'],\n                required: false\n            }];\n\n            //Validate Parameter Object, outputs stuff to console\n            QRTE.validateParams(paramObj, validationArray, 'Init');\n\n\n            //Initialize the library itself (necessary for each trial)\n            QRTE.initLib(paramObj.blockData, paramObj.blockId, paramObj.columnData, paramObj.idData, paramObj.exitQuestions, paramObj.exitItemTag);\n\n\n            if (paramObj.waitForImages !== undefined) {\n                QRTE.waitForImageLoad = paramObj.waitForImages;\n            }\n            //calculate server communication delay\n            QRTE.setTrialData('InitPre[OnsetTime]', QRTE.getBlockData('QRTLib_previousStorageDone'));\n\n            QRTE.setTrialData('InitPre[OffsetTime]', window.requestAnimationFrame.now());\n            QRTE.setTrialData('InitPre[CalculatedDuration]', QRTE.getTrialData('InitPre[OffsetTime]') - QRTE.getTrialData('InitPre[OnsetTime]'));\n            QRTE.setTrialData('Init[OnsetTime]', window.requestAnimationFrame.now());\n\n\n\n            Qualtrics.SurveyEngine.addOnload(function() {\n                this.qHTML = document.getElementById(this.questionId);\n                this.QRTLib_isActive = false;\n                this.hideChoices();\n                this.proceed = QRTE.proceed;\n                this.QRTLibId = 'InitPost';\n\n                paramObj.onLoadFn.apply(this);\n                var QuestionStackElement = {\n                    questionElement: this,\n                    onShowFunc: function() {},\n                    type: 'Stimulus',\n                    loadConfig: true,\n                    id: 'InitPost',\n                    conditional: function() {\n                        return true;\n                    },\n                    proceedOnHide: true\n\n                };\n                QRTE.setConfig(QuestionStackElement.id, 'duration', 0);\n                QRTE.postInitElement = QuestionStackElement;\n                QRTE.questionQueue.push(QuestionStackElement);\n            });\n\n            if (paramObj.interTrialDelay instanceof Array) {\n                paramObj.interTrialDelay = paramObj.interTrialDelay[Math.floor(Math.random() * paramObj.interTrialDelay.length)];\n            }\n            QRTE.setTrialData(paramObj.blockId + '[InterTrialDelay]', paramObj.interTrialDelay);\n            if (paramObj.interTrialDelay > 0) {\n                QRTE.setBlockData('QRTLib_intraTrialDelay', paramObj.interTrialDelay);\n            } else {\n                QRTE.setBlockData('QRTLib_intraTrialDelay', -1);\n            }\n        },\n\n        /**\n         * Create a Stimulus question\n         * @method Stimulus\n         * @param paramObj {Object}\n         *  @param paramObj.id {String} Id of the Question\n         *  @param paramObj.onShowFn {Function} Function to be called upon showing the question (not the same as upon loading)\n         *  @param [paramObj.conditional] {Function} Function to be called with which to decide whether to present this question or not, should return a boolean.\n         *  @param [paramObj.loadConfig] {Boolean} Load predefined config for this question (defaults to true)\n         *  @param [paramObj.stimContinue] {Boolean} Continue looking for stimuli after having seen this one, only if set to true (defaults to false)\n         *  @param [paramObj.onKeyPress] {Function} Function to be called upon receiving a key press while this Question is active (called next to onAllowableKey or onCorrectKey)\n         *  @param [paramObj.onAllowableKey] {Function} Function to be called upon receiving a key press on a key defined as 'allowable' \n         *  @param [paramObj.onCorrectKey] {Function} Function to be called upon receiving a key press on a key defined as 'correct'\n         *  @param [paramObj.onIncorrectKey] {Function} Function to be called upon receiving an allowable key that is not defined as correct (only if correct responses are defined)\n         *  @param [paramObj.proceedOnHide] {Boolean} Set whether all currently displayed elements should be removed on hide, or if only this should be removed from display (Defaults to True). This allows the user to decouple presentation of a stimulus from proceeding of a slide.\n         *  @param [paramObj.onHideFn] {Function} Function to be called upon Stimulus being hidden\n         *  @param [paramObj.duringDisplayFn] {Function} Function to be called during each frame that the Stimulus is being displayed\n         \n         */\n        Stimulus: function(paramObj) {\n            var validationArray = [{\n                name: 'id',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'onShowFn',\n                type: ['Function'],\n                required: true\n            }, {\n                name: 'conditional',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'loadConfig',\n                type: ['Boolean'],\n                required: false\n            }, {\n                name: 'duringDisplayFn',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'continue',\n                type: ['Boolean'],\n                required: false\n            }, {\n                name: 'onAllowableKey',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'onCorrectKey',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'onKeyPress',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'onIncorrectKey',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'proceedOnHide',\n                type: ['Boolean'],\n                required: false\n            }, {\n                name: 'onHideFn',\n                type: ['Function'],\n                required: false\n            }];\n\n            //Validate Parameter Object, outputs stuff to console\n            QRTE.validateParams(paramObj, validationArray, 'Stimulus');\n\n\n            if (paramObj.conditional === undefined) {\n                paramObj.conditional = function() {\n                    return true;\n                };\n            }\n            if (paramObj.loadConfig === undefined) {\n                paramObj.loadConfig = true;\n            }\n\n            if (paramObj.stimContinue === undefined) {\n                paramObj.stimContinue = false;\n            }\n\n            if (paramObj.proceedOnHide === undefined) {\n                paramObj.proceedOnHide = true;\n            }\n            Qualtrics.SurveyEngine.addOnload(function() {\n                this.QRTLib_isActive = false;\n                this.proceed = QRTE.proceed;\n                this.QRTLibId = paramObj.id;\n                var QuestionStackElement = {\n                    questionElement: this,\n                    onShowFunc: paramObj.onShowFn,\n                    duringDisplayFn: paramObj.duringDisplayFn,\n                    onHideFn: paramObj.onHideFn,\n                    type: 'Stimulus',\n                    loadConfig: paramObj.loadConfig,\n                    id: paramObj.id,\n                    conditional: paramObj.conditional,\n                    stimContinue: paramObj.stimContinue,\n                    onAllowableKey: paramObj.onAllowableKey,\n                    onCorrectKey: paramObj.onCorrectKey,\n                    onKeyPress: paramObj.onKeyPress,\n                    onIncorrectKey: paramObj.onIncorrectKey,\n                    proceedOnHide: paramObj.proceedOnHide\n                };\n                QRTE.questionQueue.push(QuestionStackElement);\n            });\n        },\n\n        /**\n         * Exit denotes the end of the block. Important for the initialization phase and the exit phase.\n         * Make the question a Form question with precisely 2 answer fields (more is unnecessary, those will get ignored)\n         * @method Exit\n         */\n        Exit: function() {\n\n\n            qArray = $('Questions').getElementsByClassName('QuestionOuter');\n            for (var i = 0; i < qArray.length && i < QRTE.initIndex + 1; i += 1) {\n                qArray[i].style.display = 'block';\n            }\n            Qualtrics.SurveyEngine.addOnload(function() {\n                //Hide all choice\n                this.hideChoices();\n                //display the question\n                //this.questionContainer.style.display = 'none';\n                var QuestionStackElement, onShowFn;\n                onShowFn = function() {\n\n                    //Create and/or store standard information about the trial\n                    var blockId = QRTE.getBlockData('QRTLib_currentBlock'),\n                        tempTD = {},\n                        key,\n                        i;\n\n                    QRTE.setBlockData('QRTLib_previousEndTime', window.requestAnimationFrame.now());\n                    QRTE.setTrialData(blockId + '[TrialNr]', QRTE.getBlockData('QRTLib_blockCounter'));\n                    QRTE.setTrialData(blockId + '[RefreshPeriod]', QRTE.refreshPeriod);\n                    QRTE.setTrialData('BlockId', blockId);\n                    QRTE.setTrialData('EngineType', window.requestAnimationFrame.method);\n                    QRTE.setTrialData('Exit[OnsetTime]', window.requestAnimationFrame.now());\n                    QRTE.setTrialData('QRTEngine[Version]', QRTE.version);\n\n                    //CHECK IF ATLEAST TWO FORM FIELDS HAVE BEEN DEFINED\n                    this.setChoiceValue(2, 'testtest');\n                    if (this.getChoiceValue(2) !== 'testtest') {\n                        //alert('You need to define two answer form fields in the Exit question!!');\n                    }\n\n                    for (key in QRTE.TDCache) {\n                        if (QRTE.TDCache.hasOwnProperty(key) && key !== '') {\n                            //Change QID thingies to entered ID's, also force every value to a string so that the Parser handles high numerical values correctly\n                            tempTD[QRTE.getOutputKey(key)] = String(QRTE.TDCache[key]);\n                        }\n                    }\n\n                    this.setChoiceValue(1, Object.toJSON(tempTD));\n                    this.setChoiceValue(2, blockId);\n                    if (QRTE.SDCache[QRTE.columnsField][blockId] === undefined) {\n                        QRTE.SDCache[QRTE.columnsField][blockId] = [];\n                    }\n                    for (i = 0; i < QRTE.newlyAddedColumns.length; i += 1) {\n                        QRTE.SDCache[QRTE.columnsField][blockId].push(QRTE.getOutputKey(QRTE.newlyAddedColumns[i]));\n                    }\n\n                    QRTE.setSurveyData(QRTE.columnsField, Object.toJSON(QRTE.SDCache[QRTE.columnsField]));\n                    QRTE.setBlockData('QRTLib_blockCounter', QRTE.getBlockData('QRTLib_blockCounter') + 1);\n                    QRTE.setBlockData('QRTLib_previousStorageDone', window.requestAnimationFrame.now());\n                    QRTE.saveBlockData();\n\n                    //If wanting to test, uncomment this line and comment the one after that to enforce manual nextbutton clicks\n                    //$('NextButton').style.display = 'block';\n                    //QRTE.submitPage();\n                    QRTEController.loadNextTrial();\n                };\n\n                QuestionStackElement = {\n                    questionElement: this,\n                    onShowFunc: onShowFn,\n                    type: 'Storage',\n                    loadConfig: true,\n                    conditional: function() {\n                        return true;\n                    }\n                };\n                QRTE.questionQueue.push(QuestionStackElement);\n\n                QRTE.startTrial(0);\n\n            });\n\n            QRTE.loadWaitingList = [false];\n            if (QRTE.waitForImageLoad === true) {\n                //set wait for image load queues.\n                var loadIndex = 1,\n                    images = $$('.QuestionOuter img'),\n                    i = 0;\n\n                var l = images.length;\n                for (; i < l; i += 1) {\n                    images[i].observe('load', function(e) {\n                        QRTE.startTrial(e.path[0].QRTELoadIndex);\n                    })\n                    images[i].QRTELoadIndex = i + 1;\n                    QRTE.loadWaitingList[i + 1] = false;\n                }\n\n            }\n\n        },\n\n        /**\n         * Remove the padding Qualtrics adds between Questions (causes question presentation to drift downwards if not called).\n         * DEPRECATED: Separators hidden through CSS now\n         * @method removeSeparators\n         * @private\n         */\n        removeSeparators: function() {\n            var questionElement = document.getElementById('Questions'),\n                index;\n            for (index = 0; index < questionElement.children.length; index += 1) {\n                if (questionElement.children[index].className === \"Separator\") {\n                    questionElement.children[index].parentNode.removeChild(questionElement.children[index]);\n                }\n            }\n        },\n        /**\n         * Notifies the engine the first trial is ready to be started. Called at the end of the 'exit' question\n         * @private\n         * @method startTrial\n         */\n        startTrial: function(startId) {\n            var duringDisplayFn, onHideFn, onDisplayFn, serverCommDelay, remainingDelay;\n            //All questions have been hidden, so display the parent block again\n            //$('Questions').style.display = 'block';\n\n            QRTE.loadWaitingList[startId] = true;\n            if (!QRTE.loadWaitingList.every()) {\n                QRTE.log('Process ' + startId + 'finished, waiting for other processes to finish')\n                return;\n            }\n\n            //Save the absolute time of when onLoad part of library was finished\n            serverCommDelay = window.requestAnimationFrame.now() - QRTE.getBlockData('QRTLib_previousEndTime'); //Calculate the remaining time based on the lib initialization + server delay times\n            remainingDelay = QRTE.getBlockData('QRTLib_intraTrialDelay') - serverCommDelay;\n\n\n            if (isNaN(remainingDelay)) {\n                remainingDelay = QRTE.getBlockData('QRTLib_intraTrialDelay') * 3;\n                //If this init call is the first one of the block (first trial), calculate the estimated refreshdelay during the pre-trial interval\n                onDisplayFn = function(ele, time) {\n                    QRTE.setTrialData('Init[OffsetTime]', ele.displayOnsetTime);\n                    QRTE.setTrialData('Init[CalculatedDuration]', ele.displayOnsetTime - QRTE.getTrialData('Init[OnsetTime]'));\n                    QRTE.refreshPeriodEstimationStack = [];\n                };\n                duringDisplayFn = function(ele, time) {\n                    //Get current time, required for \n                    QRTE.refreshPeriodEstimationStack.push(time);\n                };\n                onHideFn = function(ele, timestamp) {\n                    var diffs = [];\n\n                    for (i = 1; i < QRTE.refreshPeriodEstimationStack.length; i += 1) {\n                        diffs[i - 1] = QRTE.refreshPeriodEstimationStack[i] - QRTE.refreshPeriodEstimationStack[i - 1];\n                    }\n                    QRTE.refreshPeriod = QRTE.median(diffs);\n                    QRTE.log('Estimated refresh delay = ' + QRTE.refreshPeriod);\n                    QRTE.setBlockData('QRTE_refreshPeriod', QRTE.refreshPeriod);\n                    QRTE.referenceTime = timestamp;\n                    QRTE.framesSinceReference = 0;\n                };\n            } else {\n                onDisplayFn = function(ele, time) {\n                    QRTE.setTrialData('Init[OffsetTime]', ele.displayOnsetTime);\n                    QRTE.setTrialData('Init[CalculatedDuration]', ele.displayOnsetTime - QRTE.getTrialData('Init[OnsetTime]'));\n                };\n\n                QRTE.refreshPeriod = QRTE.getBlockData('QRTE_refreshPeriod');\n            }\n\n            //QRTE.setTrialData('ITI[Duration]', (remainingDelay > 0) ? remainingDelay : 0);\n            QRTE.initTime = window.requestAnimationFrame.now();\n\n            QRTE.postInitElement.onHideFn = onHideFn;\n            QRTE.postInitElement.onDisplayFn = onDisplayFn;\n            QRTE.postInitElement.duringDisplayFn = duringDisplayFn;\n            QRTE.setConfig('InitPost', 'duration', (remainingDelay > 0) ? remainingDelay : 0);\n            //UNCOMMENT\n            //QRTE.setConfig('InitPost', 'duration', (remainingDelay > 0) ? remainingDelay : Infinity);\n            QRTE.inited = true;\n\n            //Set initial trial data related to loading of this trial\n            QRTE.setTrialData('InitServerComm[Onset]', QRTE.getBlockData('ServerCommOnset'));\n            QRTE.setTrialData('InitServerComm[Offset]', QRTE.getBlockData('ServerCommOffset'));\n            QRTE.setTrialData('InitServerComm[CalculatedDuration]', QRTE.getBlockData('ServerCommOffset') - QRTE.getBlockData('ServerCommOnset'));\n\n            //<Load next trial here>\n            var currentLoops = '${lm://CurrentLoopNumber}',\n                totalLoops = '${lm://TotalLoops}';\n            //Check if last trial, currentloops === totalLoops;\n            QRTEController.requestNextTrial(currentLoops !== '' && currentLoops === totalLoops);\n\n            QRTE.proceed();\n        },\n\n\n\n        proceed: function() {\n            QRTE.log(\"proceed called after \" + window.requestAnimationFrame.now() - QRTE.initTime);\n            QRTE.hideAllElements();\n        },\n\n        proceedPage: function() {\n            var currentQ;\n            QRTE.log(\"Proceeding page..\");\n            while (QRTE.currentPageQuestions.length > 0) {\n                currentQ = QRTE.currentPageQuestions.shift();\n\n                //Disable\n                currentQ.questionElement.QRTLib_isActive = false;\n            }\n\n\n            //Go to next question\n            QRTE.showNextPage();\n        },\n\n        disableQuestion: function(disableQ) {},\n\n        /**\n         * Determine and show the next page/slide\n         * @private\n         * @method showNextPage\n         */\n        showNextPage: function() {\n            var continueSearch = true,\n                shownQ = false,\n                nextQ,\n                shown;\n            while (continueSearch === true) {\n                continueSearch = false;\n                nextQ = QRTE.questionQueue.shift();\n                if (nextQ !== undefined && (nextQ.type === 'Stimulus' || nextQ.type === 'Storage')) {\n                    QRTE.currentPageQuestions.push(nextQ);\n                    shown = QRTE.showStimulusQuestion.apply(nextQ.questionElement, [nextQ]);\n\n                    if (nextQ.stimContinue) {\n                        continueSearch = true;\n                        if (shown === true) {\n                            shownQ = true;\n                        }\n                    }\n                    QRTE.log('shown ' + nextQ.id + ': ' + shown);\n                    QRTE.log('continue ' + nextQ.id + ': ' + continueSearch);\n                    if (shown === false && shownQ === false) {\n                        continueSearch = true;\n                    }\n                }\n            }\n\n        },\n\n        /**\n         * Show Question\n         * Handles the activation of that question, which includes:\n         * The loading of the configuration (duration, allowable keys etc).\n         * Sets the event handler to respond to any key presses during the event.\n         * @private\n         * @method showStimulusQuestion\n         * @param question {Object} question to be shown.\n         *  @param id {String} Id of question.\n         *  @param onShowFunc {Function} Function to be called when showing question\n         *  @param loadConfig {Boolean} If true, config is loaded from the current block data (which has been defined elsewhere)\n         *  @param questionElement {Object} This Qualtrics question element\n         *  @param duringDisplayFn {Function} Function to be called each frame that the question is presented\n         */\n        showStimulusQuestion: function(question) {\n            //Save the loading start time\n            //QRTE.setTrialData(question.questionElement.QRTLibId + '[LoadStartTime]', window.requestAnimationFrame.now());\n            //Set mapping of the QID -> QRTE Id\n            QRTE.setId(this, question.id);\n\n            //Initialize variables\n            var stimulusShown = false,\n                questionScope = this,\n                dispEle;\n            QRTE.log(question);\n\n            //Check whether question should be shown or not, if not skip to the next question (implicitly)\n            if (question.conditional() === true) {\n                this.QRTLib_isActive = true;\n\n\n                if (question.loadConfig === true) {\n                    //Load the Configuration of the Question, important!\n                    QRTE.loadConfig(this);\n                }\n\n                //Check if KeyPress listener is required (one or more of the following fields are defined: onKeyPress, onCorrectKey or onAllowableKey)\n                //If so, add keypress listener.\n                if (question.onKeyPress !== undefined || question.questionElement.allowable !== '' || question.questionElement.cresp !== '') {\n                    //Initialize the fields used for storing data about RT timing.\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[RTTime]', '');\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[RT]', '');\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[RESP]', '');\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[ACC]', 0);\n\n                    //Add the key listener\n                    QRTE.addKeyListener(function(e) {\n\n                        //Get the Key of the response\n                        var RT, RESP = QRTE.keycode2string(e),\n                            RTTime = window.requestAnimationFrame.now();\n                        RT = RTTime - QRTE.getTrialData(question.questionElement.QRTLibId + '[OnsetTime]');\n\n                        //Store the Time of the Key Press and calculate the RT and ACC if correct\n\n                        if ((QRTE.isAllowableResponse(question.questionElement, RESP) || QRTE.isCorrectResponse(question.questionElement, RESP)) && QRTE.getTrialData(question.questionElement.QRTLibId + '[RTTime]') === '') {\n                            QRTE.setTrialData(question.questionElement.QRTLibId + '[RTTime]', RTTime);\n                            QRTE.setTrialData(question.questionElement.QRTLibId + '[RT]', RT);\n                            QRTE.setTrialData(question.questionElement.QRTLibId + '[RESP]', RESP);\n                            if (QRTE.isCorrectResponse(question.questionElement, RESP)) {\n                                QRTE.saveAcc(question.questionElement, 1);\n                            } else {\n                                QRTE.saveAcc(question.questionElement, 0);\n                            }\n                        }\n\n                        //Store the RT and the Response\n\n                        //Set Handling Key Press to true, this lets the engine know that a keypress is currently being handled. Necessary when there is a timer (response deadline)\n                        question.handlingKeyPress = true;\n\n                        if (question.onCorrectKey !== undefined && QRTE.isCorrectResponse(question.questionElement, RESP)) {\n                            question.onCorrectKey.apply(question.questionElement, [e, RESP]);\n                        } else if (question.onIncorrectKey !== undefined && QRTE.isAllowableResponse(question.questionElement, RESP)) {\n                            question.onIncorrectKey.apply(question.questionElement, [e, RESP]);\n                        }\n\n                        if (question.onAllowableKey !== undefined && QRTE.isAllowableResponse(question.questionElement, RESP)) {\n                            question.onAllowableKey.apply(question.questionElement, [e, RESP]);\n                        }\n\n                        if (question.onKeyPress !== undefined) {\n                            question.onKeyPress.apply(question.questionElement, [e, RESP]);\n                        }\n\n                        if (question.questionElement.endAction === 'TERMINATE') {\n                            //Proceed to the next Question Page if the response is allowable\n                            if (QRTE.isAllowableResponse(question.questionElement, RESP) && question.questionElement.QRTLib_isActive === true) {\n                                question.questionElement.proceed();\n                            }\n                        }\n                        question.handlingKeyPress = false;\n\n                    }, this);\n                }\n\n                //Build the display Element. Stimuli Questions have to take into account the possibility of being associated with a key press. \n                //OnDisplayFn therefore logs the displayOnsetTime, so that the RT can be calculated.\n                dispEle = {\n                    el: this.questionContainer,\n                    duration: this.duration,\n                    delay: this.offset,\n                    duringDisplayFn: question.duringDisplayFn,\n                    onDisplayFn: function(displayEl, timestamp) {\n                        if (question.onDisplayFn !== undefined) {\n                            question.onDisplayFn(displayEl, timestamp);\n                        }\n                        QRTE.setTrialData(questionScope.QRTLibId + '[OnsetTime]', displayEl.displayOnsetTime);\n                    },\n                    proceedOnHide: question.proceedOnHide,\n                    id: question.id\n                };\n\n                //Set the OnHide Function\n                dispEle.onHideFn = function(displayEl, timestamp) {\n                    if (question.onHideFn !== undefined) {\n                        question.onHideFn(displayEl, timestamp);\n                    }\n                    QRTE.setTrialData(questionScope.QRTLibId + '[OffsetTime]', displayEl.displayOffsetTime);\n                    QRTE.setTrialData(questionScope.QRTLibId + '[CalculatedDuration]', displayEl.displayDuration);\n                };\n\n\n                this.QRTLib_timer = QRTE.displayElement(dispEle);\n\n                question.onShowFunc.apply(this);\n\n                stimulusShown = true;\n            }\n\n            //QRTE.setTrialData(question.questionElement.QRTLibId + '[LoadEndTime]', window.requestAnimationFrame.now());\n            return stimulusShown;\n        },\n\n        setId: function(question, desc) {\n\n            this.idCache[question.questionId] = desc;\n            question.qId = desc;\n\n            Qualtrics.SurveyEngine.setEmbeddedData(QRTE.idField, Object.toJSON(this.idCache));\n        },\n\n        getOutputKey: function(key) {\n            var oldKey;\n            for (oldKey in this.idCache) {\n                if (this.idCache.hasOwnProperty(oldKey) && oldKey === key.substring(0, oldKey.length)) {\n\n                    return QRTE.getBlockData('QRTLib_currentBlock') + this.idCache[oldKey] + key.substring(oldKey.length, key.length);\n                }\n            }\n            return key;\n        },\n\n\n        OnKeyPress: function(fn, qScope) {\n\n            qScope = qScope || window;\n\n            var keyFn = function(e) {\n                QRTE.setTrialData(qScope.QRTLibId + '[RTTime]', window.requestAnimationFrame.now());\n                var RT = QRTE.getTrialData(qScope.QRTLibId + '[RTTime]') - QRTE.getTrialData(qScope.QRTLibId + '[OnsetTime]');\n                QRTE.setTrialData(qScope.QRTLibId + '[RT]', RT);\n                QRTE.setTrialData(qScope.QRTLibId + '[RESP]', QRTE.keycode2string(e));\n                QRTE.log(qScope);\n                fn.apply(qScope, [e]);\n            }\n\n            QRTE.addKeyListener(keyFn, qScope);\n        },\n\n        addKeyListener: function(fn, listenerScope) {\n            Event.observe(document, 'keypress', function(e) {\n                if (listenerScope.QRTLib_isActive === true) {\n                    fn.apply(listenerScope, [e]);\n                }\n            });\n        },\n\n        /*  \n         **************Methods below this line are support methods*******************\n         */\n\n        hideQuestions: function() {\n            qArray = $('Questions').getElementsByClassName('QuestionOuter');\n            for (var i = 0; i < qArray.length; i += 1) {\n                qArray[i].style.display = 'none';\n            }\n        },\n\n        unhideQuestions: function() {\n            //Redisplay outer questions\n            qArray = $('Questions').getElementsByClassName('QuestionOuter');\n            for (var i = 0; i < qArray.length; i += 1) {\n                qArray[i].style.display = 'block';\n            }\n            //Redisplay separators\n            qArray = $('Questions').getElementsByClassName('Separator');\n            for (var i = 0; i < qArray.length; i += 1) {\n                qArray[i].style.display = 'block';\n            }\n\n\n        },\n\n        _handleKeyPressEvent: function() {\n\n        },\n\n        _setConfig: function(QID, option, value, setterFunc) {\n            var qidString = QID;\n            if (typeof QID !== 'string') {\n                qidString = QID.questionId;\n            }\n            option = option.toLowerCase();\n\n            switch (option) {\n                case 'duration':\n                    if (value instanceof Array) {\n                        value = value[Math.floor(Math.random() * value.length)];\n                    }\n                    setterFunc.apply(this, [qidString, 'Duration', value]);\n                    break;\n                case 'allowable':\n                    setterFunc.apply(this, [qidString, 'Allowable', value]);\n                    break;\n                case 'cresp':\n                    setterFunc.apply(this, [qidString, 'CRESP', value]);\n                    break;\n                case 'delay':\n                    setterFunc.apply(this, [qidString, 'Offset', value]);\n                    break;\n                case 'endaction':\n                    setterFunc.apply(this, [qidString, 'EndAction', value]);\n                    break;\n                default:\n                    QRTE.log('No such configuration: ' + option);\n                    break;\n            }\n        },\n        getDuration: function(question) {\n            var duration = Infinity,\n                edDuration = this.getTrialData(question.QRTLib_configId + '[Duration]');\n            if (edDuration !== undefined && edDuration !== '' && !isNaN(edDuration)) {\n                duration = edDuration;\n            }\n            if (question._Duration !== undefined && question._Duration !== '' && !isNaN(question._Duration)) {\n                duration = question._Duration;\n            }\n\n            return duration;\n        },\n        getAllowable: function(question) {\n            var allowable = \"\",\n                edAllowable = this.getTrialData(question.QRTLib_configId + '[Allowable]');\n            if (edAllowable !== undefined) {\n                allowable = edAllowable;\n            }\n            if (question._Allowable !== undefined) {\n                allowable = question._Allowable;\n            }\n\n            if (allowable === '{ANY}') {\n                allowable = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890-=[]\\\\;',./`\";\n            }\n            //allowable = allowable.toUpperCase();\n            return allowable;\n        },\n        getCResp: function(question) {\n            var cresp = '',\n                edcresp = this.getTrialData(question.QRTLib_configId + '[CRESP]');\n            if (edcresp !== undefined) {\n                cresp = edcresp;\n            }\n            if (question._cresp !== undefined) {\n                cresp = question._CRESP;\n            }\n\n            if (cresp === '{ANY}') {\n                cresp = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890-=[]\\\\;',./`\";\n            }\n            //cresp = cresp.toUpperCase();\n\n            return cresp;\n        },\n\n        getOffset: function(question) {\n            var offset = 0,\n                edOffset = this.getTrialData(question.QRTLib_configId + '[Offset]');\n            if (edOffset !== undefined && edOffset !== '' && !isNaN(edOffset)) {\n                offset = edOffset;\n            }\n            if (question._Offset !== undefined && question._Offset !== '' && !isNaN(question._Offset)) {\n                offset = question._Offset;\n            }\n\n            return offset;\n\n        },\n\n        getEndAction: function(question) {\n            var endAction = 'NONE',\n                edEndAction = this.getTrialData(question.QRTLib_configId + '[EndAction]');\n            if (edEndAction !== undefined && edEndAction !== '') {\n                endAction = edEndAction;\n            }\n            if (question._EndAction !== undefined && question._EndAction !== '') {\n                endAction = question._EndAction;\n            }\n\n            return endAction;\n\n        },\n        evaluateConditional: function(conditional) {\n            QRTE.log('Conditional: ', conditional);\n            return conditional === '' || conditional();\n        },\n        log: function() {\n            if (QRTE.debug === true) {\n                for (var i = 0; i < arguments.length; i += 1) {\n                    console.log(arguments[i]);\n                }\n            }\n        },\n\n        median: function(values) {\n\n            values.sort(function(a, b) {\n                return a - b;\n            });\n\n            var half = Math.floor(values.length / 2);\n\n            if (values.length % 2) return values[half];\n            else return (values[half - 1] + values[half]) / 2.0;\n        },\n\n        waitForKey: function(question, keys) {\n            Event.observe(document, 'keypress', function(e) {\n                var resp = QRTE.keycode2string(e);\n                if (keys.indexOf(resp) >= 0) {\n                    question.clickNextButton();\n                }\n            });\n        },\n\n        validateParams: function(paramObj, validationArray) {\n            var valObj, val, index, typeCheck = true,\n                indexType;\n            //Loop over validationArray to check whether parameters suffice\n            for (index = 0; index < validationArray.length; index += 1) {\n                valObj = validationArray[index];\n                if (paramObj[valObj.name] === undefined && valObj.required === true) {\n                    alert('Required parameter: ' + valObj.name + ' seems to be missing');\n                    QRTE.log('Required parameter: ' + valObj.name + ' seems to be missing');\n                    break;\n                }\n\n                val = paramObj[valObj.name];\n\n                //Loop over type checkers\n                for (indexType = 0; indexType < valObj.type.length; indexType += 1) {\n                    typeCheck = QRTE.validateType(val, valObj.type[indexType]);\n                    if (typeCheck === true) {\n                        break;\n                    }\n                }\n                if (typeCheck === false && valObj.required === true) {\n                    alert('Parameter: ' + valObj.name + ' is of the wrong type, expected type: ' + valObj.type + ', type received: ' + (typeof val) + \"\\n\" + \"Please open the console for detailed error messages\");\n                    QRTE.log('Parameter: ' + valObj.name + ' is of the wrong type, expected type: ' + valObj.type + ', type received: ' + (typeof val));\n                    QRTE.log('Faulty parameter ' + valObj.name + ': ', val);\n                    QRTE.log('Proper functioning of QRTE is no longer guaranteed, please fix the above error');\n                }\n\n            }\n        },\n\n        validateType: function(val, type) {\n            switch (type) {\n                case 'JSON':\n                    return val.isJSON();\n                case 'String':\n                    return (typeof val === 'string' || val instanceof String);\n                case 'Number':\n                    return (!isNaN(parseFloat(val)) && isFinite(val));\n                case 'Array':\n                    return val instanceof Array;\n                case 'Object':\n                    return typeof val === 'object';\n                case 'Function':\n                    return typeof val === 'function';\n                case 'Boolean':\n                    return (val === true || val === false);\n                case 'Empty':\n                    return val === '';\n                default:\n                    return false;\n            }\n        },\n\n        fixSetEmbeddedDataBug: function() {\n            Qualtrics.SurveyEngine.setEmbeddedData = function(key, value) {\n                var fieldName = 'ED~' + key;\n                if ($(fieldName)) {\n                    $(fieldName).value = value;\n                } else {\n                    $('Header').appendChild(QBuilder('input', {\n                        type: 'hidden',\n                        id: fieldName,\n                        name: fieldName,\n                        value: value\n                    }));\n                    Qualtrics.SurveyEngine.setEmbeddedData(key, value);\n                }\n            }\n        },\n\n        //DisplayEngine part\n\n        //Since it's impossible to know when a screen refresh has happened, we assume that the first timestamp is the actual screen refresh.\n        //Based on the difference between the current timestamp Tn and the root timestamp Tn-1, we estimate the amount of frames that have passed since. \n        //Based on the amount of frames we estimate the previous screen refresh. Although not perfect, it's the best we can do.\n\n        refreshRate: 60, //hertz\n        refreshPeriod: 1000 / 60,\n        lastRefresh: 0,\n        currentRefresh: 0,\n        previousTimestamp: 0,\n        referenceTime: 0,\n        framesSinceReference: 0,\n        currentStack: [],\n        proceedOnFrameEnd: false,\n\n        init: function() {\n            window.requestAnimationFrame(QRTE.draw);\n        },\n\n        draw: function(timestamp) {\n            var curEle, newStack = [];\n            timestamp = window.requestAnimationFrame.now();\n\n\n            if (timestamp < 1e12) {\n                timestamp += window.performance.timing.navigationStart;\n            }\n\n            if (QRTE.referenceTime === 0) {\n                QRTE.referenceTime = timestamp;\n                QRTE.previousTimestamp = timestamp;\n                QRTE.framesSinceReference = 0;\n            } else {\n                //QRTE.framesSinceReference += QRTE.calcFrames(QRTE.referenceTime, timestamp);\n                QRTE.prevFrames = QRTE.framesSinceReference;\n                //frameDiff =  QRTE.calcFrames(QRTE.referenceTime, timestamp) - QRTE.prevFrames;\n                QRTE.framesSinceReference = QRTE.calcFrames(QRTE.referenceTime, timestamp);\n            }\n            QRTE.currentRefresh = (QRTE.framesSinceReference * QRTE.refreshPeriod) + QRTE.referenceTime;\n            QRTE.projectedRefresh = QRTE.currentRefresh + QRTE.refreshPeriod;\n            curEle = QRTE.currentStack.shift();\n\n            while (curEle) {\n                curEle.keep = true;\n\n                //Call duringDisplay callback function, with the current element and the timestamp as arguments.\n                if (curEle.shown === true && typeof curEle.duringDisplayFn === 'function') {\n                    curEle.duringDisplayFn(curEle, timestamp);\n                }\n\n                if (QRTE.proceedOnFrameEnd === true || curEle.hide === true || (curEle.shown === true && curEle.displayOnset !== undefined && (curEle.displayOnset + curEle.duration < QRTE.projectedRefresh))) {\n                    //If the next refresh makes it go beyond the duration, hide the element again!\n                    curEle = QRTE.hideSingleEle(curEle, timestamp);\n                } else if (curEle.shown === false && curEle.requestedAt + curEle.delay < QRTE.projectedRefresh) {\n                    curEle = QRTE.dispSingleEle(curEle, timestamp);\n                }\n\n                if (curEle.keep === false && curEle.proceedOnHide === true) {\n                    //Behold! We have found an element that commands us to proceed to the next page.\n                    QRTE.proceedOnFrameEnd = true;\n                    //Every element that has been processed so far needs to be re-processed (sadly), so that they properly hide.\n                    for (var ind = 0; ind < newStack.length; ind += 1) {\n                        if (newStack[ind].hide !== true) {\n                            newStack[ind].hide = true;\n                            QRTE.currentStack.push(newStack[ind]);\n                        }\n                    }\n                } else {\n                    //Push it to the newStack, for it to be processed next time.\n                    newStack.push(curEle);\n                }\n\n                curEle = QRTE.currentStack.shift();\n            }\n            QRTE.currentStack = newStack;\n            QRTE.lastRefresh = QRTE.currentRefresh;\n            QRTE.previousTimestamp = timestamp;\n            window.requestAnimationFrame(QRTE.draw);\n            if ((newStack.length === 0 || QRTE.proceedOnFrameEnd) && QRTE.inited === true) {\n                QRTE.proceedOnFrameEnd = false;\n                QRTE.proceedPage();\n            }\n\n\n        },\n\n        calcFrames: function(previous, current) {\n            var diff = current - previous,\n                frames = 0;\n\n            if (diff < QRTE.refreshPeriod) {\n                frames = 1;\n            } else {\n                frames = Math.floor(diff / QRTE.refreshPeriod);\n                if (diff % QRTE.refreshPeriod >= (QRTE.refreshPeriod * 0.9)) {\n                    frames += 1;\n                }\n            }\n\n            return frames;\n        },\n\n        /**\n         * Display an element for a specified duration with a specified delay. Vsyncs the display duration using requestAnimationFrame (if possible in the browser)\n         * and allows for high-precision control over its duration. Please start any custom attributes for the paramObj with the 'custom_' header, to avoid collisions.\n         * @private\n         * @method displayElement\n         * @param paramObj {Object}\n         *  @param el {Object} HTML element to be displayed\n         *  @param [onHideFn] {Function} Function to be called upon removing the element from display, is passed one argument containing all information about the display element.\n         *  @param [duration] {Number} Number of milliseconds (ms) the element should be displayed.\n         *  @param [delay] {Number} Number of milliseconds (ms) the Engine should wait before displaying the element.\n         *  @param [duringDisplayFn] {Function} Function to be called upon displaying the element for another screen refresh. Careful: Keep this function simple, could seriously hamper performance as it's called about every 16-17 ms.  is passed one argument containing all information about the display element.\n         *  @param [onDisplayfn] {Function} Function to be called upon starting to display the element. Is passed one argument containing all information about the display element.\n         */\n\n        //displayElement: function(el, callback, duration, offset, duringDisplaycb) {\n        displayElement: function(paramObj) {\n            var reqAt,\n                id = String(Math.random());\n            //QRTE.log(arguments);\n            if (paramObj.delay === undefined) {\n                paramObj.delay = 0;\n            }\n\n\n\n            if (paramObj.duration === undefined) {\n                paramObj = Infinity;\n            }\n\n            if (isNaN(QRTE.lastRefresh)) {\n                reqAt = window.requestAnimationFrame.now();\n            } else {\n                reqAt = QRTE.lastRefresh;\n            }\n            paramObj.userId = paramObj.id;\n            paramObj.id = id;\n            paramObj.shown = false;\n            paramObj.requestedAt = reqAt;\n            paramObj.hide = false;\n\n            QRTE.currentStack.push(paramObj);\n            if (paramObj.delay === 0) {\n                //This element needs to be displayed as soon as possible\n                QRTE.dispSingleEle(paramObj, QRTE.previousTimestamp);\n            }\n            QRTE.log('Added element to display stack:', paramObj);\n            //console.log('paramObj: ', paramObj.userId, ', duration: ', paramObj.duration);\n\n            return id;\n        },\n\n        hideElement: function(id) {\n            var found = false,\n                i;\n            for (i = 0; i < QRTE.currentStack.length; i += 1) {\n                if (QRTE.currentStack[i].id === id) {\n                    found = true;\n                    QRTE.currentStack[i].hide = true;\n                    this.log('Element to be hidden: ', QRTE.currentStack[i]);\n                }\n            }\n            return found;\n        },\n\n        hideAllElements: function() {\n            for (i = 0; i < QRTE.currentStack.length; i += 1) {\n                QRTE.currentStack[i].hide = true;\n            }\n            QRTE.proceedOnFrameEnd = true;\n        },\n\n        /**\n         * Hide a DrawEngine Element\n         * @private\n         * @method hideSingleEle\n         * @param curEle {Object}\n         */\n        hideSingleEle: function(curEle, timestamp) {\n            curEle.displayOffset = QRTE.projectedRefresh;\n            curEle.displayOffsetTime = window.requestAnimationFrame.now();\n            curEle.el.style.display = 'none';\n            curEle.keep = false;\n            curEle.hide = true;\n            //delete QRTE.currentStack[key];\n            curEle.displayDuration = curEle.displayOffsetTime - curEle.displayOnsetTime;\n            if (curEle.onHideFn !== undefined) {\n                curEle.onHideFn(curEle, timestamp);\n            }\n\n            return curEle;\n\n        },\n\n\n        /**\n         * Display a DrawEngine Element\n         * @private\n         * @method dispSingleEle\n         * @param curEle {Object}\n         */\n        dispSingleEle: function(curEle, timestamp) {\n            curEle.el.style.display = 'block';\n            curEle.displayOnset = QRTE.projectedRefresh;\n            curEle.displayOnsetTime = window.requestAnimationFrame.now();\n            curEle.shown = true;\n            if (curEle.onDisplayFn !== undefined) {\n                //Added try-catch block to catch the error that's causing the OnsetTime not to get saved.\n                try {\n                    curEle.onDisplayFn(curEle, timestamp);\n                } catch (e) {\n                    QRTE.setTrialData('Error[OnsetError]', JSON.stringify(e));\n                }\n            }\n            return curEle;\n        },\n\n        checkEngineCompatibility: function() {\n            return window.requestAnimationFrame.method === 'native-highres';\n        },\n    };","\n    /* ==========================================================\n     * QRTEngine.js v16\n     * =====================\n    /* ==========================================================\n     * QRTEngine.js v16\n     * ==========================================================\n     * Copyright 2013-2014 Erwin Haasnoot\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     * http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     *\n     *\n     *\n     * ========================================================== */\n    /**\n     * Qualtrics Reaction Time Engine or QRTE is an add-on providing an interface\n     * for easy reaction time experiment creation in the Qualtrics survey research suite (tm).\n     * For instructions on how to use this add-on, see xxxx\n     *\n     * QRTE was developed by Erwin Haasnoot\n     * Email: erwinhaasnoot[at]gmail.com\n     * @class QRTE\n     *\n     */\n    var QRTE = {\n        version: 'v16',\n        columnsField: 'QRTE_columns',\n        blockDataField: 'QRTE_blockData',\n        idField: 'QRTE_idData',\n        exitQuestions: 'QRTE_exitQuestions',\n        inited: false,\n        /**\n         * TDCache contains the Trial-Level Data in an Object. DO NOT directly manipulate this Object. It might cause inconsistencies in the data file and cause unexpected once parsed.\n         * Use QRTE.setTrialData and QRTE.getTrialData instead.\n         *\n         * @property TDCache\n         * @private\n         * @type Object\n         */\n        TDCache: {},\n\n        /**\n         * ColumnCache contains all the mappings from QID to Columns\n         * @property columnCache\n         * @private\n         * @type Object\n         */\n        columnCache: {},\n\n        /**\n         * BDCache contains the BlockLevel Data in an Object. Directly manipulating this Object might cause inconsistencies\n         * @property BDCache\n         * @private\n         * @type Object\n         */\n        BDCache: {},\n\n        /**\n         * SDCache is a cache for speeding up retrieval of Survey level Data,\n         * All Survey data is saved to both Embedded Data and Survey Data\n         * @private\n         * @property SDCache\n         * @type Object\n         */\n        SDCache: {},\n\n        /**\n         * idCache is a cache for quickly retrieving the Qualtrics QID to QRTLib Id mappings.\n         * Saved in the idData embedded data field after every trial.\n         * @private\n         * @property idCache\n         * @type Object\n         */\n        idCache: {},\n\n        /**\n         * questionQueue contains Objects (stimuli) that are waiting to be presented\n         * @private\n         * @property questionQueue\n         * @type Array\n         */\n        questionQueue: [],\n\n        /**\n         * currentPageQuestions contains the Question Objects that are\n         * displayed at any given time.\n         * @private\n         * @property currentPageQuestions\n         * @type Array\n         */\n        currentPageQuestions: [],\n\n        /**\n         * Contains Trial Data Columns that were 'newly' added in this trial run.\n         * @private\n         * @property newlyAddedColumns\n         * @type Array\n         */\n        newlyAddedColumns: [],\n\n        /**\n         * Contains the Post-Initialization Element.\n         * @private\n         * @property postInitElement\n         * @type Object\n         */\n        postInitElement: {},\n\n        /**\n         * Setter function for Trial-Level Data.\n         * @method setTrialData\n         * @param key {String} Key\n         * @param value {Value} Value\n         */\n        setTrialData: function(key, value) {\n            //Store value in trial cache\n            this.TDCache[key] = value;\n            if (this.BDCache.QRTLib_trialColumns[key] === undefined) {\n                //Add column to overall trial data\n                this.BDCache.QRTLib_trialColumns[key] = '';\n                this.newlyAddedColumns.push(key);\n            }\n        },\n\n        /**\n         * Gets the value of Trial-Level Data field 'key\n         * @method getTrialData\n         * @param key {String} Key\n         */\n        getTrialData: function(key) {\n            return this.TDCache[key];\n        },\n\n        /**\n         * Setter function for Block-Level Data.\n         * @method setBlockData\n         * @param key {String} Key\n         * @param value {Value} Value\n         */\n        setBlockData: function(key, value) {\n            this.BDCache[key] = value;\n        },\n\n\n        /**\n         * Gets the value of Block-Level Data field 'key\n         * @method getBlockData\n         * @param key {String} Key\n         */\n        getBlockData: function(key) {\n            return this.BDCache[key];\n        },\n\n\n\n\n        /**\n         * Stringify the Block Data and store it in the Embedded Data Field. This preserves the values stored on Block Level for use in later trials\n         * @method saveBlockData\n         * @param key {String} Key\n         */\n        saveBlockData: function() {\n            //Store blockData in ED so that we can use it next trial\n            QRTEController.storeBlockData(QRTE.BDCache);\n            Qualtrics.SurveyEngine.setEmbeddedData(QRTE.blockDataField, Object.toJSON(QRTE.BDCache));\n        },\n\n\n\n        /**\n         * Setter function for Survey-Level Data (Embedded Data).\n         * @method setSurveyData\n         * @param key {String} Key\n         * @param value {Value} Value\n         */\n        setSurveyData: function(key, value) {\n            this.SDCache[key] = value;\n            Qualtrics.SurveyEngine.setEmbeddedData(key, value);\n        },\n\n\n\n        /**\n         * Gets the value of Survey-Level Data (Embedded Data) 'key'\n         * @method getSurveyData\n         * @param key {String} Key\n         */\n\n        getSurveyData: function(key) {\n            if (this.SDCache[key] !== undefined) {\n                return this.SDCache[key];\n            }\n            //This only works if the Survey Data has been set during the same trial due to a bug in Qualtrics.\n            return Qualtrics.SurveyEngine.getEmbeddedData(key);\n        },\n\n        /**\n         * Sets a configuration for a question\n         * @method setConfig\n         * @param QID {String} The QRTE Question Id of the Question you want the configuration to apply to\n         * @param option {String} The type of configuration you want to set, Allowed options: 'cresp', 'allowable', 'duration', 'endaction', 'delay'. Refer to website for documentation on these configs\n         * @param value {String} The value the configuration needs to be set to. Differs per option.\n         */\n        setConfig: function(QID, option, value) {\n            var setterFunc;\n            if (typeof QID === 'string') {\n                setterFunc = function(QID, option, value) {\n                    this.setTrialData(QID + \"[\" + option + \"]\", value);\n                };\n            } else {\n                setterFunc = function(QID, option, value) {\n                    this.setTrialData(QID.questionId + \"[\" + option + \"]\", value);\n                    QID['_' + option] = value;\n                };\n\n            }\n\n            this._setConfig(QID, option, value, setterFunc);\n        },\n\n\n        /**\n         * Loads the configuration for a question.\n         * @private\n         * @method loadConfig\n         * @param question {Object} Question for which the configuration needs to be loaded.\n         */\n        loadConfig: function(question) {\n            if (this.idCache[question.questionId] !== undefined) {\n                question.QRTLib_configId = this.idCache[question.questionId];\n            } else {\n                question.QRTLib_configId = question.question;\n            }\n            question.duration = this.getDuration(question);\n            question.allowable = this.getAllowable(question);\n            question.cresp = this.getCResp(question);\n            question.offset = this.getOffset(question);\n            question.endAction = this.getEndAction(question);\n        },\n\n        /**\n         * Stores the accuracy of a trial\n         * @private\n         * @method saveAcc\n         * @param question {Object} Question for which accuracy needs to be stored\n         * @param acc {Integer} Accuracy of question\n         */\n\n        saveAcc: function(question, acc) {\n            if (acc === 0 || acc === 1) {\n                this.setTrialData(question.QRTLibId + \"[ACC]\", acc);\n                this.setSurveyData(\"ACC\", acc);\n            }\n        },\n\n\n\n        /**\n         * Check whether the given response was a correct response\n         * @method isCorrectResponse\n         * @param question {Object} Question for which correct response needs to be checked\n         * @param resp {String} Given response\n         */\n        isCorrectResponse: function(question, resp) {\n            return question.cresp.indexOf(resp) >= 0;\n        },\n\n        /**\n         * Check whether the given response was an allowable response\n         * @method isAllowableResponse\n         * @param question {Object} Question for which allowable response needs to be checked\n         * @param resp {String} Given response\n         */\n        isAllowableResponse: function(question, resp) {\n            return question.allowable.indexOf(resp) >= 0;\n        },\n\n\n\n        /**\n         * Check whether the given response was an allowable response\n         * @private\n         * @method keycode2string\n         * @param e {Object} KeyPress event from which to retrieve the response\n         */\n        keycode2string: function(e) {\n            return String.fromCharCode(e.charCode);\n        },\n\n        /** \n         * Wait for images to load before starting trial.\n         * @property waitForImageLoad\n         * @private\n         * @type Boolean\n         */\n\n        waitForImageLoad: true,\n\n        /** \n         * Trial Start waiting list - initialised with waiting for TrialStart\n         * @property loadWaitingList\n         * @private\n         * @type Array\n         */\n\n        loadWaitingList: [false],\n\n        /**\n         * Initializes the Engine, called at the start of the 'Init' question.\n         * @private\n         * @method initLib\n         * @param blockDataString {String} JSON string containing information saved for this block (block-level data)\n         * @param blockId {String} Id of the current block\n         * @param columns {String} JSON string containing information about the columns that have been defined in this block\n         * @param idData {String} JSON string containing information about the mapping of the QID to the name of the question\n         * @param exitQuestions {String} String containing the currently defined QuestionTags of the Exit questions\n         * @param exitItemTag {String} String containing the Tag of this block's Exit question.\n         */\n\n\n        initLib: function(blockDataString, blockId, columns, idData, exitQuestions, exitItemTag) {\n            //var blockDataString = Qualtrics.SurveyEngine.getEmbeddedData(QRTE.blockDataField),\n            //columns = Qualtrics.SurveyEngine.getEmbeddedData(QRTE.columnsField),\n            //idData = Qualtrics.SurveyEngine.getEmbeddedData(QRTE.idField);\n            var glue;\n            QRTE.fixSetEmbeddedDataBug();\n            //Initialise block Data\n            if (blockDataString === undefined columnData || blockDataString === '') {\n                blockDataString = '{}';\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.blockDataField, blockDataString);\n            }\n\n            this.BDCache = QRTEController.loadBlockData(blockDataString);\n\n            if (this.BDCache.QRTLib_currentBlock !== blockId) {\n                //If this is a new block, initialise a new block\n                this.BDCache = {\n                    QRTLib_currentBlock: blockId,\n                    QRTLib_blockCounter: 1,\n                    QRTLib_trialColumns: {}\n                };\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.blockDataField, Object.toJSON(this.BDCache));\n                if (exitQuestions === null) {exitQuestions = '';}\n                glue = '';\n                if (exitQuestions !== '') {\n                    glue = ';';\n                }\n                //And update the exit questions\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.exitQuestions, exitQuestions + glue + exitItemTag);\n\n            }\n            QRTE.TDCache = Object.toJSON(QRTE.getBlockData('QRTLib_trialColumns')).evalJSON();\n            if (columns === undefined || columns === null || columns === '') {\n                columns = '{}';\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.columnsField, columns);\n            }\n            QRTE.SDCache[QRTE.columnsField] = columns.evalJSON();\n            if (idData === undefined || idData === null || idData === '') {\n                idData = '{}';\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.idField, idData);\n            }\n            QRTE.idCache = idData.evalJSON();\n        },\n\n        /**\n         * Init initializes the QRTEngine, expects are params object with possible fields defined with parameters.\n         * @method Init\n         * @param paramObj {Object} object containing parameters of Init function\n         *  @param paramObj.blockData {String} blockData string in json format (from embedded data)\n         *  @param paramObj.columnData {String} columnData string in json format (from embedded data)\n         *  @param paramObj.exitQuestions {String} exitQuestions string (from embedded data)\n         *  @param paramObj.exitItemTag {String} Tag of the Exit question of this block\n         *  @param paramObj.blockId {String} Identificaton of the block\n         *  @param [paramObj.onLoadFn] {Function} Function to be called when this Question is displayed\n         *  @param [paramObj.interTrialDelay] {Integer|Array} Specify millisecond delay between end of previous trial and beginning of new trial\n         *  @param [paramObj.preTrialDelay] {Integer|Array} Specify millisecond (ms) delay before the start of the first trial of the block. //NYI\n         *  @param [paramObj.initQuestionIndex] {Integer} Specify index of the Init question in the Question Block (defaults to 1)\n         *  @param [paramObj.waitForImages] {Boolean} Specify whether we should wait for images or not. Is on by default, but could be turned off if all images are pre-loaded in cache, or are very small in general.\n         */\n        Init: function(paramObj) {\n            var validationArray, qArray, initIndex;\n            //init the library\n            QRTE.init();\n\n            //set the initIndex (if the Init question is not the first question of the block)\n            QRTE.initIndex = paramObj.initQuestionIndex - 1 || 0;\n\n\n            validationArray = [{\n                name: 'blockData',\n                type: ['JSON', 'Empty'],\n                required: true\n            }, {\n                name: 'columnData',\n                type: ['JSON', 'Empty'],\n                required: true\n            }, {\n                name: 'idData',\n                type: ['JSON', 'Empty'],\n                required: true\n            }, {\n                name: 'blockId',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'onLoadFn',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'interTrialDelay',\n                type: ['Integer', 'Array'],\n                required: false\n            }, {\n                name: 'exitQuestions',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'exitItemTag',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'waitForImages',\n                type: ['Boolean'],\n                required: false\n            }];\n\n            //Validate Parameter Object, outputs stuff to console\n            QRTE.validateParams(paramObj, validationArray, 'Init');\n\n\n            //Initialize the library itself (necessary for each trial)\n            QRTE.initLib(paramObj.blockData, paramObj.blockId, paramObj.columnData, paramObj.idData, paramObj.exitQuestions, paramObj.exitItemTag);\n\n\n            if (paramObj.waitForImages !== undefined) {\n                QRTE.waitForImageLoad = paramObj.waitForImages;\n            }\n            //calculate server communication delay\n            QRTE.setTrialData('InitPre[OnsetTime]', QRTE.getBlockData('QRTLib_previousStorageDone'));\n\n            QRTE.setTrialData('InitPre[OffsetTime]', window.requestAnimationFrame.now());\n            QRTE.setTrialData('InitPre[CalculatedDuration]', QRTE.getTrialData('InitPre[OffsetTime]') - QRTE.getTrialData('InitPre[OnsetTime]'));\n            QRTE.setTrialData('Init[OnsetTime]', window.requestAnimationFrame.now());\n\n\n\n            Qualtrics.SurveyEngine.addOnload(function() {\n                this.qHTML = document.getElementById(this.questionId);\n                this.QRTLib_isActive = false;\n                this.hideChoices();\n                this.proceed = QRTE.proceed;\n                this.QRTLibId = 'InitPost';\n\n                paramObj.onLoadFn.apply(this);\n                var QuestionStackElement = {\n                    questionElement: this,\n                    onShowFunc: function() {},\n                    type: 'Stimulus',\n                    loadConfig: true,\n                    id: 'InitPost',\n                    conditional: function() {\n                        return true;\n                    },\n                    proceedOnHide: true\n\n                };\n                QRTE.setConfig(QuestionStackElement.id, 'duration', 0);\n                QRTE.postInitElement = QuestionStackElement;\n                QRTE.questionQueue.push(QuestionStackElement);\n            });\n\n            if (paramObj.interTrialDelay instanceof Array) {\n                paramObj.interTrialDelay = paramObj.interTrialDelay[Math.floor(Math.random() * paramObj.interTrialDelay.length)];\n            }\n            QRTE.setTrialData(paramObj.blockId + '[InterTrialDelay]', paramObj.interTrialDelay);\n            if (paramObj.interTrialDelay > 0) {\n                QRTE.setBlockData('QRTLib_intraTrialDelay', paramObj.interTrialDelay);\n            } else {\n                QRTE.setBlockData('QRTLib_intraTrialDelay', -1);\n            }\n        },\n\n        /**\n         * Create a Stimulus question\n         * @method Stimulus\n         * @param paramObj {Object}\n         *  @param paramObj.id {String} Id of the Question\n         *  @param paramObj.onShowFn {Function} Function to be called upon showing the question (not the same as upon loading)\n         *  @param [paramObj.conditional] {Function} Function to be called with which to decide whether to present this question or not, should return a boolean.\n         *  @param [paramObj.loadConfig] {Boolean} Load predefined config for this question (defaults to true)\n         *  @param [paramObj.stimContinue] {Boolean} Continue looking for stimuli after having seen this one, only if set to true (defaults to false)\n         *  @param [paramObj.onKeyPress] {Function} Function to be called upon receiving a key press while this Question is active (called next to onAllowableKey or onCorrectKey)\n         *  @param [paramObj.onAllowableKey] {Function} Function to be called upon receiving a key press on a key defined as 'allowable' \n         *  @param [paramObj.onCorrectKey] {Function} Function to be called upon receiving a key press on a key defined as 'correct'\n         *  @param [paramObj.onIncorrectKey] {Function} Function to be called upon receiving an allowable key that is not defined as correct (only if correct responses are defined)\n         *  @param [paramObj.proceedOnHide] {Boolean} Set whether all currently displayed elements should be removed on hide, or if only this should be removed from display (Defaults to True). This allows the user to decouple presentation of a stimulus from proceeding of a slide.\n         *  @param [paramObj.onHideFn] {Function} Function to be called upon Stimulus being hidden\n         *  @param [paramObj.duringDisplayFn] {Function} Function to be called during each frame that the Stimulus is being displayed\n         \n         */\n        Stimulus: function(paramObj) {\n            var validationArray = [{\n                name: 'id',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'onShowFn',\n                type: ['Function'],\n                required: true\n            }, {\n                name: 'conditional',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'loadConfig',\n                type: ['Boolean'],\n                required: false\n            }, {\n                name: 'duringDisplayFn',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'continue',\n                type: ['Boolean'],\n                required: false\n            }, {\n                name: 'onAllowableKey',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'onCorrectKey',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'onKeyPress',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'onIncorrectKey',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'proceedOnHide',\n                type: ['Boolean'],\n                required: false\n            }, {\n                name: 'onHideFn',\n                type: ['Function'],\n                required: false\n            }];\n\n            //Validate Parameter Object, outputs stuff to console\n            QRTE.validateParams(paramObj, validationArray, 'Stimulus');\n\n\n            if (paramObj.conditional === undefined) {\n                paramObj.conditional = function() {\n                    return true;\n                };\n            }\n            if (paramObj.loadConfig === undefined) {\n                paramObj.loadConfig = true;\n            }\n\n            if (paramObj.stimContinue === undefined) {\n                paramObj.stimContinue = false;\n            }\n\n            if (paramObj.proceedOnHide === undefined) {\n                paramObj.proceedOnHide = true;\n            }\n            Qualtrics.SurveyEngine.addOnload(function() {\n                this.QRTLib_isActive = false;\n                this.proceed = QRTE.proceed;\n                this.QRTLibId = paramObj.id;\n                var QuestionStackElement = {\n                    questionElement: this,\n                    onShowFunc: paramObj.onShowFn,\n                    duringDisplayFn: paramObj.duringDisplayFn,\n                    onHideFn: paramObj.onHideFn,\n                    type: 'Stimulus',\n                    loadConfig: paramObj.loadConfig,\n                    id: paramObj.id,\n                    conditional: paramObj.conditional,\n                    stimContinue: paramObj.stimContinue,\n                    onAllowableKey: paramObj.onAllowableKey,\n                    onCorrectKey: paramObj.onCorrectKey,\n                    onKeyPress: paramObj.onKeyPress,\n                    onIncorrectKey: paramObj.onIncorrectKey,\n                    proceedOnHide: paramObj.proceedOnHide\n                };\n                QRTE.questionQueue.push(QuestionStackElement);\n            });\n        },\n\n        /**\n         * Exit denotes the end of the block. Important for the initialization phase and the exit phase.\n         * Make the question a Form question with precisely 2 answer fields (more is unnecessary, those will get ignored)\n         * @method Exit\n         */\n        Exit: function() {\n\n\n            qArray = $('Questions').getElementsByClassName('QuestionOuter');\n            for (var i = 0; i < qArray.length && i < QRTE.initIndex + 1; i += 1) {\n                qArray[i].style.display = 'block';\n            }\n            Qualtrics.SurveyEngine.addOnload(function() {\n                //Hide all choice\n                this.hideChoices();\n                //display the question\n                //this.questionContainer.style.display = 'none';\n                var QuestionStackElement, onShowFn;\n                onShowFn = function() {\n\n                    //Create and/or store standard information about the trial\n                    var blockId = QRTE.getBlockData('QRTLib_currentBlock'),\n                        tempTD = {},\n                        key,\n                        i;\n\n                    QRTE.setBlockData('QRTLib_previousEndTime', window.requestAnimationFrame.now());\n                    QRTE.setTrialData(blockId + '[TrialNr]', QRTE.getBlockData('QRTLib_blockCounter'));\n                    QRTE.setTrialData(blockId + '[RefreshPeriod]', QRTE.refreshPeriod);\n                    QRTE.setTrialData('BlockId', blockId);\n                    QRTE.setTrialData('EngineType', window.requestAnimationFrame.method);\n                    QRTE.setTrialData('Exit[OnsetTime]', window.requestAnimationFrame.now());\n                    QRTE.setTrialData('QRTEngine[Version]', QRTE.version);\n\n                    //CHECK IF ATLEAST TWO FORM FIELDS HAVE BEEN DEFINED\n                    this.setChoiceValue(2, 'testtest');\n                    if (this.getChoiceValue(2) !== 'testtest') {\n                        //alert('You need to define two answer form fields in the Exit question!!');\n                    }\n\n                    for (key in QRTE.TDCache) {\n                        if (QRTE.TDCache.hasOwnProperty(key) && key !== '') {\n                            //Change QID thingies to entered ID's, also force every value to a string so that the Parser handles high numerical values correctly\n                            tempTD[QRTE.getOutputKey(key)] = String(QRTE.TDCache[key]);\n                        }\n                    }\n\n                    this.setChoiceValue(1, Object.toJSON(tempTD));\n                    this.setChoiceValue(2, blockId);\n                    if (QRTE.SDCache[QRTE.columnsField][blockId] === undefined) {\n                        QRTE.SDCache[QRTE.columnsField][blockId] = [];\n                    }\n                    for (i = 0; i < QRTE.newlyAddedColumns.length; i += 1) {\n                        QRTE.SDCache[QRTE.columnsField][blockId].push(QRTE.getOutputKey(QRTE.newlyAddedColumns[i]));\n                    }\n\n                    QRTE.setSurveyData(QRTE.columnsField, Object.toJSON(QRTE.SDCache[QRTE.columnsField]));\n                    QRTE.setBlockData('QRTLib_blockCounter', QRTE.getBlockData('QRTLib_blockCounter') + 1);\n                    QRTE.setBlockData('QRTLib_previousStorageDone', window.requestAnimationFrame.now());\n                    QRTE.saveBlockData();\n\n                    //If wanting to test, uncomment this line and comment the one after that to enforce manual nextbutton clicks\n                    //$('NextButton').style.display = 'block';\n                    //QRTE.submitPage();\n                    QRTEController.loadNextTrial();\n                };\n\n                QuestionStackElement = {\n                    questionElement: this,\n                    onShowFunc: onShowFn,\n                    type: 'Storage',\n                    loadConfig: true,\n                    conditional: function() {\n                        return true;\n                    }\n                };\n                QRTE.questionQueue.push(QuestionStackElement);\n\n                QRTE.startTrial(0);\n\n            });\n\n            QRTE.loadWaitingList = [false];\n            if (QRTE.waitForImageLoad === true) {\n                //set wait for image load queues.\n                var loadIndex = 1,\n                    images = $$('.QuestionOuter img'),\n                    i = 0;\n\n                var l = images.length;\n                for (; i < l; i += 1) {\n                    images[i].observe('load', function(e) {\n                        QRTE.startTrial(e.path[0].QRTELoadIndex);\n                    })\n                    images[i].QRTELoadIndex = i + 1;\n                    QRTE.loadWaitingList[i + 1] = false;\n                }\n\n            }\n\n        },\n\n        /**\n         * Remove the padding Qualtrics adds between Questions (causes question presentation to drift downwards if not called).\n         * DEPRECATED: Separators hidden through CSS now\n         * @method removeSeparators\n         * @private\n         */\n        removeSeparators: function() {\n            var questionElement = document.getElementById('Questions'),\n                index;\n            for (index = 0; index < questionElement.children.length; index += 1) {\n                if (questionElement.children[index].className === \"Separator\") {\n                    questionElement.children[index].parentNode.removeChild(questionElement.children[index]);\n                }\n            }\n        },\n        /**\n         * Notifies the engine the first trial is ready to be started. Called at the end of the 'exit' question\n         * @private\n         * @method startTrial\n         */\n        startTrial: function(startId) {\n            var duringDisplayFn, onHideFn, onDisplayFn, serverCommDelay, remainingDelay;\n            //All questions have been hidden, so display the parent block again\n            //$('Questions').style.display = 'block';\n\n            QRTE.loadWaitingList[startId] = true;\n            if (!QRTE.loadWaitingList.every()) {\n                QRTE.log('Process ' + startId + 'finished, waiting for other processes to finish')\n                return;\n            }\n\n            //Save the absolute time of when onLoad part of library was finished\n            serverCommDelay = window.requestAnimationFrame.now() - QRTE.getBlockData('QRTLib_previousEndTime'); //Calculate the remaining time based on the lib initialization + server delay times\n            remainingDelay = QRTE.getBlockData('QRTLib_intraTrialDelay') - serverCommDelay;\n\n\n            if (isNaN(remainingDelay)) {\n                remainingDelay = QRTE.getBlockData('QRTLib_intraTrialDelay') * 3;\n                //If this init call is the first one of the block (first trial), calculate the estimated refreshdelay during the pre-trial interval\n                onDisplayFn = function(ele, time) {\n                    QRTE.setTrialData('Init[OffsetTime]', ele.displayOnsetTime);\n                    QRTE.setTrialData('Init[CalculatedDuration]', ele.displayOnsetTime - QRTE.getTrialData('Init[OnsetTime]'));\n                    QRTE.refreshPeriodEstimationStack = [];\n                };\n                duringDisplayFn = function(ele, time) {\n                    //Get current time, required for \n                    QRTE.refreshPeriodEstimationStack.push(time);\n                };\n                onHideFn = function(ele, timestamp) {\n                    var diffs = [];\n\n                    for (i = 1; i < QRTE.refreshPeriodEstimationStack.length; i += 1) {\n                        diffs[i - 1] = QRTE.refreshPeriodEstimationStack[i] - QRTE.refreshPeriodEstimationStack[i - 1];\n                    }\n                    QRTE.refreshPeriod = QRTE.median(diffs);\n                    QRTE.log('Estimated refresh delay = ' + QRTE.refreshPeriod);\n                    QRTE.setBlockData('QRTE_refreshPeriod', QRTE.refreshPeriod);\n                    QRTE.referenceTime = timestamp;\n                    QRTE.framesSinceReference = 0;\n                };\n            } else {\n                onDisplayFn = function(ele, time) {\n                    QRTE.setTrialData('Init[OffsetTime]', ele.displayOnsetTime);\n                    QRTE.setTrialData('Init[CalculatedDuration]', ele.displayOnsetTime - QRTE.getTrialData('Init[OnsetTime]'));\n                };\n\n                QRTE.refreshPeriod = QRTE.getBlockData('QRTE_refreshPeriod');\n            }\n\n            //QRTE.setTrialData('ITI[Duration]', (remainingDelay > 0) ? remainingDelay : 0);\n            QRTE.initTime = window.requestAnimationFrame.now();\n\n            QRTE.postInitElement.onHideFn = onHideFn;\n            QRTE.postInitElement.onDisplayFn = onDisplayFn;\n            QRTE.postInitElement.duringDisplayFn = duringDisplayFn;\n            QRTE.setConfig('InitPost', 'duration', (remainingDelay > 0) ? remainingDelay : 0);\n            //UNCOMMENT\n            //QRTE.setConfig('InitPost', 'duration', (remainingDelay > 0) ? remainingDelay : Infinity);\n            QRTE.inited = true;\n\n            //Set initial trial data related to loading of this trial\n            QRTE.setTrialData('InitServerComm[Onset]', QRTE.getBlockData('ServerCommOnset'));\n            QRTE.setTrialData('InitServerComm[Offset]', QRTE.getBlockData('ServerCommOffset'));\n            QRTE.setTrialData('InitServerComm[CalculatedDuration]', QRTE.getBlockData('ServerCommOffset') - QRTE.getBlockData('ServerCommOnset'));\n\n            //<Load next trial here>\n            var currentLoops = '${lm://CurrentLoopNumber}',\n                totalLoops = '${lm://TotalLoops}';\n            //Check if last trial, currentloops === totalLoops;\n            QRTEController.requestNextTrial(currentLoops !== '' && currentLoops === totalLoops);\n\n            QRTE.proceed();\n        },\n\n\n\n        proceed: function() {\n            QRTE.log(\"proceed called after \" + window.requestAnimationFrame.now() - QRTE.initTime);\n            QRTE.hideAllElements();\n        },\n\n        proceedPage: function() {\n            var currentQ;\n            QRTE.log(\"Proceeding page..\");\n            while (QRTE.currentPageQuestions.length > 0) {\n                currentQ = QRTE.currentPageQuestions.shift();\n\n                //Disable\n                currentQ.questionElement.QRTLib_isActive = false;\n            }\n\n\n            //Go to next question\n            QRTE.showNextPage();\n        },\n\n        disableQuestion: function(disableQ) {},\n\n        /**\n         * Determine and show the next page/slide\n         * @private\n         * @method showNextPage\n         */\n        showNextPage: function() {\n            var continueSearch = true,\n                shownQ = false,\n                nextQ,\n                shown;\n            while (continueSearch === true) {\n                continueSearch = false;\n                nextQ = QRTE.questionQueue.shift();\n                if (nextQ !== undefined && (nextQ.type === 'Stimulus' || nextQ.type === 'Storage')) {\n                    QRTE.currentPageQuestions.push(nextQ);\n                    shown = QRTE.showStimulusQuestion.apply(nextQ.questionElement, [nextQ]);\n\n                    if (nextQ.stimContinue) {\n                        continueSearch = true;\n                        if (shown === true) {\n                            shownQ = true;\n                        }\n                    }\n                    QRTE.log('shown ' + nextQ.id + ': ' + shown);\n                    QRTE.log('continue ' + nextQ.id + ': ' + continueSearch);\n                    if (shown === false && shownQ === false) {\n                        continueSearch = true;\n                    }\n                }\n            }\n\n        },\n\n        /**\n         * Show Question\n         * Handles the activation of that question, which includes:\n         * The loading of the configuration (duration, allowable keys etc).\n         * Sets the event handler to respond to any key presses during the event.\n         * @private\n         * @method showStimulusQuestion\n         * @param question {Object} question to be shown.\n         *  @param id {String} Id of question.\n         *  @param onShowFunc {Function} Function to be called when showing question\n         *  @param loadConfig {Boolean} If true, config is loaded from the current block data (which has been defined elsewhere)\n         *  @param questionElement {Object} This Qualtrics question element\n         *  @param duringDisplayFn {Function} Function to be called each frame that the question is presented\n         */\n        showStimulusQuestion: function(question) {\n            //Save the loading start time\n            //QRTE.setTrialData(question.questionElement.QRTLibId + '[LoadStartTime]', window.requestAnimationFrame.now());\n            //Set mapping of the QID -> QRTE Id\n            QRTE.setId(this, question.id);\n\n            //Initialize variables\n            var stimulusShown = false,\n                questionScope = this,\n                dispEle;\n            QRTE.log(question);\n\n            //Check whether question should be shown or not, if not skip to the next question (implicitly)\n            if (question.conditional() === true) {\n                this.QRTLib_isActive = true;\n\n\n                if (question.loadConfig === true) {\n                    //Load the Configuration of the Question, important!\n                    QRTE.loadConfig(this);\n                }\n\n                //Check if KeyPress listener is required (one or more of the following fields are defined: onKeyPress, onCorrectKey or onAllowableKey)\n                //If so, add keypress listener.\n                if (question.onKeyPress !== undefined || question.questionElement.allowable !== '' || question.questionElement.cresp !== '') {\n                    //Initialize the fields used for storing data about RT timing.\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[RTTime]', '');\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[RT]', '');\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[RESP]', '');\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[ACC]', 0);\n\n                    //Add the key listener\n                    QRTE.addKeyListener(function(e) {\n\n                        //Get the Key of the response\n                        var RT, RESP = QRTE.keycode2string(e),\n                            RTTime = window.requestAnimationFrame.now();\n                        RT = RTTime - QRTE.getTrialData(question.questionElement.QRTLibId + '[OnsetTime]');\n\n                        //Store the Time of the Key Press and calculate the RT and ACC if correct\n\n                        if ((QRTE.isAllowableResponse(question.questionElement, RESP) || QRTE.isCorrectResponse(question.questionElement, RESP)) && QRTE.getTrialData(question.questionElement.QRTLibId + '[RTTime]') === '') {\n                            QRTE.setTrialData(question.questionElement.QRTLibId + '[RTTime]', RTTime);\n                            QRTE.setTrialData(question.questionElement.QRTLibId + '[RT]', RT);\n                            QRTE.setTrialData(question.questionElement.QRTLibId + '[RESP]', RESP);\n                            if (QRTE.isCorrectResponse(question.questionElement, RESP)) {\n                                QRTE.saveAcc(question.questionElement, 1);\n                            } else {\n                                QRTE.saveAcc(question.questionElement, 0);\n                            }\n                        }\n\n                        //Store the RT and the Response\n\n                        //Set Handling Key Press to true, this lets the engine know that a keypress is currently being handled. Necessary when there is a timer (response deadline)\n                        question.handlingKeyPress = true;\n\n                        if (question.onCorrectKey !== undefined && QRTE.isCorrectResponse(question.questionElement, RESP)) {\n                            question.onCorrectKey.apply(question.questionElement, [e, RESP]);\n                        } else if (question.onIncorrectKey !== undefined && QRTE.isAllowableResponse(question.questionElement, RESP)) {\n                            question.onIncorrectKey.apply(question.questionElement, [e, RESP]);\n                        }\n\n                        if (question.onAllowableKey !== undefined && QRTE.isAllowableResponse(question.questionElement, RESP)) {\n                            question.onAllowableKey.apply(question.questionElement, [e, RESP]);\n                        }\n\n                        if (question.onKeyPress !== undefined) {\n                            question.onKeyPress.apply(question.questionElement, [e, RESP]);\n                        }\n\n                        if (question.questionElement.endAction === 'TERMINATE') {\n                            //Proceed to the next Question Page if the response is allowable\n                            if (QRTE.isAllowableResponse(question.questionElement, RESP) && question.questionElement.QRTLib_isActive === true) {\n                                question.questionElement.proceed();\n                            }\n                        }\n                        question.handlingKeyPress = false;\n\n                    }, this);\n                }\n\n                //Build the display Element. Stimuli Questions have to take into account the possibility of being associated with a key press. \n                //OnDisplayFn therefore logs the displayOnsetTime, so that the RT can be calculated.\n                dispEle = {\n                    el: this.questionContainer,\n                    duration: this.duration,\n                    delay: this.offset,\n                    duringDisplayFn: question.duringDisplayFn,\n                    onDisplayFn: function(displayEl, timestamp) {\n                        if (question.onDisplayFn !== undefined) {\n                            question.onDisplayFn(displayEl, timestamp);\n                        }\n                        QRTE.setTrialData(questionScope.QRTLibId + '[OnsetTime]', displayEl.displayOnsetTime);\n                    },\n                    proceedOnHide: question.proceedOnHide,\n                    id: question.id\n                };\n\n                //Set the OnHide Function\n                dispEle.onHideFn = function(displayEl, timestamp) {\n                    if (question.onHideFn !== undefined) {\n                        question.onHideFn(displayEl, timestamp);\n                    }\n                    QRTE.setTrialData(questionScope.QRTLibId + '[OffsetTime]', displayEl.displayOffsetTime);\n                    QRTE.setTrialData(questionScope.QRTLibId + '[CalculatedDuration]', displayEl.displayDuration);\n                };\n\n\n                this.QRTLib_timer = QRTE.displayElement(dispEle);\n\n                question.onShowFunc.apply(this);\n\n                stimulusShown = true;\n            }\n\n            //QRTE.setTrialData(question.questionElement.QRTLibId + '[LoadEndTime]', window.requestAnimationFrame.now());\n            return stimulusShown;\n        },\n\n        setId: function(question, desc) {\n\n            this.idCache[question.questionId] = desc;\n            question.qId = desc;\n\n            Qualtrics.SurveyEngine.setEmbeddedData(QRTE.idField, Object.toJSON(this.idCache));\n        },\n\n        getOutputKey: function(key) {\n            var oldKey;\n            for (oldKey in this.idCache) {\n                if (this.idCache.hasOwnProperty(oldKey) && oldKey === key.substring(0, oldKey.length)) {\n\n                    return QRTE.getBlockData('QRTLib_currentBlock') + this.idCache[oldKey] + key.substring(oldKey.length, key.length);\n                }\n            }\n            return key;\n        },\n\n\n        OnKeyPress: function(fn, qScope) {\n\n            qScope = qScope || window;\n\n            var keyFn = function(e) {\n                QRTE.setTrialData(qScope.QRTLibId + '[RTTime]', window.requestAnimationFrame.now());\n                var RT = QRTE.getTrialData(qScope.QRTLibId + '[RTTime]') - QRTE.getTrialData(qScope.QRTLibId + '[OnsetTime]');\n                QRTE.setTrialData(qScope.QRTLibId + '[RT]', RT);\n                QRTE.setTrialData(qScope.QRTLibId + '[RESP]', QRTE.keycode2string(e));\n                QRTE.log(qScope);\n                fn.apply(qScope, [e]);\n            }\n\n            QRTE.addKeyListener(keyFn, qScope);\n        },\n\n        addKeyListener: function(fn, listenerScope) {\n            Event.observe(document, 'keypress', function(e) {\n                if (listenerScope.QRTLib_isActive === true) {\n                    fn.apply(listenerScope, [e]);\n                }\n            });\n        },\n\n        /*  \n         **************Methods below this line are support methods*******************\n         */\n\n        hideQuestions: function() {\n            qArray = $('Questions').getElementsByClassName('QuestionOuter');\n            for (var i = 0; i < qArray.length; i += 1) {\n                qArray[i].style.display = 'none';\n            }\n        },\n\n        unhideQuestions: function() {\n            //Redisplay outer questions\n            qArray = $('Questions').getElementsByClassName('QuestionOuter');\n            for (var i = 0; i < qArray.length; i += 1) {\n                qArray[i].style.display = 'block';\n            }\n            //Redisplay separators\n            qArray = $('Questions').getElementsByClassName('Separator');\n            for (var i = 0; i < qArray.length; i += 1) {\n                qArray[i].style.display = 'block';\n            }\n\n\n        },\n\n        _handleKeyPressEvent: function() {\n\n        },\n\n        _setConfig: function(QID, option, value, setterFunc) {\n            var qidString = QID;\n            if (typeof QID !== 'string') {\n                qidString = QID.questionId;\n            }\n            option = option.toLowerCase();\n\n            switch (option) {\n                case 'duration':\n                    if (value instanceof Array) {\n                        value = value[Math.floor(Math.random() * value.length)];\n                    }\n                    setterFunc.apply(this, [qidString, 'Duration', value]);\n                    break;\n                case 'allowable':\n                    setterFunc.apply(this, [qidString, 'Allowable', value]);\n                    break;\n                case 'cresp':\n                    setterFunc.apply(this, [qidString, 'CRESP', value]);\n                    break;\n                case 'delay':\n                    setterFunc.apply(this, [qidString, 'Offset', value]);\n                    break;\n                case 'endaction':\n                    setterFunc.apply(this, [qidString, 'EndAction', value]);\n                    break;\n                default:\n                    QRTE.log('No such configuration: ' + option);\n                    break;\n            }\n        },\n        getDuration: function(question) {\n            var duration = Infinity,\n                edDuration = this.getTrialData(question.QRTLib_configId + '[Duration]');\n            if (edDuration !== undefined && edDuration !== '' && !isNaN(edDuration)) {\n                duration = edDuration;\n            }\n            if (question._Duration !== undefined && question._Duration !== '' && !isNaN(question._Duration)) {\n                duration = question._Duration;\n            }\n\n            return duration;\n        },\n        getAllowable: function(question) {\n            var allowable = \"\",\n                edAllowable = this.getTrialData(question.QRTLib_configId + '[Allowable]');\n            if (edAllowable !== undefined) {\n                allowable = edAllowable;\n            }\n            if (question._Allowable !== undefined) {\n                allowable = question._Allowable;\n            }\n\n            if (allowable === '{ANY}') {\n                allowable = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890-=[]\\\\;',./`\";\n            }\n            //allowable = allowable.toUpperCase();\n            return allowable;\n        },\n        getCResp: function(question) {\n            var cresp = '',\n                edcresp = this.getTrialData(question.QRTLib_configId + '[CRESP]');\n            if (edcresp !== undefined) {\n                cresp = edcresp;\n            }\n            if (question._cresp !== undefined) {\n                cresp = question._CRESP;\n            }\n\n            if (cresp === '{ANY}') {\n                cresp = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890-=[]\\\\;',./`\";\n            }\n            //cresp = cresp.toUpperCase();\n\n            return cresp;\n        },\n\n        getOffset: function(question) {\n            var offset = 0,\n                edOffset = this.getTrialData(question.QRTLib_configId + '[Offset]');\n            if (edOffset !== undefined && edOffset !== '' && !isNaN(edOffset)) {\n                offset = edOffset;\n            }\n            if (question._Offset !== undefined && question._Offset !== '' && !isNaN(question._Offset)) {\n                offset = question._Offset;\n            }\n\n            return offset;\n\n        },\n\n        getEndAction: function(question) {\n            var endAction = 'NONE',\n                edEndAction = this.getTrialData(question.QRTLib_configId + '[EndAction]');\n            if (edEndAction !== undefined && edEndAction !== '') {\n                endAction = edEndAction;\n            }\n            if (question._EndAction !== undefined && question._EndAction !== '') {\n                endAction = question._EndAction;\n            }\n\n            return endAction;\n\n        },\n        evaluateConditional: function(conditional) {\n            QRTE.log('Conditional: ', conditional);\n            return conditional === '' || conditional();\n        },\n        log: function() {\n            if (QRTE.debug === true) {\n                for (var i = 0; i < arguments.length; i += 1) {\n                    console.log(arguments[i]);\n                }\n            }\n        },\n\n        median: function(values) {\n\n            values.sort(function(a, b) {\n                return a - b;\n            });\n\n            var half = Math.floor(values.length / 2);\n\n            if (values.length % 2) return values[half];\n            else return (values[half - 1] + values[half]) / 2.0;\n        },\n\n        waitForKey: function(question, keys) {\n            Event.observe(document, 'keypress', function(e) {\n                var resp = QRTE.keycode2string(e);\n                if (keys.indexOf(resp) >= 0) {\n                    question.clickNextButton();\n                }\n            });\n        },\n\n        validateParams: function(paramObj, validationArray) {\n            var valObj, val, index, typeCheck = true,\n                indexType;\n            //Loop over validationArray to check whether parameters suffice\n            for (index = 0; index < validationArray.length; index += 1) {\n                valObj = validationArray[index];\n                if (paramObj[valObj.name] === undefined && valObj.required === true) {\n                    alert('Required parameter: ' + valObj.name + ' seems to be missing');\n                    QRTE.log('Required parameter: ' + valObj.name + ' seems to be missing');\n                    break;\n                }\n\n                val = paramObj[valObj.name];\n\n                //Loop over type checkers\n                for (indexType = 0; indexType < valObj.type.length; indexType += 1) {\n                    typeCheck = QRTE.validateType(val, valObj.type[indexType]);\n                    if (typeCheck === true) {\n                        break;\n                    }\n                }\n                if (typeCheck === false && valObj.required === true) {\n                    alert('Parameter: ' + valObj.name + ' is of the wrong type, expected type: ' + valObj.type + ', type received: ' + (typeof val) + \"\\n\" + \"Please open the console for detailed error messages\");\n                    QRTE.log('Parameter: ' + valObj.name + ' is of the wrong type, expected type: ' + valObj.type + ', type received: ' + (typeof val));\n                    QRTE.log('Faulty parameter ' + valObj.name + ': ', val);\n                    QRTE.log('Proper functioning of QRTE is no longer guaranteed, please fix the above error');\n                }\n\n            }\n        },\n\n        validateType: function(val, type) {\n            switch (type) {\n                case 'JSON':\n                    return val.isJSON();\n                case 'String':\n                    return (typeof val === 'string' || val instanceof String);\n                case 'Number':\n                    return (!isNaN(parseFloat(val)) && isFinite(val));\n                case 'Array':\n                    return val instanceof Array;\n                case 'Object':\n                    return typeof val === 'object';\n                case 'Function':\n                    return typeof val === 'function';\n                case 'Boolean':\n                    return (val === true || val === false);\n                case 'Empty':\n                    return val === '';\n                default:\n                    return false;\n            }\n        },\n\n        fixSetEmbeddedDataBug: function() {\n            Qualtrics.SurveyEngine.setEmbeddedData = function(key, value) {\n                var fieldName = 'ED~' + key;\n                if ($(fieldName)) {\n                    $(fieldName).value = value;\n                } else {\n                    $('Header').appendChild(QBuilder('input', {\n                        type: 'hidden',\n                        id: fieldName,\n                        name: fieldName,\n                        value: value\n                    }));\n                    Qualtrics.SurveyEngine.setEmbeddedData(key, value);\n                }\n            }\n        },\n\n        //DisplayEngine part\n\n        //Since it's impossible to know when a screen refresh has happened, we assume that the first timestamp is the actual screen refresh.\n        //Based on the difference between the current timestamp Tn and the root timestamp Tn-1, we estimate the amount of frames that have passed since. \n        //Based on the amount of frames we estimate the previous screen refresh. Although not perfect, it's the best we can do.\n\n        refreshRate: 60, //hertz\n        refreshPeriod: 1000 / 60,\n        lastRefresh: 0,\n        currentRefresh: 0,\n        previousTimestamp: 0,\n        referenceTime: 0,\n        framesSinceReference: 0,\n        currentStack: [],\n        proceedOnFrameEnd: false,\n\n        init: function() {\n            window.requestAnimationFrame(QRTE.draw);\n        },\n\n        draw: function(timestamp) {\n            var curEle, newStack = [];\n            timestamp = window.requestAnimationFrame.now();\n\n\n            if (timestamp < 1e12) {\n                timestamp += window.performance.timing.navigationStart;\n            }\n\n            if (QRTE.referenceTime === 0) {\n                QRTE.referenceTime = timestamp;\n                QRTE.previousTimestamp = timestamp;\n                QRTE.framesSinceReference = 0;\n            } else {\n                //QRTE.framesSinceReference += QRTE.calcFrames(QRTE.referenceTime, timestamp);\n                QRTE.prevFrames = QRTE.framesSinceReference;\n                //frameDiff =  QRTE.calcFrames(QRTE.referenceTime, timestamp) - QRTE.prevFrames;\n                QRTE.framesSinceReference = QRTE.calcFrames(QRTE.referenceTime, timestamp);\n            }\n            QRTE.currentRefresh = (QRTE.framesSinceReference * QRTE.refreshPeriod) + QRTE.referenceTime;\n            QRTE.projectedRefresh = QRTE.currentRefresh + QRTE.refreshPeriod;\n            curEle = QRTE.currentStack.shift();\n\n            while (curEle) {\n                curEle.keep = true;\n\n                //Call duringDisplay callback function, with the current element and the timestamp as arguments.\n                if (curEle.shown === true && typeof curEle.duringDisplayFn === 'function') {\n                    curEle.duringDisplayFn(curEle, timestamp);\n                }\n\n                if (QRTE.proceedOnFrameEnd === true || curEle.hide === true || (curEle.shown === true && curEle.displayOnset !== undefined && (curEle.displayOnset + curEle.duration < QRTE.projectedRefresh))) {\n                    //If the next refresh makes it go beyond the duration, hide the element again!\n                    curEle = QRTE.hideSingleEle(curEle, timestamp);\n                } else if (curEle.shown === false && curEle.requestedAt + curEle.delay < QRTE.projectedRefresh) {\n                    curEle = QRTE.dispSingleEle(curEle, timestamp);\n                }\n\n                if (curEle.keep === false && curEle.proceedOnHide === true) {\n                    //Behold! We have found an element that commands us to proceed to the next page.\n                    QRTE.proceedOnFrameEnd = true;\n                    //Every element that has been processed so far needs to be re-processed (sadly), so that they properly hide.\n                    for (var ind = 0; ind < newStack.length; ind += 1) {\n                        if (newStack[ind].hide !== true) {\n                            newStack[ind].hide = true;\n                            QRTE.currentStack.push(newStack[ind]);\n                        }\n                    }\n                } else {\n                    //Push it to the newStack, for it to be processed next time.\n                    newStack.push(curEle);\n                }\n\n                curEle = QRTE.currentStack.shift();\n            }\n            QRTE.currentStack = newStack;\n            QRTE.lastRefresh = QRTE.currentRefresh;\n            QRTE.previousTimestamp = timestamp;\n            window.requestAnimationFrame(QRTE.draw);\n            if ((newStack.length === 0 || QRTE.proceedOnFrameEnd) && QRTE.inited === true) {\n                QRTE.proceedOnFrameEnd = false;\n                QRTE.proceedPage();\n            }\n\n\n        },\n\n        calcFrames: function(previous, current) {\n            var diff = current - previous,\n                frames = 0;\n\n            if (diff < QRTE.refreshPeriod) {\n                frames = 1;\n            } else {\n                frames = Math.floor(diff / QRTE.refreshPeriod);\n                if (diff % QRTE.refreshPeriod >= (QRTE.refreshPeriod * 0.9)) {\n                    frames += 1;\n                }\n            }\n\n            return frames;\n        },\n\n        /**\n         * Display an element for a specified duration with a specified delay. Vsyncs the display duration using requestAnimationFrame (if possible in the browser)\n         * and allows for high-precision control over its duration. Please start any custom attributes for the paramObj with the 'custom_' header, to avoid collisions.\n         * @private\n         * @method displayElement\n         * @param paramObj {Object}\n         *  @param el {Object} HTML element to be displayed\n         *  @param [onHideFn] {Function} Function to be called upon removing the element from display, is passed one argument containing all information about the display element.\n         *  @param [duration] {Number} Number of milliseconds (ms) the element should be displayed.\n         *  @param [delay] {Number} Number of milliseconds (ms) the Engine should wait before displaying the element.\n         *  @param [duringDisplayFn] {Function} Function to be called upon displaying the element for another screen refresh. Careful: Keep this function simple, could seriously hamper performance as it's called about every 16-17 ms.  is passed one argument containing all information about the display element.\n         *  @param [onDisplayfn] {Function} Function to be called upon starting to display the element. Is passed one argument containing all information about the display element.\n         */\n\n        //displayElement: function(el, callback, duration, offset, duringDisplaycb) {\n        displayElement: function(paramObj) {\n            var reqAt,\n                id = String(Math.random());\n            //QRTE.log(arguments);\n            if (paramObj.delay === undefined) {\n                paramObj.delay = 0;\n            }\n\n\n\n            if (paramObj.duration === undefined) {\n                paramObj = Infinity;\n            }\n\n            if (isNaN(QRTE.lastRefresh)) {\n                reqAt = window.requestAnimationFrame.now();\n            } else {\n                reqAt = QRTE.lastRefresh;\n            }\n            paramObj.userId = paramObj.id;\n            paramObj.id = id;\n            paramObj.shown = false;\n            paramObj.requestedAt = reqAt;\n            paramObj.hide = false;\n\n            QRTE.currentStack.push(paramObj);\n            if (paramObj.delay === 0) {\n                //This element needs to be displayed as soon as possible\n                QRTE.dispSingleEle(paramObj, QRTE.previousTimestamp);\n            }\n            QRTE.log('Added element to display stack:', paramObj);\n            //console.log('paramObj: ', paramObj.userId, ', duration: ', paramObj.duration);\n\n            return id;\n        },\n\n        hideElement: function(id) {\n            var found = false,\n                i;\n            for (i = 0; i < QRTE.currentStack.length; i += 1) {\n                if (QRTE.currentStack[i].id === id) {\n                    found = true;\n                    QRTE.currentStack[i].hide = true;\n                    this.log('Element to be hidden: ', QRTE.currentStack[i]);\n                }\n            }\n            return found;\n        },\n\n        hideAllElements: function() {\n            for (i = 0; i < QRTE.currentStack.length; i += 1) {\n                QRTE.currentStack[i].hide = true;\n            }\n            QRTE.proceedOnFrameEnd = true;\n        },\n\n        /**\n         * Hide a DrawEngine Element\n         * @private\n         * @method hideSingleEle\n         * @param curEle {Object}\n         */\n        hideSingleEle: function(curEle, timestamp) {\n            curEle.displayOffset = QRTE.projectedRefresh;\n            curEle.displayOffsetTime = window.requestAnimationFrame.now();\n            curEle.el.style.display = 'none';\n            curEle.keep = false;\n            curEle.hide = true;\n            //delete QRTE.currentStack[key];\n            curEle.displayDuration = curEle.displayOffsetTime - curEle.displayOnsetTime;\n            if (curEle.onHideFn !== undefined) {\n                curEle.onHideFn(curEle, timestamp);\n            }\n\n            return curEle;\n\n        },\n\n\n        /**\n         * Display a DrawEngine Element\n         * @private\n         * @method dispSingleEle\n         * @param curEle {Object}\n         */\n        dispSingleEle: function(curEle, timestamp) {\n            curEle.el.style.display = 'block';\n            curEle.displayOnset = QRTE.projectedRefresh;\n            curEle.displayOnsetTime = window.requestAnimationFrame.now();\n            curEle.shown = true;\n            if (curEle.onDisplayFn !== undefined) {\n                //Added try-catch block to catch the error that's causing the OnsetTime not to get saved.\n                try {\n                    curEle.onDisplayFn(curEle, timestamp);\n                } catch (e) {\n                    QRTE.setTrialData('Error[OnsetError]', JSON.stringify(e));\n                }\n            }\n            return curEle;\n        },\n\n        checkEngineCompatibility: function() {\n            return window.requestAnimationFrame.method === 'native-highres';\n        },\n    };=====================================\n     * Copyright 2013-2014 Erwin Haasnoot\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     * http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     *\n     *\n     *\n     * ========================================================== */\n    /**\n     * Qualtrics Reaction Time Engine or QRTE is an add-on providing an interface\n     * for easy reaction time experiment creation in the Qualtrics survey research suite (tm).\n     * For instructions on how to use this add-on, see xxxx\n     *\n     * QRTE was developed by Erwin Haasnoot\n     * Email: erwinhaasnoot[at]gmail.com\n     * @class QRTE\n     *\n     */\n    var QRTE = {\n        version: 'v16',\n        columnsField: 'QRTE_columns',\n        blockDataField: 'QRTE_blockData',\n        idField: 'QRTE_idData',\n        exitQuestions: 'QRTE_exitQuestions',\n        inited: false,\n        /**\n         * TDCache contains the Trial-Level Data in an Object. DO NOT directly manipulate this Object. It might cause inconsistencies in the data file and cause unexpected once parsed.\n         * Use QRTE.setTrialData and QRTE.getTrialData instead.\n         *\n         * @property TDCache\n         * @private\n         * @type Object\n         */\n        TDCache: {},\n\n        /**\n         * ColumnCache contains all the mappings from QID to Columns\n         * @property columnCache\n         * @private\n         * @type Object\n         */\n        columnCache: {},\n\n        /**\n         * BDCache contains the BlockLevel Data in an Object. Directly manipulating this Object might cause inconsistencies\n         * @property BDCache\n         * @private\n         * @type Object\n         */\n        BDCache: {},\n\n        /**\n         * SDCache is a cache for speeding up retrieval of Survey level Data,\n         * All Survey data is saved to both Embedded Data and Survey Data\n         * @private\n         * @property SDCache\n         * @type Object\n         */\n        SDCache: {},\n\n        /**\n         * idCache is a cache for quickly retrieving the Qualtrics QID to QRTLib Id mappings.\n         * Saved in the idData embedded data field after every trial.\n         * @private\n         * @property idCache\n         * @type Object\n         */\n        idCache: {},\n\n        /**\n         * questionQueue contains Objects (stimuli) that are waiting to be presented\n         * @private\n         * @property questionQueue\n         * @type Array\n         */\n        questionQueue: [],\n\n        /**\n         * currentPageQuestions contains the Question Objects that are\n         * displayed at any given time.\n         * @private\n         * @property currentPageQuestions\n         * @type Array\n         */\n        currentPageQuestions: [],\n\n        /**\n         * Contains Trial Data Columns that were 'newly' added in this trial run.\n         * @private\n         * @property newlyAddedColumns\n         * @type Array\n         */\n        newlyAddedColumns: [],\n\n        /**\n         * Contains the Post-Initialization Element.\n         * @private\n         * @property postInitElement\n         * @type Object\n         */\n        postInitElement: {},\n\n        /**\n         * Setter function for Trial-Level Data.\n         * @method setTrialData\n         * @param key {String} Key\n         * @param value {Value} Value\n         */\n        setTrialData: function(key, value) {\n            //Store value in trial cache\n            this.TDCache[key] = value;\n            if (this.BDCache.QRTLib_trialColumns[key] === undefined) {\n                //Add column to overall trial data\n                this.BDCache.QRTLib_trialColumns[key] = '';\n                this.newlyAddedColumns.push(key);\n            }\n        },\n\n        /**\n         * Gets the value of Trial-Level Data field 'key\n         * @method getTrialData\n         * @param key {String} Key\n         */\n        getTrialData: function(key) {\n            return this.TDCache[key];\n        },\n\n        /**\n         * Setter function for Block-Level Data.\n         * @method setBlockData\n         * @param key {String} Key\n         * @param value {Value} Value\n         */\n        setBlockData: function(key, value) {\n            this.BDCache[key] = value;\n        },\n\n\n        /**\n         * Gets the value of Block-Level Data field 'key\n         * @method getBlockData\n         * @param key {String} Key\n         */\n        getBlockData: function(key) {\n            return this.BDCache[key];\n        },\n\n\n\n\n        /**\n         * Stringify the Block Data and store it in the Embedded Data Field. This preserves the values stored on Block Level for use in later trials\n         * @method saveBlockData\n         * @param key {String} Key\n         */\n        saveBlockData: function() {\n            //Store blockData in ED so that we can use it next trial\n            QRTEController.storeBlockData(QRTE.BDCache);\n            Qualtrics.SurveyEngine.setEmbeddedData(QRTE.blockDataField, Object.toJSON(QRTE.BDCache));\n        },\n\n\n\n        /**\n         * Setter function for Survey-Level Data (Embedded Data).\n         * @method setSurveyData\n         * @param key {String} Key\n         * @param value {Value} Value\n         */\n        setSurveyData: function(key, value) {\n            this.SDCache[key] = value;\n            Qualtrics.SurveyEngine.setEmbeddedData(key, value);\n        },\n\n\n\n        /**\n         * Gets the value of Survey-Level Data (Embedded Data) 'key'\n         * @method getSurveyData\n         * @param key {String} Key\n         */\n\n        getSurveyData: function(key) {\n            if (this.SDCache[key] !== undefined) {\n                return this.SDCache[key];\n            }\n            //This only works if the Survey Data has been set during the same trial due to a bug in Qualtrics.\n            return Qualtrics.SurveyEngine.getEmbeddedData(key);\n        },\n\n        /**\n         * Sets a configuration for a question\n         * @method setConfig\n         * @param QID {String} The QRTE Question Id of the Question you want the configuration to apply to\n         * @param option {String} The type of configuration you want to set, Allowed options: 'cresp', 'allowable', 'duration', 'endaction', 'delay'. Refer to website for documentation on these configs\n         * @param value {String} The value the configuration needs to be set to. Differs per option.\n         */\n        setConfig: function(QID, option, value) {\n            var setterFunc;\n            if (typeof QID === 'string') {\n                setterFunc = function(QID, option, value) {\n                    this.setTrialData(QID + \"[\" + option + \"]\", value);\n                };\n            } else {\n                setterFunc = function(QID, option, value) {\n                    this.setTrialData(QID.questionId + \"[\" + option + \"]\", value);\n                    QID['_' + option] = value;\n                };\n\n            }\n\n            this._setConfig(QID, option, value, setterFunc);\n        },\n\n\n        /**\n         * Loads the configuration for a question.\n         * @private\n         * @method loadConfig\n         * @param question {Object} Question for which the configuration needs to be loaded.\n         */\n        loadConfig: function(question) {\n            if (this.idCache[question.questionId] !== undefined) {\n                question.QRTLib_configId = this.idCache[question.questionId];\n            } else {\n                question.QRTLib_configId = question.question;\n            }\n            question.duration = this.getDuration(question);\n            question.allowable = this.getAllowable(question);\n            question.cresp = this.getCResp(question);\n            question.offset = this.getOffset(question);\n            question.endAction = this.getEndAction(question);\n        },\n\n        /**\n         * Stores the accuracy of a trial\n         * @private\n         * @method saveAcc\n         * @param question {Object} Question for which accuracy needs to be stored\n         * @param acc {Integer} Accuracy of question\n         */\n\n        saveAcc: function(question, acc) {\n            if (acc === 0 || acc === 1) {\n                this.setTrialData(question.QRTLibId + \"[ACC]\", acc);\n                this.setSurveyData(\"ACC\", acc);\n            }\n        },\n\n\n\n        /**\n         * Check whether the given response was a correct response\n         * @method isCorrectResponse\n         * @param question {Object} Question for which correct response needs to be checked\n         * @param resp {String} Given response\n         */\n        isCorrectResponse: function(question, resp) {\n            return question.cresp.indexOf(resp) >= 0;\n        },\n\n        /**\n         * Check whether the given response was an allowable response\n         * @method isAllowableResponse\n         * @param question {Object} Question for which allowable response needs to be checked\n         * @param resp {String} Given response\n         */\n        isAllowableResponse: function(question, resp) {\n            return question.allowable.indexOf(resp) >= 0;\n        },\n\n\n\n        /**\n         * Check whether the given response was an allowable response\n         * @private\n         * @method keycode2string\n         * @param e {Object} KeyPress event from which to retrieve the response\n         */\n        keycode2string: function(e) {\n            return String.fromCharCode(e.charCode);\n        },\n\n        /** \n         * Wait for images to load before starting trial.\n         * @property waitForImageLoad\n         * @private\n         * @type Boolean\n         */\n\n        waitForImageLoad: true,\n\n        /** \n         * Trial Start waiting list - initialised with waiting for TrialStart\n         * @property loadWaitingList\n         * @private\n         * @type Array\n         */\n\n        loadWaitingList: [false],\n\n        /**\n         * Initializes the Engine, called at the start of the 'Init' question.\n         * @private\n         * @method initLib\n         * @param blockDataString {String} JSON string containing information saved for this block (block-level data)\n         * @param blockId {String} Id of the current block\n         * @param columns {String} JSON string containing information about the columns that have been defined in this block\n         * @param idData {String} JSON string containing information about the mapping of the QID to the name of the question\n         * @param exitQuestions {String} String containing the currently defined QuestionTags of the Exit questions\n         * @param exitItemTag {String} String containing the Tag of this block's Exit question.\n         */\n\n\n        initLib: function(blockDataString, blockId, columns, idData, exitQuestions, exitItemTag) {\n            //var blockDataString = Qualtrics.SurveyEngine.getEmbeddedData(QRTE.blockDataField),\n            //columns = Qualtrics.SurveyEngine.getEmbeddedData(QRTE.columnsField),\n            //idData = Qualtrics.SurveyEngine.getEmbeddedData(QRTE.idField);\n            var glue;\n            QRTE.fixSetEmbeddedDataBug();\n            //Initialise block Data\n            if (blockDataString === undefined columnData || blockDataString === '') {\n                blockDataString = '{}';\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.blockDataField, blockDataString);\n            }\n\n            this.BDCache = QRTEController.loadBlockData(blockDataString);\n\n            if (this.BDCache.QRTLib_currentBlock !== blockId) {\n                //If this is a new block, initialise a new block\n                this.BDCache = {\n                    QRTLib_currentBlock: blockId,\n                    QRTLib_blockCounter: 1,\n                    QRTLib_trialColumns: {}\n                };\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.blockDataField, Object.toJSON(this.BDCache));\n                if (exitQuestions === null) {exitQuestions = '';}\n                glue = '';\n                if (exitQuestions !== '') {\n                    glue = ';';\n                }\n                //And update the exit questions\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.exitQuestions, exitQuestions + glue + exitItemTag);\n\n            }\n            QRTE.TDCache = Object.toJSON(QRTE.getBlockData('QRTLib_trialColumns')).evalJSON();\n            if (columns === undefined || columns === null || columns === '') {\n                columns = '{}';\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.columnsField, columns);\n            }\n            QRTE.SDCache[QRTE.columnsField] = columns.evalJSON();\n            if (idData === undefined || idData === null || idData === '') {\n                idData = '{}';\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.idField, idData);\n            }\n            QRTE.idCache = idData.evalJSON();\n        },\n\n        /**\n         * Init initializes the QRTEngine, expects are params object with possible fields defined with parameters.\n         * @method Init\n         * @param paramObj {Object} object containing parameters of Init function\n         *  @param paramObj.blockData {String} blockData string in json format (from embedded data)\n         *  @param paramObj.columnData {String} columnData string in json format (from embedded data)\n         *  @param paramObj.exitQuestions {String} exitQuestions string (from embedded data)\n         *  @param paramObj.exitItemTag {String} Tag of the Exit question of this block\n         *  @param paramObj.blockId {String} Identificaton of the block\n         *  @param [paramObj.onLoadFn] {Function} Function to be called when this Question is displayed\n         *  @param [paramObj.interTrialDelay] {Integer|Array} Specify millisecond delay between end of previous trial and beginning of new trial\n         *  @param [paramObj.preTrialDelay] {Integer|Array} Specify millisecond (ms) delay before the start of the first trial of the block. //NYI\n         *  @param [paramObj.initQuestionIndex] {Integer} Specify index of the Init question in the Question Block (defaults to 1)\n         *  @param [paramObj.waitForImages] {Boolean} Specify whether we should wait for images or not. Is on by default, but could be turned off if all images are pre-loaded in cache, or are very small in general.\n         */\n        Init: function(paramObj) {\n            var validationArray, qArray, initIndex;\n            //init the library\n            QRTE.init();\n\n            //set the initIndex (if the Init question is not the first question of the block)\n            QRTE.initIndex = paramObj.initQuestionIndex - 1 || 0;\n\n\n            validationArray = [{\n                name: 'blockData',\n                type: ['JSON', 'Empty'],\n                required: true\n            }, {\n                name: 'columnData',\n                type: ['JSON', 'Empty'],\n                required: true\n            }, {\n                name: 'idData',\n                type: ['JSON', 'Empty'],\n                required: true\n            }, {\n                name: 'blockId',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'onLoadFn',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'interTrialDelay',\n                type: ['Integer', 'Array'],\n                required: false\n            }, {\n                name: 'exitQuestions',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'exitItemTag',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'waitForImages',\n                type: ['Boolean'],\n                required: false\n            }];\n\n            //Validate Parameter Object, outputs stuff to console\n            QRTE.validateParams(paramObj, validationArray, 'Init');\n\n\n            //Initialize the library itself (necessary for each trial)\n            QRTE.initLib(paramObj.blockData, paramObj.blockId, paramObj.columnData, paramObj.idData, paramObj.exitQuestions, paramObj.exitItemTag);\n\n\n            if (paramObj.waitForImages !== undefined) {\n                QRTE.waitForImageLoad = paramObj.waitForImages;\n            }\n            //calculate server communication delay\n            QRTE.setTrialData('InitPre[OnsetTime]', QRTE.getBlockData('QRTLib_previousStorageDone'));\n\n            QRTE.setTrialData('InitPre[OffsetTime]', window.requestAnimationFrame.now());\n            QRTE.setTrialData('InitPre[CalculatedDuration]', QRTE.getTrialData('InitPre[OffsetTime]') - QRTE.getTrialData('InitPre[OnsetTime]'));\n            QRTE.setTrialData('Init[OnsetTime]', window.requestAnimationFrame.now());\n\n\n\n            Qualtrics.SurveyEngine.addOnload(function() {\n                this.qHTML = document.getElementById(this.questionId);\n                this.QRTLib_isActive = false;\n                this.hideChoices();\n                this.proceed = QRTE.proceed;\n                this.QRTLibId = 'InitPost';\n\n                paramObj.onLoadFn.apply(this);\n                var QuestionStackElement = {\n                    questionElement: this,\n                    onShowFunc: function() {},\n                    type: 'Stimulus',\n                    loadConfig: true,\n                    id: 'InitPost',\n                    conditional: function() {\n                        return true;\n                    },\n                    proceedOnHide: true\n\n                };\n                QRTE.setConfig(QuestionStackElement.id, 'duration', 0);\n                QRTE.postInitElement = QuestionStackElement;\n                QRTE.questionQueue.push(QuestionStackElement);\n            });\n\n            if (paramObj.interTrialDelay instanceof Array) {\n                paramObj.interTrialDelay = paramObj.interTrialDelay[Math.floor(Math.random() * paramObj.interTrialDelay.length)];\n            }\n            QRTE.setTrialData(paramObj.blockId + '[InterTrialDelay]', paramObj.interTrialDelay);\n            if (paramObj.interTrialDelay > 0) {\n                QRTE.setBlockData('QRTLib_intraTrialDelay', paramObj.interTrialDelay);\n            } else {\n                QRTE.setBlockData('QRTLib_intraTrialDelay', -1);\n            }\n        },\n\n        /**\n         * Create a Stimulus question\n         * @method Stimulus\n         * @param paramObj {Object}\n         *  @param paramObj.id {String} Id of the Question\n         *  @param paramObj.onShowFn {Function} Function to be called upon showing the question (not the same as upon loading)\n         *  @param [paramObj.conditional] {Function} Function to be called with which to decide whether to present this question or not, should return a boolean.\n         *  @param [paramObj.loadConfig] {Boolean} Load predefined config for this question (defaults to true)\n         *  @param [paramObj.stimContinue] {Boolean} Continue looking for stimuli after having seen this one, only if set to true (defaults to false)\n         *  @param [paramObj.onKeyPress] {Function} Function to be called upon receiving a key press while this Question is active (called next to onAllowableKey or onCorrectKey)\n         *  @param [paramObj.onAllowableKey] {Function} Function to be called upon receiving a key press on a key defined as 'allowable' \n         *  @param [paramObj.onCorrectKey] {Function} Function to be called upon receiving a key press on a key defined as 'correct'\n         *  @param [paramObj.onIncorrectKey] {Function} Function to be called upon receiving an allowable key that is not defined as correct (only if correct responses are defined)\n         *  @param [paramObj.proceedOnHide] {Boolean} Set whether all currently displayed elements should be removed on hide, or if only this should be removed from display (Defaults to True). This allows the user to decouple presentation of a stimulus from proceeding of a slide.\n         *  @param [paramObj.onHideFn] {Function} Function to be called upon Stimulus being hidden\n         *  @param [paramObj.duringDisplayFn] {Function} Function to be called during each frame that the Stimulus is being displayed\n         \n         */\n        Stimulus: function(paramObj) {\n            var validationArray = [{\n                name: 'id',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'onShowFn',\n                type: ['Function'],\n                required: true\n            }, {\n                name: 'conditional',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'loadConfig',\n                type: ['Boolean'],\n                required: false\n            }, {\n                name: 'duringDisplayFn',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'continue',\n                type: ['Boolean'],\n                required: false\n            }, {\n                name: 'onAllowableKey',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'onCorrectKey',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'onKeyPress',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'onIncorrectKey',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'proceedOnHide',\n                type: ['Boolean'],\n                required: false\n            }, {\n                name: 'onHideFn',\n                type: ['Function'],\n                required: false\n            }];\n\n            //Validate Parameter Object, outputs stuff to console\n            QRTE.validateParams(paramObj, validationArray, 'Stimulus');\n\n\n            if (paramObj.conditional === undefined) {\n                paramObj.conditional = function() {\n                    return true;\n                };\n            }\n            if (paramObj.loadConfig === undefined) {\n                paramObj.loadConfig = true;\n            }\n\n            if (paramObj.stimContinue === undefined) {\n                paramObj.stimContinue = false;\n            }\n\n            if (paramObj.proceedOnHide === undefined) {\n                paramObj.proceedOnHide = true;\n            }\n            Qualtrics.SurveyEngine.addOnload(function() {\n                this.QRTLib_isActive = false;\n                this.proceed = QRTE.proceed;\n                this.QRTLibId = paramObj.id;\n                var QuestionStackElement = {\n                    questionElement: this,\n                    onShowFunc: paramObj.onShowFn,\n                    duringDisplayFn: paramObj.duringDisplayFn,\n                    onHideFn: paramObj.onHideFn,\n                    type: 'Stimulus',\n                    loadConfig: paramObj.loadConfig,\n                    id: paramObj.id,\n                    conditional: paramObj.conditional,\n                    stimContinue: paramObj.stimContinue,\n                    onAllowableKey: paramObj.onAllowableKey,\n                    onCorrectKey: paramObj.onCorrectKey,\n                    onKeyPress: paramObj.onKeyPress,\n                    onIncorrectKey: paramObj.onIncorrectKey,\n                    proceedOnHide: paramObj.proceedOnHide\n                };\n                QRTE.questionQueue.push(QuestionStackElement);\n            });\n        },\n\n        /**\n         * Exit denotes the end of the block. Important for the initialization phase and the exit phase.\n         * Make the question a Form question with precisely 2 answer fields (more is unnecessary, those will get ignored)\n         * @method Exit\n         */\n        Exit: function() {\n\n\n            qArray = $('Questions').getElementsByClassName('QuestionOuter');\n            for (var i = 0; i < qArray.length && i < QRTE.initIndex + 1; i += 1) {\n                qArray[i].style.display = 'block';\n            }\n            Qualtrics.SurveyEngine.addOnload(function() {\n                //Hide all choice\n                this.hideChoices();\n                //display the question\n                //this.questionContainer.style.display = 'none';\n                var QuestionStackElement, onShowFn;\n                onShowFn = function() {\n\n                    //Create and/or store standard information about the trial\n                    var blockId = QRTE.getBlockData('QRTLib_currentBlock'),\n                        tempTD = {},\n                        key,\n                        i;\n\n                    QRTE.setBlockData('QRTLib_previousEndTime', window.requestAnimationFrame.now());\n                    QRTE.setTrialData(blockId + '[TrialNr]', QRTE.getBlockData('QRTLib_blockCounter'));\n                    QRTE.setTrialData(blockId + '[RefreshPeriod]', QRTE.refreshPeriod);\n                    QRTE.setTrialData('BlockId', blockId);\n                    QRTE.setTrialData('EngineType', window.requestAnimationFrame.method);\n                    QRTE.setTrialData('Exit[OnsetTime]', window.requestAnimationFrame.now());\n                    QRTE.setTrialData('QRTEngine[Version]', QRTE.version);\n\n                    //CHECK IF ATLEAST TWO FORM FIELDS HAVE BEEN DEFINED\n                    this.setChoiceValue(2, 'testtest');\n                    if (this.getChoiceValue(2) !== 'testtest') {\n                        //alert('You need to define two answer form fields in the Exit question!!');\n                    }\n\n                    for (key in QRTE.TDCache) {\n                        if (QRTE.TDCache.hasOwnProperty(key) && key !== '') {\n                            //Change QID thingies to entered ID's, also force every value to a string so that the Parser handles high numerical values correctly\n                            tempTD[QRTE.getOutputKey(key)] = String(QRTE.TDCache[key]);\n                        }\n                    }\n\n                    this.setChoiceValue(1, Object.toJSON(tempTD));\n                    this.setChoiceValue(2, blockId);\n                    if (QRTE.SDCache[QRTE.columnsField][blockId] === undefined) {\n                        QRTE.SDCache[QRTE.columnsField][blockId] = [];\n                    }\n                    for (i = 0; i < QRTE.newlyAddedColumns.length; i += 1) {\n                        QRTE.SDCache[QRTE.columnsField][blockId].push(QRTE.getOutputKey(QRTE.newlyAddedColumns[i]));\n                    }\n\n                    QRTE.setSurveyData(QRTE.columnsField, Object.toJSON(QRTE.SDCache[QRTE.columnsField]));\n                    QRTE.setBlockData('QRTLib_blockCounter', QRTE.getBlockData('QRTLib_blockCounter') + 1);\n                    QRTE.setBlockData('QRTLib_previousStorageDone', window.requestAnimationFrame.now());\n                    QRTE.saveBlockData();\n\n                    //If wanting to test, uncomment this line and comment the one after that to enforce manual nextbutton clicks\n                    //$('NextButton').style.display = 'block';\n                    //QRTE.submitPage();\n                    QRTEController.loadNextTrial();\n                };\n\n                QuestionStackElement = {\n                    questionElement: this,\n                    onShowFunc: onShowFn,\n                    type: 'Storage',\n                    loadConfig: true,\n                    conditional: function() {\n                        return true;\n                    }\n                };\n                QRTE.questionQueue.push(QuestionStackElement);\n\n                QRTE.startTrial(0);\n\n            });\n\n            QRTE.loadWaitingList = [false];\n            if (QRTE.waitForImageLoad === true) {\n                //set wait for image load queues.\n                var loadIndex = 1,\n                    images = $$('.QuestionOuter img'),\n                    i = 0;\n\n                var l = images.length;\n                for (; i < l; i += 1) {\n                    images[i].observe('load', function(e) {\n                        QRTE.startTrial(e.path[0].QRTELoadIndex);\n                    })\n                    images[i].QRTELoadIndex = i + 1;\n                    QRTE.loadWaitingList[i + 1] = false;\n                }\n\n            }\n\n        },\n\n        /**\n         * Remove the padding Qualtrics adds between Questions (causes question presentation to drift downwards if not called).\n         * DEPRECATED: Separators hidden through CSS now\n         * @method removeSeparators\n         * @private\n         */\n        removeSeparators: function() {\n            var questionElement = document.getElementById('Questions'),\n                index;\n            for (index = 0; index < questionElement.children.length; index += 1) {\n                if (questionElement.children[index].className === \"Separator\") {\n                    questionElement.children[index].parentNode.removeChild(questionElement.children[index]);\n                }\n            }\n        },\n        /**\n         * Notifies the engine the first trial is ready to be started. Called at the end of the 'exit' question\n         * @private\n         * @method startTrial\n         */\n        startTrial: function(startId) {\n            var duringDisplayFn, onHideFn, onDisplayFn, serverCommDelay, remainingDelay;\n            //All questions have been hidden, so display the parent block again\n            //$('Questions').style.display = 'block';\n\n            QRTE.loadWaitingList[startId] = true;\n            if (!QRTE.loadWaitingList.every()) {\n                QRTE.log('Process ' + startId + 'finished, waiting for other processes to finish')\n                return;\n            }\n\n            //Save the absolute time of when onLoad part of library was finished\n            serverCommDelay = window.requestAnimationFrame.now() - QRTE.getBlockData('QRTLib_previousEndTime'); //Calculate the remaining time based on the lib initialization + server delay times\n            remainingDelay = QRTE.getBlockData('QRTLib_intraTrialDelay') - serverCommDelay;\n\n\n            if (isNaN(remainingDelay)) {\n                remainingDelay = QRTE.getBlockData('QRTLib_intraTrialDelay') * 3;\n                //If this init call is the first one of the block (first trial), calculate the estimated refreshdelay during the pre-trial interval\n                onDisplayFn = function(ele, time) {\n                    QRTE.setTrialData('Init[OffsetTime]', ele.displayOnsetTime);\n                    QRTE.setTrialData('Init[CalculatedDuration]', ele.displayOnsetTime - QRTE.getTrialData('Init[OnsetTime]'));\n                    QRTE.refreshPeriodEstimationStack = [];\n                };\n                duringDisplayFn = function(ele, time) {\n                    //Get current time, required for \n                    QRTE.refreshPeriodEstimationStack.push(time);\n                };\n                onHideFn = function(ele, timestamp) {\n                    var diffs = [];\n\n                    for (i = 1; i < QRTE.refreshPeriodEstimationStack.length; i += 1) {\n                        diffs[i - 1] = QRTE.refreshPeriodEstimationStack[i] - QRTE.refreshPeriodEstimationStack[i - 1];\n                    }\n                    QRTE.refreshPeriod = QRTE.median(diffs);\n                    QRTE.log('Estimated refresh delay = ' + QRTE.refreshPeriod);\n                    QRTE.setBlockData('QRTE_refreshPeriod', QRTE.refreshPeriod);\n                    QRTE.referenceTime = timestamp;\n                    QRTE.framesSinceReference = 0;\n                };\n            } else {\n                onDisplayFn = function(ele, time) {\n                    QRTE.setTrialData('Init[OffsetTime]', ele.displayOnsetTime);\n                    QRTE.setTrialData('Init[CalculatedDuration]', ele.displayOnsetTime - QRTE.getTrialData('Init[OnsetTime]'));\n                };\n\n                QRTE.refreshPeriod = QRTE.getBlockData('QRTE_refreshPeriod');\n            }\n\n            //QRTE.setTrialData('ITI[Duration]', (remainingDelay > 0) ? remainingDelay : 0);\n            QRTE.initTime = window.requestAnimationFrame.now();\n\n            QRTE.postInitElement.onHideFn = onHideFn;\n            QRTE.postInitElement.onDisplayFn = onDisplayFn;\n            QRTE.postInitElement.duringDisplayFn = duringDisplayFn;\n            QRTE.setConfig('InitPost', 'duration', (remainingDelay > 0) ? remainingDelay : 0);\n            //UNCOMMENT\n            //QRTE.setConfig('InitPost', 'duration', (remainingDelay > 0) ? remainingDelay : Infinity);\n            QRTE.inited = true;\n\n            //Set initial trial data related to loading of this trial\n            QRTE.setTrialData('InitServerComm[Onset]', QRTE.getBlockData('ServerCommOnset'));\n            QRTE.setTrialData('InitServerComm[Offset]', QRTE.getBlockData('ServerCommOffset'));\n            QRTE.setTrialData('InitServerComm[CalculatedDuration]', QRTE.getBlockData('ServerCommOffset') - QRTE.getBlockData('ServerCommOnset'));\n\n            //<Load next trial here>\n            var currentLoops = '${lm://CurrentLoopNumber}',\n                totalLoops = '${lm://TotalLoops}';\n            //Check if last trial, currentloops === totalLoops;\n            QRTEController.requestNextTrial(currentLoops !== '' && currentLoops === totalLoops);\n\n            QRTE.proceed();\n        },\n\n\n\n        proceed: function() {\n            QRTE.log(\"proceed called after \" + window.requestAnimationFrame.now() - QRTE.initTime);\n            QRTE.hideAllElements();\n        },\n\n        proceedPage: function() {\n            var currentQ;\n            QRTE.log(\"Proceeding page..\");\n            while (QRTE.currentPageQuestions.length > 0) {\n                currentQ = QRTE.currentPageQuestions.shift();\n\n                //Disable\n                currentQ.questionElement.QRTLib_isActive = false;\n            }\n\n\n            //Go to next question\n            QRTE.showNextPage();\n        },\n\n        disableQuestion: function(disableQ) {},\n\n        /**\n         * Determine and show the next page/slide\n         * @private\n         * @method showNextPage\n         */\n        showNextPage: function() {\n            var continueSearch = true,\n                shownQ = false,\n                nextQ,\n                shown;\n            while (continueSearch === true) {\n                continueSearch = false;\n                nextQ = QRTE.questionQueue.shift();\n                if (nextQ !== undefined && (nextQ.type === 'Stimulus' || nextQ.type === 'Storage')) {\n                    QRTE.currentPageQuestions.push(nextQ);\n                    shown = QRTE.showStimulusQuestion.apply(nextQ.questionElement, [nextQ]);\n\n                    if (nextQ.stimContinue) {\n                        continueSearch = true;\n                        if (shown === true) {\n                            shownQ = true;\n                        }\n                    }\n                    QRTE.log('shown ' + nextQ.id + ': ' + shown);\n                    QRTE.log('continue ' + nextQ.id + ': ' + continueSearch);\n                    if (shown === false && shownQ === false) {\n                        continueSearch = true;\n                    }\n                }\n            }\n\n        },\n\n        /**\n         * Show Question\n         * Handles the activation of that question, which includes:\n         * The loading of the configuration (duration, allowable keys etc).\n         * Sets the event handler to respond to any key presses during the event.\n         * @private\n         * @method showStimulusQuestion\n         * @param question {Object} question to be shown.\n         *  @param id {String} Id of question.\n         *  @param onShowFunc {Function} Function to be called when showing question\n         *  @param loadConfig {Boolean} If true, config is loaded from the current block data (which has been defined elsewhere)\n         *  @param questionElement {Object} This Qualtrics question element\n         *  @param duringDisplayFn {Function} Function to be called each frame that the question is presented\n         */\n        showStimulusQuestion: function(question) {\n            //Save the loading start time\n            //QRTE.setTrialData(question.questionElement.QRTLibId + '[LoadStartTime]', window.requestAnimationFrame.now());\n            //Set mapping of the QID -> QRTE Id\n            QRTE.setId(this, question.id);\n\n            //Initialize variables\n            var stimulusShown = false,\n                questionScope = this,\n                dispEle;\n            QRTE.log(question);\n\n            //Check whether question should be shown or not, if not skip to the next question (implicitly)\n            if (question.conditional() === true) {\n                this.QRTLib_isActive = true;\n\n\n                if (question.loadConfig === true) {\n                    //Load the Configuration of the Question, important!\n                    QRTE.loadConfig(this);\n                }\n\n                //Check if KeyPress listener is required (one or more of the following fields are defined: onKeyPress, onCorrectKey or onAllowableKey)\n                //If so, add keypress listener.\n                if (question.onKeyPress !== undefined || question.questionElement.allowable !== '' || question.questionElement.cresp !== '') {\n                    //Initialize the fields used for storing data about RT timing.\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[RTTime]', '');\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[RT]', '');\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[RESP]', '');\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[ACC]', 0);\n\n                    //Add the key listener\n                    QRTE.addKeyListener(function(e) {\n\n                        //Get the Key of the response\n                        var RT, RESP = QRTE.keycode2string(e),\n                            RTTime = window.requestAnimationFrame.now();\n                        RT = RTTime - QRTE.getTrialData(question.questionElement.QRTLibId + '[OnsetTime]');\n\n                        //Store the Time of the Key Press and calculate the RT and ACC if correct\n\n                        if ((QRTE.isAllowableResponse(question.questionElement, RESP) || QRTE.isCorrectResponse(question.questionElement, RESP)) && QRTE.getTrialData(question.questionElement.QRTLibId + '[RTTime]') === '') {\n                            QRTE.setTrialData(question.questionElement.QRTLibId + '[RTTime]', RTTime);\n                            QRTE.setTrialData(question.questionElement.QRTLibId + '[RT]', RT);\n                            QRTE.setTrialData(question.questionElement.QRTLibId + '[RESP]', RESP);\n                            if (QRTE.isCorrectResponse(question.questionElement, RESP)) {\n                                QRTE.saveAcc(question.questionElement, 1);\n                            } else {\n                                QRTE.saveAcc(question.questionElement, 0);\n                            }\n                        }\n\n                        //Store the RT and the Response\n\n                        //Set Handling Key Press to true, this lets the engine know that a keypress is currently being handled. Necessary when there is a timer (response deadline)\n                        question.handlingKeyPress = true;\n\n                        if (question.onCorrectKey !== undefined && QRTE.isCorrectResponse(question.questionElement, RESP)) {\n                            question.onCorrectKey.apply(question.questionElement, [e, RESP]);\n                        } else if (question.onIncorrectKey !== undefined && QRTE.isAllowableResponse(question.questionElement, RESP)) {\n                            question.onIncorrectKey.apply(question.questionElement, [e, RESP]);\n                        }\n\n                        if (question.onAllowableKey !== undefined && QRTE.isAllowableResponse(question.questionElement, RESP)) {\n                            question.onAllowableKey.apply(question.questionElement, [e, RESP]);\n                        }\n\n                        if (question.onKeyPress !== undefined) {\n                            question.onKeyPress.apply(question.questionElement, [e, RESP]);\n                        }\n\n                        if (question.questionElement.endAction === 'TERMINATE') {\n                            //Proceed to the next Question Page if the response is allowable\n                            if (QRTE.isAllowableResponse(question.questionElement, RESP) && question.questionElement.QRTLib_isActive === true) {\n                                question.questionElement.proceed();\n                            }\n                        }\n                        question.handlingKeyPress = false;\n\n                    }, this);\n                }\n\n                //Build the display Element. Stimuli Questions have to take into account the possibility of being associated with a key press. \n                //OnDisplayFn therefore logs the displayOnsetTime, so that the RT can be calculated.\n                dispEle = {\n                    el: this.questionContainer,\n                    duration: this.duration,\n                    delay: this.offset,\n                    duringDisplayFn: question.duringDisplayFn,\n                    onDisplayFn: function(displayEl, timestamp) {\n                        if (question.onDisplayFn !== undefined) {\n                            question.onDisplayFn(displayEl, timestamp);\n                        }\n                        QRTE.setTrialData(questionScope.QRTLibId + '[OnsetTime]', displayEl.displayOnsetTime);\n                    },\n                    proceedOnHide: question.proceedOnHide,\n                    id: question.id\n                };\n\n                //Set the OnHide Function\n                dispEle.onHideFn = function(displayEl, timestamp) {\n                    if (question.onHideFn !== undefined) {\n                        question.onHideFn(displayEl, timestamp);\n                    }\n                    QRTE.setTrialData(questionScope.QRTLibId + '[OffsetTime]', displayEl.displayOffsetTime);\n                    QRTE.setTrialData(questionScope.QRTLibId + '[CalculatedDuration]', displayEl.displayDuration);\n                };\n\n\n                this.QRTLib_timer = QRTE.displayElement(dispEle);\n\n                question.onShowFunc.apply(this);\n\n                stimulusShown = true;\n            }\n\n            //QRTE.setTrialData(question.questionElement.QRTLibId + '[LoadEndTime]', window.requestAnimationFrame.now());\n            return stimulusShown;\n        },\n\n        setId: function(question, desc) {\n\n            this.idCache[question.questionId] = desc;\n            question.qId = desc;\n\n            Qualtrics.SurveyEngine.setEmbeddedData(QRTE.idField, Object.toJSON(this.idCache));\n        },\n\n        getOutputKey: function(key) {\n            var oldKey;\n            for (oldKey in this.idCache) {\n                if (this.idCache.hasOwnProperty(oldKey) && oldKey === key.substring(0, oldKey.length)) {\n\n                    return QRTE.getBlockData('QRTLib_currentBlock') + this.idCache[oldKey] + key.substring(oldKey.length, key.length);\n                }\n            }\n            return key;\n        },\n\n\n        OnKeyPress: function(fn, qScope) {\n\n            qScope = qScope || window;\n\n            var keyFn = function(e) {\n                QRTE.setTrialData(qScope.QRTLibId + '[RTTime]', window.requestAnimationFrame.now());\n                var RT = QRTE.getTrialData(qScope.QRTLibId + '[RTTime]') - QRTE.getTrialData(qScope.QRTLibId + '[OnsetTime]');\n                QRTE.setTrialData(qScope.QRTLibId + '[RT]', RT);\n                QRTE.setTrialData(qScope.QRTLibId + '[RESP]', QRTE.keycode2string(e));\n                QRTE.log(qScope);\n                fn.apply(qScope, [e]);\n            }\n\n            QRTE.addKeyListener(keyFn, qScope);\n        },\n\n        addKeyListener: function(fn, listenerScope) {\n            Event.observe(document, 'keypress', function(e) {\n                if (listenerScope.QRTLib_isActive === true) {\n                    fn.apply(listenerScope, [e]);\n                }\n            });\n        },\n\n        /*  \n         **************Methods below this line are support methods*******************\n         */\n\n        hideQuestions: function() {\n            qArray = $('Questions').getElementsByClassName('QuestionOuter');\n            for (var i = 0; i < qArray.length; i += 1) {\n                qArray[i].style.display = 'none';\n            }\n        },\n\n        unhideQuestions: function() {\n            //Redisplay outer questions\n            qArray = $('Questions').getElementsByClassName('QuestionOuter');\n            for (var i = 0; i < qArray.length; i += 1) {\n                qArray[i].style.display = 'block';\n            }\n            //Redisplay separators\n            qArray = $('Questions').getElementsByClassName('Separator');\n            for (var i = 0; i < qArray.length; i += 1) {\n                qArray[i].style.display = 'block';\n            }\n\n\n        },\n\n        _handleKeyPressEvent: function() {\n\n        },\n\n        _setConfig: function(QID, option, value, setterFunc) {\n            var qidString = QID;\n            if (typeof QID !== 'string') {\n                qidString = QID.questionId;\n            }\n            option = option.toLowerCase();\n\n            switch (option) {\n                case 'duration':\n                    if (value instanceof Array) {\n                        value = value[Math.floor(Math.random() * value.length)];\n                    }\n                    setterFunc.apply(this, [qidString, 'Duration', value]);\n                    break;\n                case 'allowable':\n                    setterFunc.apply(this, [qidString, 'Allowable', value]);\n                    break;\n                case 'cresp':\n                    setterFunc.apply(this, [qidString, 'CRESP', value]);\n                    break;\n                case 'delay':\n                    setterFunc.apply(this, [qidString, 'Offset', value]);\n                    break;\n                case 'endaction':\n                    setterFunc.apply(this, [qidString, 'EndAction', value]);\n                    break;\n                default:\n                    QRTE.log('No such configuration: ' + option);\n                    break;\n            }\n        },\n        getDuration: function(question) {\n            var duration = Infinity,\n                edDuration = this.getTrialData(question.QRTLib_configId + '[Duration]');\n            if (edDuration !== undefined && edDuration !== '' && !isNaN(edDuration)) {\n                duration = edDuration;\n            }\n            if (question._Duration !== undefined && question._Duration !== '' && !isNaN(question._Duration)) {\n                duration = question._Duration;\n            }\n\n            return duration;\n        },\n        getAllowable: function(question) {\n            var allowable = \"\",\n                edAllowable = this.getTrialData(question.QRTLib_configId + '[Allowable]');\n            if (edAllowable !== undefined) {\n                allowable = edAllowable;\n            }\n            if (question._Allowable !== undefined) {\n                allowable = question._Allowable;\n            }\n\n            if (allowable === '{ANY}') {\n                allowable = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890-=[]\\\\;',./`\";\n            }\n            //allowable = allowable.toUpperCase();\n            return allowable;\n        },\n        getCResp: function(question) {\n            var cresp = '',\n                edcresp = this.getTrialData(question.QRTLib_configId + '[CRESP]');\n            if (edcresp !== undefined) {\n                cresp = edcresp;\n            }\n            if (question._cresp !== undefined) {\n                cresp = question._CRESP;\n            }\n\n            if (cresp === '{ANY}') {\n                cresp = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890-=[]\\\\;',./`\";\n            }\n            //cresp = cresp.toUpperCase();\n\n            return cresp;\n        },\n\n        getOffset: function(question) {\n            var offset = 0,\n                edOffset = this.getTrialData(question.QRTLib_configId + '[Offset]');\n            if (edOffset !== undefined && edOffset !== '' && !isNaN(edOffset)) {\n                offset = edOffset;\n            }\n            if (question._Offset !== undefined && question._Offset !== '' && !isNaN(question._Offset)) {\n                offset = question._Offset;\n            }\n\n            return offset;\n\n        },\n\n        getEndAction: function(question) {\n            var endAction = 'NONE',\n                edEndAction = this.getTrialData(question.QRTLib_configId + '[EndAction]');\n            if (edEndAction !== undefined && edEndAction !== '') {\n                endAction = edEndAction;\n            }\n            if (question._EndAction !== undefined && question._EndAction !== '') {\n                endAction = question._EndAction;\n            }\n\n            return endAction;\n\n        },\n        evaluateConditional: function(conditional) {\n            QRTE.log('Conditional: ', conditional);\n            return conditional === '' || conditional();\n        },\n        log: function() {\n            if (QRTE.debug === true) {\n                for (var i = 0; i < arguments.length; i += 1) {\n                    console.log(arguments[i]);\n                }\n            }\n        },\n\n        median: function(values) {\n\n            values.sort(function(a, b) {\n                return a - b;\n            });\n\n            var half = Math.floor(values.length / 2);\n\n            if (values.length % 2) return values[half];\n            else return (values[half - 1] + values[half]) / 2.0;\n        },\n\n        waitForKey: function(question, keys) {\n            Event.observe(document, 'keypress', function(e) {\n                var resp = QRTE.keycode2string(e);\n                if (keys.indexOf(resp) >= 0) {\n                    question.clickNextButton();\n                }\n            });\n        },\n\n        validateParams: function(paramObj, validationArray) {\n            var valObj, val, index, typeCheck = true,\n                indexType;\n            //Loop over validationArray to check whether parameters suffice\n            for (index = 0; index < validationArray.length; index += 1) {\n                valObj = validationArray[index];\n                if (paramObj[valObj.name] === undefined && valObj.required === true) {\n                    alert('Required parameter: ' + valObj.name + ' seems to be missing');\n                    QRTE.log('Required parameter: ' + valObj.name + ' seems to be missing');\n                    break;\n                }\n\n                val = paramObj[valObj.name];\n\n                //Loop over type checkers\n                for (indexType = 0; indexType < valObj.type.length; indexType += 1) {\n                    typeCheck = QRTE.validateType(val, valObj.type[indexType]);\n                    if (typeCheck === true) {\n                        break;\n                    }\n                }\n                if (typeCheck === false && valObj.required === true) {\n                    alert('Parameter: ' + valObj.name + ' is of the wrong type, expected type: ' + valObj.type + ', type received: ' + (typeof val) + \"\\n\" + \"Please open the console for detailed error messages\");\n                    QRTE.log('Parameter: ' + valObj.name + ' is of the wrong type, expected type: ' + valObj.type + ', type received: ' + (typeof val));\n                    QRTE.log('Faulty parameter ' + valObj.name + ': ', val);\n                    QRTE.log('Proper functioning of QRTE is no longer guaranteed, please fix the above error');\n                }\n\n            }\n        },\n\n        validateType: function(val, type) {\n            switch (type) {\n                case 'JSON':\n                    return val.isJSON();\n                case 'String':\n                    return (typeof val === 'string' || val instanceof String);\n                case 'Number':\n                    return (!isNaN(parseFloat(val)) && isFinite(val));\n                case 'Array':\n                    return val instanceof Array;\n                case 'Object':\n                    return typeof val === 'object';\n                case 'Function':\n                    return typeof val === 'function';\n                case 'Boolean':\n                    return (val === true || val === false);\n                case 'Empty':\n                    return val === '';\n                default:\n                    return false;\n            }\n        },\n\n        fixSetEmbeddedDataBug: function() {\n            Qualtrics.SurveyEngine.setEmbeddedData = function(key, value) {\n                var fieldName = 'ED~' + key;\n                if ($(fieldName)) {\n                    $(fieldName).value = value;\n                } else {\n                    $('Header').appendChild(QBuilder('input', {\n                        type: 'hidden',\n                        id: fieldName,\n                        name: fieldName,\n                        value: value\n                    }));\n                    Qualtrics.SurveyEngine.setEmbeddedData(key, value);\n                }\n            }\n        },\n\n        //DisplayEngine part\n\n        //Since it's impossible to know when a screen refresh has happened, we assume that the first timestamp is the actual screen refresh.\n        //Based on the difference between the current timestamp Tn and the root timestamp Tn-1, we estimate the amount of frames that have passed since. \n        //Based on the amount of frames we estimate the previous screen refresh. Although not perfect, it's the best we can do.\n\n        refreshRate: 60, //hertz\n        refreshPeriod: 1000 / 60,\n        lastRefresh: 0,\n        currentRefresh: 0,\n        previousTimestamp: 0,\n        referenceTime: 0,\n        framesSinceReference: 0,\n        currentStack: [],\n        proceedOnFrameEnd: false,\n\n        init: function() {\n            window.requestAnimationFrame(QRTE.draw);\n        },\n\n        draw: function(timestamp) {\n            var curEle, newStack = [];\n            timestamp = window.requestAnimationFrame.now();\n\n\n            if (timestamp < 1e12) {\n                timestamp += window.performance.timing.navigationStart;\n            }\n\n            if (QRTE.referenceTime === 0) {\n                QRTE.referenceTime = timestamp;\n                QRTE.previousTimestamp = timestamp;\n                QRTE.framesSinceReference = 0;\n            } else {\n                //QRTE.framesSinceReference += QRTE.calcFrames(QRTE.referenceTime, timestamp);\n                QRTE.prevFrames = QRTE.framesSinceReference;\n                //frameDiff =  QRTE.calcFrames(QRTE.referenceTime, timestamp) - QRTE.prevFrames;\n                QRTE.framesSinceReference = QRTE.calcFrames(QRTE.referenceTime, timestamp);\n            }\n            QRTE.currentRefresh = (QRTE.framesSinceReference * QRTE.refreshPeriod) + QRTE.referenceTime;\n            QRTE.projectedRefresh = QRTE.currentRefresh + QRTE.refreshPeriod;\n            curEle = QRTE.currentStack.shift();\n\n            while (curEle) {\n                curEle.keep = true;\n\n                //Call duringDisplay callback function, with the current element and the timestamp as arguments.\n                if (curEle.shown === true && typeof curEle.duringDisplayFn === 'function') {\n                    curEle.duringDisplayFn(curEle, timestamp);\n                }\n\n                if (QRTE.proceedOnFrameEnd === true || curEle.hide === true || (curEle.shown === true && curEle.displayOnset !== undefined && (curEle.displayOnset + curEle.duration < QRTE.projectedRefresh))) {\n                    //If the next refresh makes it go beyond the duration, hide the element again!\n                    curEle = QRTE.hideSingleEle(curEle, timestamp);\n                } else if (curEle.shown === false && curEle.requestedAt + curEle.delay < QRTE.projectedRefresh) {\n                    curEle = QRTE.dispSingleEle(curEle, timestamp);\n                }\n\n                if (curEle.keep === false && curEle.proceedOnHide === true) {\n                    //Behold! We have found an element that commands us to proceed to the next page.\n                    QRTE.proceedOnFrameEnd = true;\n                    //Every element that has been processed so far needs to be re-processed (sadly), so that they properly hide.\n                    for (var ind = 0; ind < newStack.length; ind += 1) {\n                        if (newStack[ind].hide !== true) {\n                            newStack[ind].hide = true;\n                            QRTE.currentStack.push(newStack[ind]);\n                        }\n                    }\n                } else {\n                    //Push it to the newStack, for it to be processed next time.\n                    newStack.push(curEle);\n                }\n\n                curEle = QRTE.currentStack.shift();\n            }\n            QRTE.currentStack = newStack;\n            QRTE.lastRefresh = QRTE.currentRefresh;\n            QRTE.previousTimestamp = timestamp;\n            window.requestAnimationFrame(QRTE.draw);\n            if ((newStack.length === 0 || QRTE.proceedOnFrameEnd) && QRTE.inited === true) {\n                QRTE.proceedOnFrameEnd = false;\n                QRTE.proceedPage();\n            }\n\n\n        },\n\n        calcFrames: function(previous, current) {\n            var diff = current - previous,\n                frames = 0;\n\n            if (diff < QRTE.refreshPeriod) {\n                frames = 1;\n            } else {\n                frames = Math.floor(diff / QRTE.refreshPeriod);\n                if (diff % QRTE.refreshPeriod >= (QRTE.refreshPeriod * 0.9)) {\n                    frames += 1;\n                }\n            }\n\n            return frames;\n        },\n\n        /**\n         * Display an element for a specified duration with a specified delay. Vsyncs the display duration using requestAnimationFrame (if possible in the browser)\n         * and allows for high-precision control over its duration. Please start any custom attributes for the paramObj with the 'custom_' header, to avoid collisions.\n         * @private\n         * @method displayElement\n         * @param paramObj {Object}\n         *  @param el {Object} HTML element to be displayed\n         *  @param [onHideFn] {Function} Function to be called upon removing the element from display, is passed one argument containing all information about the display element.\n         *  @param [duration] {Number} Number of milliseconds (ms) the element should be displayed.\n         *  @param [delay] {Number} Number of milliseconds (ms) the Engine should wait before displaying the element.\n         *  @param [duringDisplayFn] {Function} Function to be called upon displaying the element for another screen refresh. Careful: Keep this function simple, could seriously hamper performance as it's called about every 16-17 ms.  is passed one argument containing all information about the display element.\n         *  @param [onDisplayfn] {Function} Function to be called upon starting to display the element. Is passed one argument containing all information about the display element.\n         */\n\n        //displayElement: function(el, callback, duration, offset, duringDisplaycb) {\n        displayElement: function(paramObj) {\n            var reqAt,\n                id = String(Math.random());\n            //QRTE.log(arguments);\n            if (paramObj.delay === undefined) {\n                paramObj.delay = 0;\n            }\n\n\n\n            if (paramObj.duration === undefined) {\n                paramObj = Infinity;\n            }\n\n            if (isNaN(QRTE.lastRefresh)) {\n                reqAt = window.requestAnimationFrame.now();\n            } else {\n                reqAt = QRTE.lastRefresh;\n            }\n            paramObj.userId = paramObj.id;\n            paramObj.id = id;\n            paramObj.shown = false;\n            paramObj.requestedAt = reqAt;\n            paramObj.hide = false;\n\n            QRTE.currentStack.push(paramObj);\n            if (paramObj.delay === 0) {\n                //This element needs to be displayed as soon as possible\n                QRTE.dispSingleEle(paramObj, QRTE.previousTimestamp);\n            }\n            QRTE.log('Added element to display stack:', paramObj);\n            //console.log('paramObj: ', paramObj.userId, ', duration: ', paramObj.duration);\n\n            return id;\n        },\n\n        hideElement: function(id) {\n            var found = false,\n                i;\n            for (i = 0; i < QRTE.currentStack.length; i += 1) {\n                if (QRTE.currentStack[i].id === id) {\n                    found = true;\n                    QRTE.currentStack[i].hide = true;\n                    this.log('Element to be hidden: ', QRTE.currentStack[i]);\n                }\n            }\n            return found;\n        },\n\n        hideAllElements: function() {\n            for (i = 0; i < QRTE.currentStack.length; i += 1) {\n                QRTE.currentStack[i].hide = true;\n            }\n            QRTE.proceedOnFrameEnd = true;\n        },\n\n        /**\n         * Hide a DrawEngine Element\n         * @private\n         * @method hideSingleEle\n         * @param curEle {Object}\n         */\n        hideSingleEle: function(curEle, timestamp) {\n            curEle.displayOffset = QRTE.projectedRefresh;\n            curEle.displayOffsetTime = window.requestAnimationFrame.now();\n            curEle.el.style.display = 'none';\n            curEle.keep = false;\n            curEle.hide = true;\n            //delete QRTE.currentStack[key];\n            curEle.displayDuration = curEle.displayOffsetTime - curEle.displayOnsetTime;\n            if (curEle.onHideFn !== undefined) {\n                curEle.onHideFn(curEle, timestamp);\n            }\n\n            return curEle;\n\n        },\n\n\n        /**\n         * Display a DrawEngine Element\n         * @private\n         * @method dispSingleEle\n         * @param curEle {Object}\n         */\n        dispSingleEle: function(curEle, timestamp) {\n            curEle.el.style.display = 'block';\n            curEle.displayOnset = QRTE.projectedRefresh;\n            curEle.displayOnsetTime = window.requestAnimationFrame.now();\n            curEle.shown = true;\n            if (curEle.onDisplayFn !== undefined) {\n                //Added try-catch block to catch the error that's causing the OnsetTime not to get saved.\n                try {\n                    curEle.onDisplayFn(curEle, timestamp);\n                } catch (e) {\n                    QRTE.setTrialData('Error[OnsetError]', JSON.stringify(e));\n                }\n            }\n            return curEle;\n        },\n\n        checkEngineCompatibility: function() {\n            return window.requestAnimationFrame.method === 'native-highres';\n        },\n    };\n\n    if (typeof QRTEController == 'undefined') {\n        //QRTE SurveySlider controller layer\n        //Takes care of progressing through the survey. Catches all qualtrics native ways of submitting the form and replaces that by\n        //its own asynchronous ajax stuff.\n        QRTEController = {\n\n\n            //This plug-in to QRTEngine has been developed under the name SurveySlider\n            // for general Qualtrics Surveys. It has been adapted to work with QRTEngine\n            nextTrialContainer: null,\n            nextTrialText: '',\n            currentForm: null,\n            previousForm: null,\n            handlingSubmit: false,\n            onSubmitStack: [],\n            inited: false,\n            childInputs: [],\n            loadUponCallback: false,\n            setEmbeddedData: function() {},\n            tempED: {},\n\n\n\n            //Initialize thecontroller\n            init: function() {\n                this.nextTrialContainer = new Element('div', {\n                    id: 'nextTrialContainer'\n                });\n                this.currentForm = $$('form')[0];\n\n                //Catch submits and change it with our own submit function (which does AJAX submissions)\n                //this.currentForm.observe('QRTE:submit', QRTE.handleSubmit);\n                this.currentElements = $$('.QuestionOuter');\n\n                //Initial SSload firing\n                Qualtrics.SurveyEngine.addOnload(function() {\n                    QRTEController.currentForm.fire('QRTE:load');\n                });\n                //Change SurveyEngine.OnLoad to trigger on SSload, rather than page load\n                Qualtrics.SurveyEngine.addOnload = function(f) {\n                        var questions = $$('.QuestionOuter'),\n                            currentCount = QRTEController.count(Qualtrics.SurveyEngine.QuestionInfo),\n                            id = questions[currentCount - 1].id;\n                        if ($('body') && $('body').hasClassName('EditSection')) return;\n                        try {\n                            var obj = new Qualtrics.SurveyEngine.QuestionData(id);\n                            obj.onload = f;\n\n                            QRTEController.currentForm.observe('QRTE:load', obj.onload.bind(obj));\n                            //Event.observe(this.currentForm, 'SSload', obj.onload.bind(obj));\n                        } catch (e) {\n                            console.error('SE API Error: ' + e);\n                        }\n                    }\n                    //Set the Qualtrics setEmbeddedData to inside the QRTEController\n                QRTEController.setEmbeddedData = Qualtrics.SurveyEngine.setEmbeddedData;\n                Qualtrics.SurveyEngine.setEmbeddedData = function(key, value) {\n                    QRTEController.tempED[key] = value;\n                }\n                this.submitPage = this.requestNextTrial;\n                this.inited = true;\n            },\n\n            /**\n             * Requests the next trial from the Qualtrics server.\n             *\n             *\n             */\n            requestNextTrial: function(isLastTrial) {\n\n                //If this is the last trial of a block, DON'T request the next page, let qualtrics handle it themselves\n                if (this.handlingSubmit === false && isLastTrial === false) {\n                    //Load next trial means that current page is a trial and has been inited\n                    //Need to remove relevant input elements from current form before submitting\n                    //After that add them back\n                    this.handlingSubmit = true\n                    var childs = $$('form input[type=text]'),\n                        childInputs = [];\n                    //remove current input elements from the form\n                    for (var i = 0; i < childs.length; i += 1) {\n                        childInputs[i] = {\n                            ele: childs[i],\n                            parent: childs[i].up()\n                        };\n                        childs[i].remove();\n                    }\n                    //add previous input elements to form\n                    //Text inputs\n                    for (var i = 0; i < this.childInputs.length; i += 1) {\n                        this.childInputs[i].ele.style.display = 'none';\n                        this.currentForm.insert(this.childInputs[i].ele);\n                    }\n\n\n                    //And embedded data\n                    for (var key in this.tempED) {\n                        if (this.tempED.hasOwnProperty(key)) {\n                            QRTEController.setEmbeddedData(key, this.tempED[key]);\n                        }\n                    }\n                    //Reset stored embedded data\n                    this.tempED = {};\n                    //set new childs\n                    this.childInputs = childInputs;\n\n                    //Loop over submit stack, or callbacks that need to be finished before submitting\n                    for (var i = 0; i < QRTEController.onSubmitStack.length; i += 1) {\n                        QRTE.onSubmitStack[i]();\n                    }\n                    QRTEController.onSubmitStack = [];\n                    debugger;\n                    this.currentForm.request({\n                        onComplete: this.requestNextTrialCallback\n                    });\n\n                    //Set server comm onset for the next trial\n                    QRTE.setBlockData('ServerCommOnset', window.requestAnimationFrame.now());\n\n                    QRTEController.betweenSubmits = true;\n\n                    for (var i = 0; i < this.childInputs.length; i += 1) {\n                        this.childInputs[i].parent.insert(this.childInputs[i].ele);\n                        this.childInputs[i].ele.style.display = 'none';\n                    }\n                } else if (isLastTrial === true) {\n                    //Just add the previous trial's childInputs to the form \n                    for (var i = 0; i < this.childInputs.length; i += 1) {\n\n                        this.currentForm.insert(this.childInputs[i].ele);\n                        this.childInputs[i].ele.style.display = 'none';\n                    }\n\n                    this.loadNextTrial = function() {\n                        //Directly submitting the form doesn't seem to work? Let's do it through NextButton click\n                        $('NextButton').click();\n                    };\n                }\n            },\n\n            loadNextTrial: function() {\n                if (this.handlingSubmit === true) {\n                    //The submit still hasn't returned..\n                    this.loadUponCallback = true;\n                    return;\n\n                }\n                //Set handling submit to false (as page has been returned)\n                //Save the previous form\n                this.previousForm = this.currentForm;\n                //Reset the QuestionInfo object, this is for Qualtrics to correctly initiate its own page\n                Qualtrics.SurveyEngine.QuestionInfo = {}\n                    //Parse the HTML that was returned earlier and set it as the current trial container's contents\n                this.nextTrialContainer = jQuery(this.nextTrialContainer).html(this.nextTrialText)[0];\n                //Filter out the 'form' field, and append it back.\n                this.currentForm = jQuery(this.nextTrialContainer).find('form')[0];\n                jQuery(this.previousForm).replaceWith(jQuery(this.currentForm));\n\n                jQuery(this.currentForm).show();\n\n                if (this.currentForm.select('.END_OF_SURVEY').length === 0) {\n                    this.currentForm.fire('QRTE:load');\n                    this.submitPage = this.requestNextTrial;\n                } else {\n                    this.submitPage = this.currentForm.submit;\n                }\n\n            },\n\n            requestNextTrialCallback: function(e) {\n                QRTEController.nextTrialText = e.responseText;\n                QRTEController.handlingSubmit = false;\n                QRTE.setBlockData('ServerCommOffset', window.requestAnimationFrame.now());\n\n                if (QRTEController.loadUponCallback === true) {\n                    QRTEController.loadUponCallback = false;\n                    QRTEController.loadNextTrial();\n                }\n            },\n\n            submitPage: function() {\n                console.log('Not yet initialised');\n            },\n\n            count: function(obj) {\n                var count = 0;\n\n                for (var prop in obj) {\n                    if (obj.hasOwnProperty(prop))\n                        ++count;\n                }\n\n                return count;\n            },\n\n            BDCache: {},\n            storeBlockData: function(blockData) {\n                this.BDCache = blockData;\n            },\n\n            loadBlockData: function() {\n                return this.BDCache;\n            }\n        };\n\n        document.observe('dom:loaded', QRTEController.init.bind(QRTEController));\n\n\n        (function() {\n            var lastFrame, method, now, queue, requestAnimationFrame, timer, vendor, _i, _len, _ref, _ref1;\n            method = 'native';\n            now = Date.now || function() {\n                return new Date().getTime();\n            };\n            requestAnimationFrame = window.requestAnimationFrame;\n            _ref = ['webkit', 'moz', 'o', 'ms'];\n            for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n                vendor = _ref[_i];\n                if (!(requestAnimationFrame != null)) {\n                    requestAnimationFrame = window[vendor + \"RequestAnimationFrame\"];\n                }\n            }\n            if (!(requestAnimationFrame != null)) {\n                method = 'timer';\n                lastFrame = 0;\n                queue = timer = null;\n                requestAnimationFrame = function(callback) {\n                    var fire, nextFrame, time;\n                    if (queue != null) {\n                        queue.push(callback);\n                        return;\n                    }\n                    time = now();\n                    nextFrame = Math.max(0, 16.66 - (time - lastFrame));\n                    queue = [callback];\n                    lastFrame = time + nextFrame;\n                    fire = function() {\n                        var cb, q, _j, _len1;\n                        q = queue;\n                        queue = null;\n                        for (_j = 0, _len1 = q.length; _j < _len1; _j++) {\n                            cb = q[_j];\n                            cb(lastFrame);\n                        }\n                    };\n                    timer = setTimeout(fire, nextFrame);\n                };\n            }\n            requestAnimationFrame(function(time) {\n                var _ref1;\n                if ((((_ref1 = window.performance) != null ? _ref1.now : void 0) != null) && time < 1e12) {\n                    requestAnimationFrame.now = function() {\n                        return window.performance.now() + window.performance.timing.navigationStart;\n                    };\n                    requestAnimationFrame.method = 'native-highres';\n                } else {\n                    requestAnimationFrame.now = now;\n                }\n            });\n            requestAnimationFrame.now = ((_ref1 = window.performance) != null ? _ref1.now : void 0) != null ? (function() {\n                return window.performance.now() + window.performance.timing.navigationStart;\n            }) : now;\n            requestAnimationFrame.method = method;\n            window.requestAnimationFrame = requestAnimationFrame;\n        })();\n\n        function loadScript(url, callback) {\n\n            var script = document.createElement(\"script\")\n            script.type = \"text/javascript\";\n\n            if (script.readyState) { //IE\n                script.onreadystatechange = function() {\n                    if (script.readyState == \"loaded\" || script.readyState == \"complete\") {\n                        script.onreadystatechange = null;\n                        callback();\n                    }\n\n                };\n            } else { //Others\n                script.onload = function() {\n                    callback();\n                };\n            }\n\n            script.src = url;\n            document.getElementsByTagName(\"head\")[0].appendChild(script);\n        }\n\n        (function() {\n\n            //jQuery is only required for the Fixation flash fix. prototypejs is unable to efficiently replace elements\n            //and introduces a 10 ms delay between loading element and firing off the scripts. Unacceptable\n            //First time jQuery should be used is the second trial\n\n            loadScript(\"https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js\", function() {\n\n                $.noConflict();\n\n            });\n\n        })();\n\n        //If preview mode is run (PreviewBanner element exists, add a QRTEngine plug with id QRTEPlug)\n\n        if ($('PreviewBanner')) {\n            var plug, row, banner = $('PreviewBanner');\n            //Go down to the first table row inside that banner\n            row = banner.children[0].children[0].children[0];\n            //Insert new cell    \n            plug = row.insertCell(2);\n            plug.id = \"QRTEPlug\";\n            plug.width = \"20%\";\n            plug.innerHTML = 'This survey is proudly and successfully powered by <a href=\"http://qrtengine.com\" target=\"_blank\"><i><b>QRTEngine</b></i></a>';\n            plug.style.textAlign = \"center\";\n        }\n    }","\n    /* ==========================================================\n     * QRTEngine.js v16\n     * ==========================================================\n     * Copyright 2013-2014 Erwin Haasnoot\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     * http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     *\n     *\n     *\n     * ========================================================== */\n    /**\n     * Qualtrics Reaction Time Engine or QRTE is an add-on providing an interface\n     * for easy reaction time experiment creation in the Qualtrics survey research suite (tm).\n     * For instructions on how to use this add-on, see xxxx\n     *\n     * QRTE was developed by Erwin Haasnoot\n     * Email: erwinhaasnoot[at]gmail.com\n     * @class QRTE\n     *\n     */\n    var QRTE = {\n        version: 'v16',\n        columnsField: 'QRTE_columns',\n        blockDataField: 'QRTE_blockData',\n        idField: 'QRTE_idData',\n        exitQuestions: 'QRTE_exitQuestions',\n        inited: false,\n        /**\n         * TDCache contains the Trial-Level Data in an Object. DO NOT directly manipulate this Object. It might cause inconsistencies in the data file and cause unexpected once parsed.\n         * Use QRTE.setTrialData and QRTE.getTrialData instead.\n         *\n         * @property TDCache\n         * @private\n         * @type Object\n         */\n        TDCache: {},\n\n        /**\n         * ColumnCache contains all the mappings from QID to Columns\n         * @property columnCache\n         * @private\n         * @type Object\n         */\n        columnCache: {},\n\n        /**\n         * BDCache contains the BlockLevel Data in an Object. Directly manipulating this Object might cause inconsistencies\n         * @property BDCache\n         * @private\n         * @type Object\n         */\n        BDCache: {},\n\n        /**\n         * SDCache is a cache for speeding up retrieval of Survey level Data,\n         * All Survey data is saved to both Embedded Data and Survey Data\n         * @private\n         * @property SDCache\n         * @type Object\n         */\n        SDCache: {},\n\n        /**\n         * idCache is a cache for quickly retrieving the Qualtrics QID to QRTLib Id mappings.\n         * Saved in the idData embedded data field after every trial.\n         * @private\n         * @property idCache\n         * @type Object\n         */\n        idCache: {},\n\n        /**\n         * questionQueue contains Objects (stimuli) that are waiting to be presented\n         * @private\n         * @property questionQueue\n         * @type Array\n         */\n        questionQueue: [],\n\n        /**\n         * currentPageQuestions contains the Question Objects that are\n         * displayed at any given time.\n         * @private\n         * @property currentPageQuestions\n         * @type Array\n         */\n        currentPageQuestions: [],\n\n        /**\n         * Contains Trial Data Columns that were 'newly' added in this trial run.\n         * @private\n         * @property newlyAddedColumns\n         * @type Array\n         */\n        newlyAddedColumns: [],\n\n        /**\n         * Contains the Post-Initialization Element.\n         * @private\n         * @property postInitElement\n         * @type Object\n         */\n        postInitElement: {},\n\n        /**\n         * Setter function for Trial-Level Data.\n         * @method setTrialData\n         * @param key {String} Key\n         * @param value {Value} Value\n         */\n        setTrialData: function(key, value) {\n            //Store value in trial cache\n            this.TDCache[key] = value;\n            if (this.BDCache.QRTLib_trialColumns[key] === undefined) {\n                //Add column to overall trial data\n                this.BDCache.QRTLib_trialColumns[key] = '';\n                this.newlyAddedColumns.push(key);\n            }\n        },\n\n        /**\n         * Gets the value of Trial-Level Data field 'key\n         * @method getTrialData\n         * @param key {String} Key\n         */\n        getTrialData: function(key) {\n            return this.TDCache[key];\n        },\n\n        /**\n         * Setter function for Block-Level Data.\n         * @method setBlockData\n         * @param key {String} Key\n         * @param value {Value} Value\n         */\n        setBlockData: function(key, value) {\n            this.BDCache[key] = value;\n        },\n\n\n        /**\n         * Gets the value of Block-Level Data field 'key\n         * @method getBlockData\n         * @param key {String} Key\n         */\n        getBlockData: function(key) {\n            return this.BDCache[key];\n        },\n\n\n\n\n        /**\n         * Stringify the Block Data and store it in the Embedded Data Field. This preserves the values stored on Block Level for use in later trials\n         * @method saveBlockData\n         * @param key {String} Key\n         */\n        saveBlockData: function() {\n            //Store blockData in ED so that we can use it next trial\n            QRTEController.storeBlockData(QRTE.BDCache);\n            Qualtrics.SurveyEngine.setEmbeddedData(QRTE.blockDataField, Object.toJSON(QRTE.BDCache));\n        },\n\n\n\n        /**\n         * Setter function for Survey-Level Data (Embedded Data).\n         * @method setSurveyData\n         * @param key {String} Key\n         * @param value {Value} Value\n         */\n        setSurveyData: function(key, value) {\n            this.SDCache[key] = value;\n            Qualtrics.SurveyEngine.setEmbeddedData(key, value);\n        },\n\n\n\n        /**\n         * Gets the value of Survey-Level Data (Embedded Data) 'key'\n         * @method getSurveyData\n         * @param key {String} Key\n         */\n\n        getSurveyData: function(key) {\n            if (this.SDCache[key] !== undefined) {\n                return this.SDCache[key];\n            }\n            //This only works if the Survey Data has been set during the same trial due to a bug in Qualtrics.\n            return Qualtrics.SurveyEngine.getEmbeddedData(key);\n        },\n\n        /**\n         * Sets a configuration for a question\n         * @method setConfig\n         * @param QID {String} The QRTE Question Id of the Question you want the configuration to apply to\n         * @param option {String} The type of configuration you want to set, Allowed options: 'cresp', 'allowable', 'duration', 'endaction', 'delay'. Refer to website for documentation on these configs\n         * @param value {String} The value the configuration needs to be set to. Differs per option.\n         */\n        setConfig: function(QID, option, value) {\n            var setterFunc;\n            if (typeof QID === 'string') {\n                setterFunc = function(QID, option, value) {\n                    this.setTrialData(QID + \"[\" + option + \"]\", value);\n                };\n            } else {\n                setterFunc = function(QID, option, value) {\n                    this.setTrialData(QID.questionId + \"[\" + option + \"]\", value);\n                    QID['_' + option] = value;\n                };\n\n            }\n\n            this._setConfig(QID, option, value, setterFunc);\n        },\n\n\n        /**\n         * Loads the configuration for a question.\n         * @private\n         * @method loadConfig\n         * @param question {Object} Question for which the configuration needs to be loaded.\n         */\n        loadConfig: function(question) {\n            if (this.idCache[question.questionId] !== undefined) {\n                question.QRTLib_configId = this.idCache[question.questionId];\n            } else {\n                question.QRTLib_configId = question.question;\n            }\n            question.duration = this.getDuration(question);\n            question.allowable = this.getAllowable(question);\n            question.cresp = this.getCResp(question);\n            question.offset = this.getOffset(question);\n            question.endAction = this.getEndAction(question);\n        },\n\n        /**\n         * Stores the accuracy of a trial\n         * @private\n         * @method saveAcc\n         * @param question {Object} Question for which accuracy needs to be stored\n         * @param acc {Integer} Accuracy of question\n         */\n\n        saveAcc: function(question, acc) {\n            if (acc === 0 || acc === 1) {\n                this.setTrialData(question.QRTLibId + \"[ACC]\", acc);\n                this.setSurveyData(\"ACC\", acc);\n            }\n        },\n\n\n\n        /**\n         * Check whether the given response was a correct response\n         * @method isCorrectResponse\n         * @param question {Object} Question for which correct response needs to be checked\n         * @param resp {String} Given response\n         */\n        isCorrectResponse: function(question, resp) {\n            return question.cresp.indexOf(resp) >= 0;\n        },\n\n        /**\n         * Check whether the given response was an allowable response\n         * @method isAllowableResponse\n         * @param question {Object} Question for which allowable response needs to be checked\n         * @param resp {String} Given response\n         */\n        isAllowableResponse: function(question, resp) {\n            return question.allowable.indexOf(resp) >= 0;\n        },\n\n\n\n        /**\n         * Check whether the given response was an allowable response\n         * @private\n         * @method keycode2string\n         * @param e {Object} KeyPress event from which to retrieve the response\n         */\n        keycode2string: function(e) {\n            return String.fromCharCode(e.charCode);\n        },\n\n        /** \n         * Wait for images to load before starting trial.\n         * @property waitForImageLoad\n         * @private\n         * @type Boolean\n         */\n\n        waitForImageLoad: true,\n\n        /** \n         * Trial Start waiting list - initialised with waiting for TrialStart\n         * @property loadWaitingList\n         * @private\n         * @type Array\n         */\n\n        loadWaitingList: [false],\n\n        /**\n         * Initializes the Engine, called at the start of the 'Init' question.\n         * @private\n         * @method initLib\n         * @param blockDataString {String} JSON string containing information saved for this block (block-level data)\n         * @param blockId {String} Id of the current block\n         * @param columns {String} JSON string containing information about the columns that have been defined in this block\n         * @param idData {String} JSON string containing information about the mapping of the QID to the name of the question\n         * @param exitQuestions {String} String containing the currently defined QuestionTags of the Exit questions\n         * @param exitItemTag {String} String containing the Tag of this block's Exit question.\n         */\n\n\n        initLib: function(blockDataString, blockId, columns, idData, exitQuestions, exitItemTag) {\n            //var blockDataString = Qualtrics.SurveyEngine.getEmbeddedData(QRTE.blockDataField),\n            //columns = Qualtrics.SurveyEngine.getEmbeddedData(QRTE.columnsField),\n            //idData = Qualtrics.SurveyEngine.getEmbeddedData(QRTE.idField);\n            var glue;\n            QRTE.fixSetEmbeddedDataBug();\n            //Initialise block Data\n            if (blockDataString === undefined columnData || blockDataString === '') {\n                blockDataString = '{}';\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.blockDataField, blockDataString);\n            }\n\n            this.BDCache = QRTEController.loadBlockData(blockDataString);\n\n            if (this.BDCache.QRTLib_currentBlock !== blockId) {\n                //If this is a new block, initialise a new block\n                this.BDCache = {\n                    QRTLib_currentBlock: blockId,\n                    QRTLib_blockCounter: 1,\n                    QRTLib_trialColumns: {}\n                };\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.blockDataField, Object.toJSON(this.BDCache));\n                if (exitQuestions === null) {exitQuestions = '';}\n                glue = '';\n                if (exitQuestions !== '') {\n                    glue = ';';\n                }\n                //And update the exit questions\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.exitQuestions, exitQuestions + glue + exitItemTag);\n\n            }\n            QRTE.TDCache = Object.toJSON(QRTE.getBlockData('QRTLib_trialColumns')).evalJSON();\n            if (columns === undefined || columns === null || columns === '') {\n                columns = '{}';\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.columnsField, columns);\n            }\n            QRTE.SDCache[QRTE.columnsField] = columns.evalJSON();\n            if (idData === undefined || idData === null || idData === '') {\n                idData = '{}';\n                Qualtrics.SurveyEngine.setEmbeddedData(QRTE.idField, idData);\n            }\n            QRTE.idCache = idData.evalJSON();\n        },\n\n        /**\n         * Init initializes the QRTEngine, expects are params object with possible fields defined with parameters.\n         * @method Init\n         * @param paramObj {Object} object containing parameters of Init function\n         *  @param paramObj.blockData {String} blockData string in json format (from embedded data)\n         *  @param paramObj.columnData {String} columnData string in json format (from embedded data)\n         *  @param paramObj.exitQuestions {String} exitQuestions string (from embedded data)\n         *  @param paramObj.exitItemTag {String} Tag of the Exit question of this block\n         *  @param paramObj.blockId {String} Identificaton of the block\n         *  @param [paramObj.onLoadFn] {Function} Function to be called when this Question is displayed\n         *  @param [paramObj.interTrialDelay] {Integer|Array} Specify millisecond delay between end of previous trial and beginning of new trial\n         *  @param [paramObj.preTrialDelay] {Integer|Array} Specify millisecond (ms) delay before the start of the first trial of the block. //NYI\n         *  @param [paramObj.initQuestionIndex] {Integer} Specify index of the Init question in the Question Block (defaults to 1)\n         *  @param [paramObj.waitForImages] {Boolean} Specify whether we should wait for images or not. Is on by default, but could be turned off if all images are pre-loaded in cache, or are very small in general.\n         */\n        Init: function(paramObj) {\n            var validationArray, qArray, initIndex;\n            //init the library\n            QRTE.init();\n\n            //set the initIndex (if the Init question is not the first question of the block)\n            QRTE.initIndex = paramObj.initQuestionIndex - 1 || 0;\n\n\n            validationArray = [{\n                name: 'blockData',\n                type: ['JSON', 'Empty'],\n                required: true\n            }, {\n                name: 'columnData',\n                type: ['JSON', 'Empty'],\n                required: true\n            }, {\n                name: 'idData',\n                type: ['JSON', 'Empty'],\n                required: true\n            }, {\n                name: 'blockId',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'onLoadFn',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'interTrialDelay',\n                type: ['Integer', 'Array'],\n                required: false\n            }, {\n                name: 'exitQuestions',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'exitItemTag',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'waitForImages',\n                type: ['Boolean'],\n                required: false\n            }];\n\n            //Validate Parameter Object, outputs stuff to console\n            QRTE.validateParams(paramObj, validationArray, 'Init');\n\n\n            //Initialize the library itself (necessary for each trial)\n            QRTE.initLib(paramObj.blockData, paramObj.blockId, paramObj.columnData, paramObj.idData, paramObj.exitQuestions, paramObj.exitItemTag);\n\n\n            if (paramObj.waitForImages !== undefined) {\n                QRTE.waitForImageLoad = paramObj.waitForImages;\n            }\n            //calculate server communication delay\n            QRTE.setTrialData('InitPre[OnsetTime]', QRTE.getBlockData('QRTLib_previousStorageDone'));\n\n            QRTE.setTrialData('InitPre[OffsetTime]', window.requestAnimationFrame.now());\n            QRTE.setTrialData('InitPre[CalculatedDuration]', QRTE.getTrialData('InitPre[OffsetTime]') - QRTE.getTrialData('InitPre[OnsetTime]'));\n            QRTE.setTrialData('Init[OnsetTime]', window.requestAnimationFrame.now());\n\n\n\n            Qualtrics.SurveyEngine.addOnload(function() {\n                this.qHTML = document.getElementById(this.questionId);\n                this.QRTLib_isActive = false;\n                this.hideChoices();\n                this.proceed = QRTE.proceed;\n                this.QRTLibId = 'InitPost';\n\n                paramObj.onLoadFn.apply(this);\n                var QuestionStackElement = {\n                    questionElement: this,\n                    onShowFunc: function() {},\n                    type: 'Stimulus',\n                    loadConfig: true,\n                    id: 'InitPost',\n                    conditional: function() {\n                        return true;\n                    },\n                    proceedOnHide: true\n\n                };\n                QRTE.setConfig(QuestionStackElement.id, 'duration', 0);\n                QRTE.postInitElement = QuestionStackElement;\n                QRTE.questionQueue.push(QuestionStackElement);\n            });\n\n            if (paramObj.interTrialDelay instanceof Array) {\n                paramObj.interTrialDelay = paramObj.interTrialDelay[Math.floor(Math.random() * paramObj.interTrialDelay.length)];\n            }\n            QRTE.setTrialData(paramObj.blockId + '[InterTrialDelay]', paramObj.interTrialDelay);\n            if (paramObj.interTrialDelay > 0) {\n                QRTE.setBlockData('QRTLib_intraTrialDelay', paramObj.interTrialDelay);\n            } else {\n                QRTE.setBlockData('QRTLib_intraTrialDelay', -1);\n            }\n        },\n\n        /**\n         * Create a Stimulus question\n         * @method Stimulus\n         * @param paramObj {Object}\n         *  @param paramObj.id {String} Id of the Question\n         *  @param paramObj.onShowFn {Function} Function to be called upon showing the question (not the same as upon loading)\n         *  @param [paramObj.conditional] {Function} Function to be called with which to decide whether to present this question or not, should return a boolean.\n         *  @param [paramObj.loadConfig] {Boolean} Load predefined config for this question (defaults to true)\n         *  @param [paramObj.stimContinue] {Boolean} Continue looking for stimuli after having seen this one, only if set to true (defaults to false)\n         *  @param [paramObj.onKeyPress] {Function} Function to be called upon receiving a key press while this Question is active (called next to onAllowableKey or onCorrectKey)\n         *  @param [paramObj.onAllowableKey] {Function} Function to be called upon receiving a key press on a key defined as 'allowable' \n         *  @param [paramObj.onCorrectKey] {Function} Function to be called upon receiving a key press on a key defined as 'correct'\n         *  @param [paramObj.onIncorrectKey] {Function} Function to be called upon receiving an allowable key that is not defined as correct (only if correct responses are defined)\n         *  @param [paramObj.proceedOnHide] {Boolean} Set whether all currently displayed elements should be removed on hide, or if only this should be removed from display (Defaults to True). This allows the user to decouple presentation of a stimulus from proceeding of a slide.\n         *  @param [paramObj.onHideFn] {Function} Function to be called upon Stimulus being hidden\n         *  @param [paramObj.duringDisplayFn] {Function} Function to be called during each frame that the Stimulus is being displayed\n         \n         */\n        Stimulus: function(paramObj) {\n            var validationArray = [{\n                name: 'id',\n                type: ['String'],\n                required: true\n            }, {\n                name: 'onShowFn',\n                type: ['Function'],\n                required: true\n            }, {\n                name: 'conditional',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'loadConfig',\n                type: ['Boolean'],\n                required: false\n            }, {\n                name: 'duringDisplayFn',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'continue',\n                type: ['Boolean'],\n                required: false\n            }, {\n                name: 'onAllowableKey',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'onCorrectKey',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'onKeyPress',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'onIncorrectKey',\n                type: ['Function'],\n                required: false\n            }, {\n                name: 'proceedOnHide',\n                type: ['Boolean'],\n                required: false\n            }, {\n                name: 'onHideFn',\n                type: ['Function'],\n                required: false\n            }];\n\n            //Validate Parameter Object, outputs stuff to console\n            QRTE.validateParams(paramObj, validationArray, 'Stimulus');\n\n\n            if (paramObj.conditional === undefined) {\n                paramObj.conditional = function() {\n                    return true;\n                };\n            }\n            if (paramObj.loadConfig === undefined) {\n                paramObj.loadConfig = true;\n            }\n\n            if (paramObj.stimContinue === undefined) {\n                paramObj.stimContinue = false;\n            }\n\n            if (paramObj.proceedOnHide === undefined) {\n                paramObj.proceedOnHide = true;\n            }\n            Qualtrics.SurveyEngine.addOnload(function() {\n                this.QRTLib_isActive = false;\n                this.proceed = QRTE.proceed;\n                this.QRTLibId = paramObj.id;\n                var QuestionStackElement = {\n                    questionElement: this,\n                    onShowFunc: paramObj.onShowFn,\n                    duringDisplayFn: paramObj.duringDisplayFn,\n                    onHideFn: paramObj.onHideFn,\n                    type: 'Stimulus',\n                    loadConfig: paramObj.loadConfig,\n                    id: paramObj.id,\n                    conditional: paramObj.conditional,\n                    stimContinue: paramObj.stimContinue,\n                    onAllowableKey: paramObj.onAllowableKey,\n                    onCorrectKey: paramObj.onCorrectKey,\n                    onKeyPress: paramObj.onKeyPress,\n                    onIncorrectKey: paramObj.onIncorrectKey,\n                    proceedOnHide: paramObj.proceedOnHide\n                };\n                QRTE.questionQueue.push(QuestionStackElement);\n            });\n        },\n\n        /**\n         * Exit denotes the end of the block. Important for the initialization phase and the exit phase.\n         * Make the question a Form question with precisely 2 answer fields (more is unnecessary, those will get ignored)\n         * @method Exit\n         */\n        Exit: function() {\n\n\n            qArray = $('Questions').getElementsByClassName('QuestionOuter');\n            for (var i = 0; i < qArray.length && i < QRTE.initIndex + 1; i += 1) {\n                qArray[i].style.display = 'block';\n            }\n            Qualtrics.SurveyEngine.addOnload(function() {\n                //Hide all choice\n                this.hideChoices();\n                //display the question\n                //this.questionContainer.style.display = 'none';\n                var QuestionStackElement, onShowFn;\n                onShowFn = function() {\n\n                    //Create and/or store standard information about the trial\n                    var blockId = QRTE.getBlockData('QRTLib_currentBlock'),\n                        tempTD = {},\n                        key,\n                        i;\n\n                    QRTE.setBlockData('QRTLib_previousEndTime', window.requestAnimationFrame.now());\n                    QRTE.setTrialData(blockId + '[TrialNr]', QRTE.getBlockData('QRTLib_blockCounter'));\n                    QRTE.setTrialData(blockId + '[RefreshPeriod]', QRTE.refreshPeriod);\n                    QRTE.setTrialData('BlockId', blockId);\n                    QRTE.setTrialData('EngineType', window.requestAnimationFrame.method);\n                    QRTE.setTrialData('Exit[OnsetTime]', window.requestAnimationFrame.now());\n                    QRTE.setTrialData('QRTEngine[Version]', QRTE.version);\n\n                    //CHECK IF ATLEAST TWO FORM FIELDS HAVE BEEN DEFINED\n                    this.setChoiceValue(2, 'testtest');\n                    if (this.getChoiceValue(2) !== 'testtest') {\n                        //alert('You need to define two answer form fields in the Exit question!!');\n                    }\n\n                    for (key in QRTE.TDCache) {\n                        if (QRTE.TDCache.hasOwnProperty(key) && key !== '') {\n                            //Change QID thingies to entered ID's, also force every value to a string so that the Parser handles high numerical values correctly\n                            tempTD[QRTE.getOutputKey(key)] = String(QRTE.TDCache[key]);\n                        }\n                    }\n\n                    this.setChoiceValue(1, Object.toJSON(tempTD));\n                    this.setChoiceValue(2, blockId);\n                    if (QRTE.SDCache[QRTE.columnsField][blockId] === undefined) {\n                        QRTE.SDCache[QRTE.columnsField][blockId] = [];\n                    }\n                    for (i = 0; i < QRTE.newlyAddedColumns.length; i += 1) {\n                        QRTE.SDCache[QRTE.columnsField][blockId].push(QRTE.getOutputKey(QRTE.newlyAddedColumns[i]));\n                    }\n\n                    QRTE.setSurveyData(QRTE.columnsField, Object.toJSON(QRTE.SDCache[QRTE.columnsField]));\n                    QRTE.setBlockData('QRTLib_blockCounter', QRTE.getBlockData('QRTLib_blockCounter') + 1);\n                    QRTE.setBlockData('QRTLib_previousStorageDone', window.requestAnimationFrame.now());\n                    QRTE.saveBlockData();\n\n                    //If wanting to test, uncomment this line and comment the one after that to enforce manual nextbutton clicks\n                    //$('NextButton').style.display = 'block';\n                    //QRTE.submitPage();\n                    QRTEController.loadNextTrial();\n                };\n\n                QuestionStackElement = {\n                    questionElement: this,\n                    onShowFunc: onShowFn,\n                    type: 'Storage',\n                    loadConfig: true,\n                    conditional: function() {\n                        return true;\n                    }\n                };\n                QRTE.questionQueue.push(QuestionStackElement);\n\n                QRTE.startTrial(0);\n\n            });\n\n            QRTE.loadWaitingList = [false];\n            if (QRTE.waitForImageLoad === true) {\n                //set wait for image load queues.\n                var loadIndex = 1,\n                    images = $$('.QuestionOuter img'),\n                    i = 0;\n\n                var l = images.length;\n                for (; i < l; i += 1) {\n                    images[i].observe('load', function(e) {\n                        QRTE.startTrial(e.path[0].QRTELoadIndex);\n                    })\n                    images[i].QRTELoadIndex = i + 1;\n                    QRTE.loadWaitingList[i + 1] = false;\n                }\n\n            }\n\n        },\n\n        /**\n         * Remove the padding Qualtrics adds between Questions (causes question presentation to drift downwards if not called).\n         * DEPRECATED: Separators hidden through CSS now\n         * @method removeSeparators\n         * @private\n         */\n        removeSeparators: function() {\n            var questionElement = document.getElementById('Questions'),\n                index;\n            for (index = 0; index < questionElement.children.length; index += 1) {\n                if (questionElement.children[index].className === \"Separator\") {\n                    questionElement.children[index].parentNode.removeChild(questionElement.children[index]);\n                }\n            }\n        },\n        /**\n         * Notifies the engine the first trial is ready to be started. Called at the end of the 'exit' question\n         * @private\n         * @method startTrial\n         */\n        startTrial: function(startId) {\n            var duringDisplayFn, onHideFn, onDisplayFn, serverCommDelay, remainingDelay;\n            //All questions have been hidden, so display the parent block again\n            //$('Questions').style.display = 'block';\n\n            QRTE.loadWaitingList[startId] = true;\n            if (!QRTE.loadWaitingList.every()) {\n                QRTE.log('Process ' + startId + 'finished, waiting for other processes to finish')\n                return;\n            }\n\n            //Save the absolute time of when onLoad part of library was finished\n            serverCommDelay = window.requestAnimationFrame.now() - QRTE.getBlockData('QRTLib_previousEndTime'); //Calculate the remaining time based on the lib initialization + server delay times\n            remainingDelay = QRTE.getBlockData('QRTLib_intraTrialDelay') - serverCommDelay;\n\n\n            if (isNaN(remainingDelay)) {\n                remainingDelay = QRTE.getBlockData('QRTLib_intraTrialDelay') * 3;\n                //If this init call is the first one of the block (first trial), calculate the estimated refreshdelay during the pre-trial interval\n                onDisplayFn = function(ele, time) {\n                    QRTE.setTrialData('Init[OffsetTime]', ele.displayOnsetTime);\n                    QRTE.setTrialData('Init[CalculatedDuration]', ele.displayOnsetTime - QRTE.getTrialData('Init[OnsetTime]'));\n                    QRTE.refreshPeriodEstimationStack = [];\n                };\n                duringDisplayFn = function(ele, time) {\n                    //Get current time, required for \n                    QRTE.refreshPeriodEstimationStack.push(time);\n                };\n                onHideFn = function(ele, timestamp) {\n                    var diffs = [];\n\n                    for (i = 1; i < QRTE.refreshPeriodEstimationStack.length; i += 1) {\n                        diffs[i - 1] = QRTE.refreshPeriodEstimationStack[i] - QRTE.refreshPeriodEstimationStack[i - 1];\n                    }\n                    QRTE.refreshPeriod = QRTE.median(diffs);\n                    QRTE.log('Estimated refresh delay = ' + QRTE.refreshPeriod);\n                    QRTE.setBlockData('QRTE_refreshPeriod', QRTE.refreshPeriod);\n                    QRTE.referenceTime = timestamp;\n                    QRTE.framesSinceReference = 0;\n                };\n            } else {\n                onDisplayFn = function(ele, time) {\n                    QRTE.setTrialData('Init[OffsetTime]', ele.displayOnsetTime);\n                    QRTE.setTrialData('Init[CalculatedDuration]', ele.displayOnsetTime - QRTE.getTrialData('Init[OnsetTime]'));\n                };\n\n                QRTE.refreshPeriod = QRTE.getBlockData('QRTE_refreshPeriod');\n            }\n\n            //QRTE.setTrialData('ITI[Duration]', (remainingDelay > 0) ? remainingDelay : 0);\n            QRTE.initTime = window.requestAnimationFrame.now();\n\n            QRTE.postInitElement.onHideFn = onHideFn;\n            QRTE.postInitElement.onDisplayFn = onDisplayFn;\n            QRTE.postInitElement.duringDisplayFn = duringDisplayFn;\n            QRTE.setConfig('InitPost', 'duration', (remainingDelay > 0) ? remainingDelay : 0);\n            //UNCOMMENT\n            //QRTE.setConfig('InitPost', 'duration', (remainingDelay > 0) ? remainingDelay : Infinity);\n            QRTE.inited = true;\n\n            //Set initial trial data related to loading of this trial\n            QRTE.setTrialData('InitServerComm[Onset]', QRTE.getBlockData('ServerCommOnset'));\n            QRTE.setTrialData('InitServerComm[Offset]', QRTE.getBlockData('ServerCommOffset'));\n            QRTE.setTrialData('InitServerComm[CalculatedDuration]', QRTE.getBlockData('ServerCommOffset') - QRTE.getBlockData('ServerCommOnset'));\n\n            //<Load next trial here>\n            var currentLoops = '${lm://CurrentLoopNumber}',\n                totalLoops = '${lm://TotalLoops}';\n            //Check if last trial, currentloops === totalLoops;\n            QRTEController.requestNextTrial(currentLoops !== '' && currentLoops === totalLoops);\n\n            QRTE.proceed();\n        },\n\n\n\n        proceed: function() {\n            QRTE.log(\"proceed called after \" + window.requestAnimationFrame.now() - QRTE.initTime);\n            QRTE.hideAllElements();\n        },\n\n        proceedPage: function() {\n            var currentQ;\n            QRTE.log(\"Proceeding page..\");\n            while (QRTE.currentPageQuestions.length > 0) {\n                currentQ = QRTE.currentPageQuestions.shift();\n\n                //Disable\n                currentQ.questionElement.QRTLib_isActive = false;\n            }\n\n\n            //Go to next question\n            QRTE.showNextPage();\n        },\n\n        disableQuestion: function(disableQ) {},\n\n        /**\n         * Determine and show the next page/slide\n         * @private\n         * @method showNextPage\n         */\n        showNextPage: function() {\n            var continueSearch = true,\n                shownQ = false,\n                nextQ,\n                shown;\n            while (continueSearch === true) {\n                continueSearch = false;\n                nextQ = QRTE.questionQueue.shift();\n                if (nextQ !== undefined && (nextQ.type === 'Stimulus' || nextQ.type === 'Storage')) {\n                    QRTE.currentPageQuestions.push(nextQ);\n                    shown = QRTE.showStimulusQuestion.apply(nextQ.questionElement, [nextQ]);\n\n                    if (nextQ.stimContinue) {\n                        continueSearch = true;\n                        if (shown === true) {\n                            shownQ = true;\n                        }\n                    }\n                    QRTE.log('shown ' + nextQ.id + ': ' + shown);\n                    QRTE.log('continue ' + nextQ.id + ': ' + continueSearch);\n                    if (shown === false && shownQ === false) {\n                        continueSearch = true;\n                    }\n                }\n            }\n\n        },\n\n        /**\n         * Show Question\n         * Handles the activation of that question, which includes:\n         * The loading of the configuration (duration, allowable keys etc).\n         * Sets the event handler to respond to any key presses during the event.\n         * @private\n         * @method showStimulusQuestion\n         * @param question {Object} question to be shown.\n         *  @param id {String} Id of question.\n         *  @param onShowFunc {Function} Function to be called when showing question\n         *  @param loadConfig {Boolean} If true, config is loaded from the current block data (which has been defined elsewhere)\n         *  @param questionElement {Object} This Qualtrics question element\n         *  @param duringDisplayFn {Function} Function to be called each frame that the question is presented\n         */\n        showStimulusQuestion: function(question) {\n            //Save the loading start time\n            //QRTE.setTrialData(question.questionElement.QRTLibId + '[LoadStartTime]', window.requestAnimationFrame.now());\n            //Set mapping of the QID -> QRTE Id\n            QRTE.setId(this, question.id);\n\n            //Initialize variables\n            var stimulusShown = false,\n                questionScope = this,\n                dispEle;\n            QRTE.log(question);\n\n            //Check whether question should be shown or not, if not skip to the next question (implicitly)\n            if (question.conditional() === true) {\n                this.QRTLib_isActive = true;\n\n\n                if (question.loadConfig === true) {\n                    //Load the Configuration of the Question, important!\n                    QRTE.loadConfig(this);\n                }\n\n                //Check if KeyPress listener is required (one or more of the following fields are defined: onKeyPress, onCorrectKey or onAllowableKey)\n                //If so, add keypress listener.\n                if (question.onKeyPress !== undefined || question.questionElement.allowable !== '' || question.questionElement.cresp !== '') {\n                    //Initialize the fields used for storing data about RT timing.\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[RTTime]', '');\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[RT]', '');\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[RESP]', '');\n                    QRTE.setTrialData(question.questionElement.QRTLibId + '[ACC]', 0);\n\n                    //Add the key listener\n                    QRTE.addKeyListener(function(e) {\n\n                        //Get the Key of the response\n                        var RT, RESP = QRTE.keycode2string(e),\n                            RTTime = window.requestAnimationFrame.now();\n                        RT = RTTime - QRTE.getTrialData(question.questionElement.QRTLibId + '[OnsetTime]');\n\n                        //Store the Time of the Key Press and calculate the RT and ACC if correct\n\n                        if ((QRTE.isAllowableResponse(question.questionElement, RESP) || QRTE.isCorrectResponse(question.questionElement, RESP)) && QRTE.getTrialData(question.questionElement.QRTLibId + '[RTTime]') === '') {\n                            QRTE.setTrialData(question.questionElement.QRTLibId + '[RTTime]', RTTime);\n                            QRTE.setTrialData(question.questionElement.QRTLibId + '[RT]', RT);\n                            QRTE.setTrialData(question.questionElement.QRTLibId + '[RESP]', RESP);\n                            if (QRTE.isCorrectResponse(question.questionElement, RESP)) {\n                                QRTE.saveAcc(question.questionElement, 1);\n                            } else {\n                                QRTE.saveAcc(question.questionElement, 0);\n                            }\n                        }\n\n                        //Store the RT and the Response\n\n                        //Set Handling Key Press to true, this lets the engine know that a keypress is currently being handled. Necessary when there is a timer (response deadline)\n                        question.handlingKeyPress = true;\n\n                        if (question.onCorrectKey !== undefined && QRTE.isCorrectResponse(question.questionElement, RESP)) {\n                            question.onCorrectKey.apply(question.questionElement, [e, RESP]);\n                        } else if (question.onIncorrectKey !== undefined && QRTE.isAllowableResponse(question.questionElement, RESP)) {\n                            question.onIncorrectKey.apply(question.questionElement, [e, RESP]);\n                        }\n\n                        if (question.onAllowableKey !== undefined && QRTE.isAllowableResponse(question.questionElement, RESP)) {\n                            question.onAllowableKey.apply(question.questionElement, [e, RESP]);\n                        }\n\n                        if (question.onKeyPress !== undefined) {\n                            question.onKeyPress.apply(question.questionElement, [e, RESP]);\n                        }\n\n                        if (question.questionElement.endAction === 'TERMINATE') {\n                            //Proceed to the next Question Page if the response is allowable\n                            if (QRTE.isAllowableResponse(question.questionElement, RESP) && question.questionElement.QRTLib_isActive === true) {\n                                question.questionElement.proceed();\n                            }\n                        }\n                        question.handlingKeyPress = false;\n\n                    }, this);\n                }\n\n                //Build the display Element. Stimuli Questions have to take into account the possibility of being associated with a key press. \n                //OnDisplayFn therefore logs the displayOnsetTime, so that the RT can be calculated.\n                dispEle = {\n                    el: this.questionContainer,\n                    duration: this.duration,\n                    delay: this.offset,\n                    duringDisplayFn: question.duringDisplayFn,\n                    onDisplayFn: function(displayEl, timestamp) {\n                        if (question.onDisplayFn !== undefined) {\n                            question.onDisplayFn(displayEl, timestamp);\n                        }\n                        QRTE.setTrialData(questionScope.QRTLibId + '[OnsetTime]', displayEl.displayOnsetTime);\n                    },\n                    proceedOnHide: question.proceedOnHide,\n                    id: question.id\n                };\n\n                //Set the OnHide Function\n                dispEle.onHideFn = function(displayEl, timestamp) {\n                    if (question.onHideFn !== undefined) {\n                        question.onHideFn(displayEl, timestamp);\n                    }\n                    QRTE.setTrialData(questionScope.QRTLibId + '[OffsetTime]', displayEl.displayOffsetTime);\n                    QRTE.setTrialData(questionScope.QRTLibId + '[CalculatedDuration]', displayEl.displayDuration);\n                };\n\n\n                this.QRTLib_timer = QRTE.displayElement(dispEle);\n\n                question.onShowFunc.apply(this);\n\n                stimulusShown = true;\n            }\n\n            //QRTE.setTrialData(question.questionElement.QRTLibId + '[LoadEndTime]', window.requestAnimationFrame.now());\n            return stimulusShown;\n        },\n\n        setId: function(question, desc) {\n\n            this.idCache[question.questionId] = desc;\n            question.qId = desc;\n\n            Qualtrics.SurveyEngine.setEmbeddedData(QRTE.idField, Object.toJSON(this.idCache));\n        },\n\n        getOutputKey: function(key) {\n            var oldKey;\n            for (oldKey in this.idCache) {\n                if (this.idCache.hasOwnProperty(oldKey) && oldKey === key.substring(0, oldKey.length)) {\n\n                    return QRTE.getBlockData('QRTLib_currentBlock') + this.idCache[oldKey] + key.substring(oldKey.length, key.length);\n                }\n            }\n            return key;\n        },\n\n\n        OnKeyPress: function(fn, qScope) {\n\n            qScope = qScope || window;\n\n            var keyFn = function(e) {\n                QRTE.setTrialData(qScope.QRTLibId + '[RTTime]', window.requestAnimationFrame.now());\n                var RT = QRTE.getTrialData(qScope.QRTLibId + '[RTTime]') - QRTE.getTrialData(qScope.QRTLibId + '[OnsetTime]');\n                QRTE.setTrialData(qScope.QRTLibId + '[RT]', RT);\n                QRTE.setTrialData(qScope.QRTLibId + '[RESP]', QRTE.keycode2string(e));\n                QRTE.log(qScope);\n                fn.apply(qScope, [e]);\n            }\n\n            QRTE.addKeyListener(keyFn, qScope);\n        },\n\n        addKeyListener: function(fn, listenerScope) {\n            Event.observe(document, 'keypress', function(e) {\n                if (listenerScope.QRTLib_isActive === true) {\n                    fn.apply(listenerScope, [e]);\n                }\n            });\n        },\n\n        /*  \n         **************Methods below this line are support methods*******************\n         */\n\n        hideQuestions: function() {\n            qArray = $('Questions').getElementsByClassName('QuestionOuter');\n            for (var i = 0; i < qArray.length; i += 1) {\n                qArray[i].style.display = 'none';\n            }\n        },\n\n        unhideQuestions: function() {\n            //Redisplay outer questions\n            qArray = $('Questions').getElementsByClassName('QuestionOuter');\n            for (var i = 0; i < qArray.length; i += 1) {\n                qArray[i].style.display = 'block';\n            }\n            //Redisplay separators\n            qArray = $('Questions').getElementsByClassName('Separator');\n            for (var i = 0; i < qArray.length; i += 1) {\n                qArray[i].style.display = 'block';\n            }\n\n\n        },\n\n        _handleKeyPressEvent: function() {\n\n        },\n\n        _setConfig: function(QID, option, value, setterFunc) {\n            var qidString = QID;\n            if (typeof QID !== 'string') {\n                qidString = QID.questionId;\n            }\n            option = option.toLowerCase();\n\n            switch (option) {\n                case 'duration':\n                    if (value instanceof Array) {\n                        value = value[Math.floor(Math.random() * value.length)];\n                    }\n                    setterFunc.apply(this, [qidString, 'Duration', value]);\n                    break;\n                case 'allowable':\n                    setterFunc.apply(this, [qidString, 'Allowable', value]);\n                    break;\n                case 'cresp':\n                    setterFunc.apply(this, [qidString, 'CRESP', value]);\n                    break;\n                case 'delay':\n                    setterFunc.apply(this, [qidString, 'Offset', value]);\n                    break;\n                case 'endaction':\n                    setterFunc.apply(this, [qidString, 'EndAction', value]);\n                    break;\n                default:\n                    QRTE.log('No such configuration: ' + option);\n                    break;\n            }\n        },\n        getDuration: function(question) {\n            var duration = Infinity,\n                edDuration = this.getTrialData(question.QRTLib_configId + '[Duration]');\n            if (edDuration !== undefined && edDuration !== '' && !isNaN(edDuration)) {\n                duration = edDuration;\n            }\n            if (question._Duration !== undefined && question._Duration !== '' && !isNaN(question._Duration)) {\n                duration = question._Duration;\n            }\n\n            return duration;\n        },\n        getAllowable: function(question) {\n            var allowable = \"\",\n                edAllowable = this.getTrialData(question.QRTLib_configId + '[Allowable]');\n            if (edAllowable !== undefined) {\n                allowable = edAllowable;\n            }\n            if (question._Allowable !== undefined) {\n                allowable = question._Allowable;\n            }\n\n            if (allowable === '{ANY}') {\n                allowable = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890-=[]\\\\;',./`\";\n            }\n            //allowable = allowable.toUpperCase();\n            return allowable;\n        },\n        getCResp: function(question) {\n            var cresp = '',\n                edcresp = this.getTrialData(question.QRTLib_configId + '[CRESP]');\n            if (edcresp !== undefined) {\n                cresp = edcresp;\n            }\n            if (question._cresp !== undefined) {\n                cresp = question._CRESP;\n            }\n\n            if (cresp === '{ANY}') {\n                cresp = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890-=[]\\\\;',./`\";\n            }\n            //cresp = cresp.toUpperCase();\n\n            return cresp;\n        },\n\n        getOffset: function(question) {\n            var offset = 0,\n                edOffset = this.getTrialData(question.QRTLib_configId + '[Offset]');\n            if (edOffset !== undefined && edOffset !== '' && !isNaN(edOffset)) {\n                offset = edOffset;\n            }\n            if (question._Offset !== undefined && question._Offset !== '' && !isNaN(question._Offset)) {\n                offset = question._Offset;\n            }\n\n            return offset;\n\n        },\n\n        getEndAction: function(question) {\n            var endAction = 'NONE',\n                edEndAction = this.getTrialData(question.QRTLib_configId + '[EndAction]');\n            if (edEndAction !== undefined && edEndAction !== '') {\n                endAction = edEndAction;\n            }\n            if (question._EndAction !== undefined && question._EndAction !== '') {\n                endAction = question._EndAction;\n            }\n\n            return endAction;\n\n        },\n        evaluateConditional: function(conditional) {\n            QRTE.log('Conditional: ', conditional);\n            return conditional === '' || conditional();\n        },\n        log: function() {\n            if (QRTE.debug === true) {\n                for (var i = 0; i < arguments.length; i += 1) {\n                    console.log(arguments[i]);\n                }\n            }\n        },\n\n        median: function(values) {\n\n            values.sort(function(a, b) {\n                return a - b;\n            });\n\n            var half = Math.floor(values.length / 2);\n\n            if (values.length % 2) return values[half];\n            else return (values[half - 1] + values[half]) / 2.0;\n        },\n\n        waitForKey: function(question, keys) {\n            Event.observe(document, 'keypress', function(e) {\n                var resp = QRTE.keycode2string(e);\n                if (keys.indexOf(resp) >= 0) {\n                    question.clickNextButton();\n                }\n            });\n        },\n\n        validateParams: function(paramObj, validationArray) {\n            var valObj, val, index, typeCheck = true,\n                indexType;\n            //Loop over validationArray to check whether parameters suffice\n            for (index = 0; index < validationArray.length; index += 1) {\n                valObj = validationArray[index];\n                if (paramObj[valObj.name] === undefined && valObj.required === true) {\n                    alert('Required parameter: ' + valObj.name + ' seems to be missing');\n                    QRTE.log('Required parameter: ' + valObj.name + ' seems to be missing');\n                    break;\n                }\n\n                val = paramObj[valObj.name];\n\n                //Loop over type checkers\n                for (indexType = 0; indexType < valObj.type.length; indexType += 1) {\n                    typeCheck = QRTE.validateType(val, valObj.type[indexType]);\n                    if (typeCheck === true) {\n                        break;\n                    }\n                }\n                if (typeCheck === false && valObj.required === true) {\n                    alert('Parameter: ' + valObj.name + ' is of the wrong type, expected type: ' + valObj.type + ', type received: ' + (typeof val) + \"\\n\" + \"Please open the console for detailed error messages\");\n                    QRTE.log('Parameter: ' + valObj.name + ' is of the wrong type, expected type: ' + valObj.type + ', type received: ' + (typeof val));\n                    QRTE.log('Faulty parameter ' + valObj.name + ': ', val);\n                    QRTE.log('Proper functioning of QRTE is no longer guaranteed, please fix the above error');\n                }\n\n            }\n        },\n\n        validateType: function(val, type) {\n            switch (type) {\n                case 'JSON':\n                    return val.isJSON();\n                case 'String':\n                    return (typeof val === 'string' || val instanceof String);\n                case 'Number':\n                    return (!isNaN(parseFloat(val)) && isFinite(val));\n                case 'Array':\n                    return val instanceof Array;\n                case 'Object':\n                    return typeof val === 'object';\n                case 'Function':\n                    return typeof val === 'function';\n                case 'Boolean':\n                    return (val === true || val === false);\n                case 'Empty':\n                    return val === '';\n                default:\n                    return false;\n            }\n        },\n\n        fixSetEmbeddedDataBug: function() {\n            Qualtrics.SurveyEngine.setEmbeddedData = function(key, value) {\n                var fieldName = 'ED~' + key;\n                if ($(fieldName)) {\n                    $(fieldName).value = value;\n                } else {\n                    $('Header').appendChild(QBuilder('input', {\n                        type: 'hidden',\n                        id: fieldName,\n                        name: fieldName,\n                        value: value\n                    }));\n                    Qualtrics.SurveyEngine.setEmbeddedData(key, value);\n                }\n            }\n        },\n\n        //DisplayEngine part\n\n        //Since it's impossible to know when a screen refresh has happened, we assume that the first timestamp is the actual screen refresh.\n        //Based on the difference between the current timestamp Tn and the root timestamp Tn-1, we estimate the amount of frames that have passed since. \n        //Based on the amount of frames we estimate the previous screen refresh. Although not perfect, it's the best we can do.\n\n        refreshRate: 60, //hertz\n        refreshPeriod: 1000 / 60,\n        lastRefresh: 0,\n        currentRefresh: 0,\n        previousTimestamp: 0,\n        referenceTime: 0,\n        framesSinceReference: 0,\n        currentStack: [],\n        proceedOnFrameEnd: false,\n\n        init: function() {\n            window.requestAnimationFrame(QRTE.draw);\n        },\n\n        draw: function(timestamp) {\n            var curEle, newStack = [];\n            timestamp = window.requestAnimationFrame.now();\n\n\n            if (timestamp < 1e12) {\n                timestamp += window.performance.timing.navigationStart;\n            }\n\n            if (QRTE.referenceTime === 0) {\n                QRTE.referenceTime = timestamp;\n                QRTE.previousTimestamp = timestamp;\n                QRTE.framesSinceReference = 0;\n            } else {\n                //QRTE.framesSinceReference += QRTE.calcFrames(QRTE.referenceTime, timestamp);\n                QRTE.prevFrames = QRTE.framesSinceReference;\n                //frameDiff =  QRTE.calcFrames(QRTE.referenceTime, timestamp) - QRTE.prevFrames;\n                QRTE.framesSinceReference = QRTE.calcFrames(QRTE.referenceTime, timestamp);\n            }\n            QRTE.currentRefresh = (QRTE.framesSinceReference * QRTE.refreshPeriod) + QRTE.referenceTime;\n            QRTE.projectedRefresh = QRTE.currentRefresh + QRTE.refreshPeriod;\n            curEle = QRTE.currentStack.shift();\n\n            while (curEle) {\n                curEle.keep = true;\n\n                //Call duringDisplay callback function, with the current element and the timestamp as arguments.\n                if (curEle.shown === true && typeof curEle.duringDisplayFn === 'function') {\n                    curEle.duringDisplayFn(curEle, timestamp);\n                }\n\n                if (QRTE.proceedOnFrameEnd === true || curEle.hide === true || (curEle.shown === true && curEle.displayOnset !== undefined && (curEle.displayOnset + curEle.duration < QRTE.projectedRefresh))) {\n                    //If the next refresh makes it go beyond the duration, hide the element again!\n                    curEle = QRTE.hideSingleEle(curEle, timestamp);\n                } else if (curEle.shown === false && curEle.requestedAt + curEle.delay < QRTE.projectedRefresh) {\n                    curEle = QRTE.dispSingleEle(curEle, timestamp);\n                }\n\n                if (curEle.keep === false && curEle.proceedOnHide === true) {\n                    //Behold! We have found an element that commands us to proceed to the next page.\n                    QRTE.proceedOnFrameEnd = true;\n                    //Every element that has been processed so far needs to be re-processed (sadly), so that they properly hide.\n                    for (var ind = 0; ind < newStack.length; ind += 1) {\n                        if (newStack[ind].hide !== true) {\n                            newStack[ind].hide = true;\n                            QRTE.currentStack.push(newStack[ind]);\n                        }\n                    }\n                } else {\n                    //Push it to the newStack, for it to be processed next time.\n                    newStack.push(curEle);\n                }\n\n                curEle = QRTE.currentStack.shift();\n            }\n            QRTE.currentStack = newStack;\n            QRTE.lastRefresh = QRTE.currentRefresh;\n            QRTE.previousTimestamp = timestamp;\n            window.requestAnimationFrame(QRTE.draw);\n            if ((newStack.length === 0 || QRTE.proceedOnFrameEnd) && QRTE.inited === true) {\n                QRTE.proceedOnFrameEnd = false;\n                QRTE.proceedPage();\n            }\n\n\n        },\n\n        calcFrames: function(previous, current) {\n            var diff = current - previous,\n                frames = 0;\n\n            if (diff < QRTE.refreshPeriod) {\n                frames = 1;\n            } else {\n                frames = Math.floor(diff / QRTE.refreshPeriod);\n                if (diff % QRTE.refreshPeriod >= (QRTE.refreshPeriod * 0.9)) {\n                    frames += 1;\n                }\n            }\n\n            return frames;\n        },\n\n        /**\n         * Display an element for a specified duration with a specified delay. Vsyncs the display duration using requestAnimationFrame (if possible in the browser)\n         * and allows for high-precision control over its duration. Please start any custom attributes for the paramObj with the 'custom_' header, to avoid collisions.\n         * @private\n         * @method displayElement\n         * @param paramObj {Object}\n         *  @param el {Object} HTML element to be displayed\n         *  @param [onHideFn] {Function} Function to be called upon removing the element from display, is passed one argument containing all information about the display element.\n         *  @param [duration] {Number} Number of milliseconds (ms) the element should be displayed.\n         *  @param [delay] {Number} Number of milliseconds (ms) the Engine should wait before displaying the element.\n         *  @param [duringDisplayFn] {Function} Function to be called upon displaying the element for another screen refresh. Careful: Keep this function simple, could seriously hamper performance as it's called about every 16-17 ms.  is passed one argument containing all information about the display element.\n         *  @param [onDisplayfn] {Function} Function to be called upon starting to display the element. Is passed one argument containing all information about the display element.\n         */\n\n        //displayElement: function(el, callback, duration, offset, duringDisplaycb) {\n        displayElement: function(paramObj) {\n            var reqAt,\n                id = String(Math.random());\n            //QRTE.log(arguments);\n            if (paramObj.delay === undefined) {\n                paramObj.delay = 0;\n            }\n\n\n\n            if (paramObj.duration === undefined) {\n                paramObj = Infinity;\n            }\n\n            if (isNaN(QRTE.lastRefresh)) {\n                reqAt = window.requestAnimationFrame.now();\n            } else {\n                reqAt = QRTE.lastRefresh;\n            }\n            paramObj.userId = paramObj.id;\n            paramObj.id = id;\n            paramObj.shown = false;\n            paramObj.requestedAt = reqAt;\n            paramObj.hide = false;\n\n            QRTE.currentStack.push(paramObj);\n            if (paramObj.delay === 0) {\n                //This element needs to be displayed as soon as possible\n                QRTE.dispSingleEle(paramObj, QRTE.previousTimestamp);\n            }\n            QRTE.log('Added element to display stack:', paramObj);\n            //console.log('paramObj: ', paramObj.userId, ', duration: ', paramObj.duration);\n\n            return id;\n        },\n\n        hideElement: function(id) {\n            var found = false,\n                i;\n            for (i = 0; i < QRTE.currentStack.length; i += 1) {\n                if (QRTE.currentStack[i].id === id) {\n                    found = true;\n                    QRTE.currentStack[i].hide = true;\n                    this.log('Element to be hidden: ', QRTE.currentStack[i]);\n                }\n            }\n            return found;\n        },\n\n        hideAllElements: function() {\n            for (i = 0; i < QRTE.currentStack.length; i += 1) {\n                QRTE.currentStack[i].hide = true;\n            }\n            QRTE.proceedOnFrameEnd = true;\n        },\n\n        /**\n         * Hide a DrawEngine Element\n         * @private\n         * @method hideSingleEle\n         * @param curEle {Object}\n         */\n        hideSingleEle: function(curEle, timestamp) {\n            curEle.displayOffset = QRTE.projectedRefresh;\n            curEle.displayOffsetTime = window.requestAnimationFrame.now();\n            curEle.el.style.display = 'none';\n            curEle.keep = false;\n            curEle.hide = true;\n            //delete QRTE.currentStack[key];\n            curEle.displayDuration = curEle.displayOffsetTime - curEle.displayOnsetTime;\n            if (curEle.onHideFn !== undefined) {\n                curEle.onHideFn(curEle, timestamp);\n            }\n\n            return curEle;\n\n        },\n\n\n        /**\n         * Display a DrawEngine Element\n         * @private\n         * @method dispSingleEle\n         * @param curEle {Object}\n         */\n        dispSingleEle: function(curEle, timestamp) {\n            curEle.el.style.display = 'block';\n            curEle.displayOnset = QRTE.projectedRefresh;\n            curEle.displayOnsetTime = window.requestAnimationFrame.now();\n            curEle.shown = true;\n            if (curEle.onDisplayFn !== undefined) {\n                //Added try-catch block to catch the error that's causing the OnsetTime not to get saved.\n                try {\n                    curEle.onDisplayFn(curEle, timestamp);\n                } catch (e) {\n                    QRTE.setTrialData('Error[OnsetError]', JSON.stringify(e));\n                }\n            }\n            return curEle;\n        },\n\n        checkEngineCompatibility: function() {\n            return window.requestAnimationFrame.method === 'native-highres';\n        },\n    };\n\n    if (typeof QRTEController == 'undefined') {\n        //QRTE SurveySlider controller layer\n        //Takes care of progressing through the survey. Catches all qualtrics native ways of submitting the form and replaces that by\n        //its own asynchronous ajax stuff.\n        QRTEController = {\n\n\n            //This plug-in to QRTEngine has been developed under the name SurveySlider\n            // for general Qualtrics Surveys. It has been adapted to work with QRTEngine\n            nextTrialContainer: null,\n            nextTrialText: '',\n            currentForm: null,\n            previousForm: null,\n            handlingSubmit: false,\n            onSubmitStack: [],\n            inited: false,\n            childInputs: [],\n            loadUponCallback: false,\n            setEmbeddedData: function() {},\n            tempED: {},\n\n\n\n            //Initialize thecontroller\n            init: function() {\n                this.nextTrialContainer = new Element('div', {\n                    id: 'nextTrialContainer'\n                });\n                this.currentForm = $$('form')[0];\n\n                //Catch submits and change it with our own submit function (which does AJAX submissions)\n                //this.currentForm.observe('QRTE:submit', QRTE.handleSubmit);\n                this.currentElements = $$('.QuestionOuter');\n\n                //Initial SSload firing\n                Qualtrics.SurveyEngine.addOnload(function() {\n                    QRTEController.currentForm.fire('QRTE:load');\n                });\n                //Change SurveyEngine.OnLoad to trigger on SSload, rather than page load\n                Qualtrics.SurveyEngine.addOnload = function(f) {\n                        var questions = $$('.QuestionOuter'),\n                            currentCount = QRTEController.count(Qualtrics.SurveyEngine.QuestionInfo),\n                            id = questions[currentCount - 1].id;\n                        if ($('body') && $('body').hasClassName('EditSection')) return;\n                        try {\n                            var obj = new Qualtrics.SurveyEngine.QuestionData(id);\n                            obj.onload = f;\n\n                            QRTEController.currentForm.observe('QRTE:load', obj.onload.bind(obj));\n                            //Event.observe(this.currentForm, 'SSload', obj.onload.bind(obj));\n                        } catch (e) {\n                            console.error('SE API Error: ' + e);\n                        }\n                    }\n                    //Set the Qualtrics setEmbeddedData to inside the QRTEController\n                QRTEController.setEmbeddedData = Qualtrics.SurveyEngine.setEmbeddedData;\n                Qualtrics.SurveyEngine.setEmbeddedData = function(key, value) {\n                    QRTEController.tempED[key] = value;\n                }\n                this.submitPage = this.requestNextTrial;\n                this.inited = true;\n            },\n\n            /**\n             * Requests the next trial from the Qualtrics server.\n             *\n             *\n             */\n            requestNextTrial: function(isLastTrial) {\n\n                //If this is the last trial of a block, DON'T request the next page, let qualtrics handle it themselves\n                if (this.handlingSubmit === false && isLastTrial === false) {\n                    //Load next trial means that current page is a trial and has been inited\n                    //Need to remove relevant input elements from current form before submitting\n                    //After that add them back\n                    this.handlingSubmit = true\n                    var childs = $$('form input[type=text]'),\n                        childInputs = [];\n                    //remove current input elements from the form\n                    for (var i = 0; i < childs.length; i += 1) {\n                        childInputs[i] = {\n                            ele: childs[i],\n                            parent: childs[i].up()\n                        };\n                        childs[i].remove();\n                    }\n                    //add previous input elements to form\n                    //Text inputs\n                    for (var i = 0; i < this.childInputs.length; i += 1) {\n                        this.childInputs[i].ele.style.display = 'none';\n                        this.currentForm.insert(this.childInputs[i].ele);\n                    }\n\n\n                    //And embedded data\n                    for (var key in this.tempED) {\n                        if (this.tempED.hasOwnProperty(key)) {\n                            QRTEController.setEmbeddedData(key, this.tempED[key]);\n                        }\n                    }\n                    //Reset stored embedded data\n                    this.tempED = {};\n                    //set new childs\n                    this.childInputs = childInputs;\n\n                    //Loop over submit stack, or callbacks that need to be finished before submitting\n                    for (var i = 0; i < QRTEController.onSubmitStack.length; i += 1) {\n                        QRTE.onSubmitStack[i]();\n                    }\n                    QRTEController.onSubmitStack = [];\n                    debugger;\n                    this.currentForm.request({\n                        onComplete: this.requestNextTrialCallback\n                    });\n\n                    //Set server comm onset for the next trial\n                    QRTE.setBlockData('ServerCommOnset', window.requestAnimationFrame.now());\n\n                    QRTEController.betweenSubmits = true;\n\n                    for (var i = 0; i < this.childInputs.length; i += 1) {\n                        this.childInputs[i].parent.insert(this.childInputs[i].ele);\n                        this.childInputs[i].ele.style.display = 'none';\n                    }\n                } else if (isLastTrial === true) {\n                    //Just add the previous trial's childInputs to the form \n                    for (var i = 0; i < this.childInputs.length; i += 1) {\n\n                        this.currentForm.insert(this.childInputs[i].ele);\n                        this.childInputs[i].ele.style.display = 'none';\n                    }\n\n                    this.loadNextTrial = function() {\n                        //Directly submitting the form doesn't seem to work? Let's do it through NextButton click\n                        $('NextButton').click();\n                    };\n                }\n            },\n\n            loadNextTrial: function() {\n                if (this.handlingSubmit === true) {\n                    //The submit still hasn't returned..\n                    this.loadUponCallback = true;\n                    return;\n\n                }\n                //Set handling submit to false (as page has been returned)\n                //Save the previous form\n                this.previousForm = this.currentForm;\n                //Reset the QuestionInfo object, this is for Qualtrics to correctly initiate its own page\n                Qualtrics.SurveyEngine.QuestionInfo = {}\n                    //Parse the HTML that was returned earlier and set it as the current trial container's contents\n                this.nextTrialContainer = jQuery(this.nextTrialContainer).html(this.nextTrialText)[0];\n                //Filter out the 'form' field, and append it back.\n                this.currentForm = jQuery(this.nextTrialContainer).find('form')[0];\n                jQuery(this.previousForm).replaceWith(jQuery(this.currentForm));\n\n                jQuery(this.currentForm).show();\n\n                if (this.currentForm.select('.END_OF_SURVEY').length === 0) {\n                    this.currentForm.fire('QRTE:load');\n                    this.submitPage = this.requestNextTrial;\n                } else {\n                    this.submitPage = this.currentForm.submit;\n                }\n\n            },\n\n            requestNextTrialCallback: function(e) {\n                QRTEController.nextTrialText = e.responseText;\n                QRTEController.handlingSubmit = false;\n                QRTE.setBlockData('ServerCommOffset', window.requestAnimationFrame.now());\n\n                if (QRTEController.loadUponCallback === true) {\n                    QRTEController.loadUponCallback = false;\n                    QRTEController.loadNextTrial();\n                }\n            },\n\n            submitPage: function() {\n                console.log('Not yet initialised');\n            },\n\n            count: function(obj) {\n                var count = 0;\n\n                for (var prop in obj) {\n                    if (obj.hasOwnProperty(prop))\n                        ++count;\n                }\n\n                return count;\n            },\n\n            BDCache: {},\n            storeBlockData: function(blockData) {\n                this.BDCache = blockData;\n            },\n\n            loadBlockData: function() {\n                return this.BDCache;\n            }\n        };\n\n        document.observe('dom:loaded', QRTEController.init.bind(QRTEController));\n\n\n        (function() {\n            var lastFrame, method, now, queue, requestAnimationFrame, timer, vendor, _i, _len, _ref, _ref1;\n            method = 'native';\n            now = Date.now || function() {\n                return new Date().getTime();\n            };\n            requestAnimationFrame = window.requestAnimationFrame;\n            _ref = ['webkit', 'moz', 'o', 'ms'];\n            for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n                vendor = _ref[_i];\n                if (!(requestAnimationFrame != null)) {\n                    requestAnimationFrame = window[vendor + \"RequestAnimationFrame\"];\n                }\n            }\n            if (!(requestAnimationFrame != null)) {\n                method = 'timer';\n                lastFrame = 0;\n                queue = timer = null;\n                requestAnimationFrame = function(callback) {\n                    var fire, nextFrame, time;\n                    if (queue != null) {\n                        queue.push(callback);\n                        return;\n                    }\n                    time = now();\n                    nextFrame = Math.max(0, 16.66 - (time - lastFrame));\n                    queue = [callback];\n                    lastFrame = time + nextFrame;\n                    fire = function() {\n                        var cb, q, _j, _len1;\n                        q = queue;\n                        queue = null;\n                        for (_j = 0, _len1 = q.length; _j < _len1; _j++) {\n                            cb = q[_j];\n                            cb(lastFrame);\n                        }\n                    };\n                    timer = setTimeout(fire, nextFrame);\n                };\n            }\n            requestAnimationFrame(function(time) {\n                var _ref1;\n                if ((((_ref1 = window.performance) != null ? _ref1.now : void 0) != null) && time < 1e12) {\n                    requestAnimationFrame.now = function() {\n                        return window.performance.now() + window.performance.timing.navigationStart;\n                    };\n                    requestAnimationFrame.method = 'native-highres';\n                } else {\n                    requestAnimationFrame.now = now;\n                }\n            });\n            requestAnimationFrame.now = ((_ref1 = window.performance) != null ? _ref1.now : void 0) != null ? (function() {\n                return window.performance.now() + window.performance.timing.navigationStart;\n            }) : now;\n            requestAnimationFrame.method = method;\n            window.requestAnimationFrame = requestAnimationFrame;\n        })();\n\n        function loadScript(url, callback) {\n\n            var script = document.createElement(\"script\")\n            script.type = \"text/javascript\";\n\n            if (script.readyState) { //IE\n                script.onreadystatechange = function() {\n                    if (script.readyState == \"loaded\" || script.readyState == \"complete\") {\n                        script.onreadystatechange = null;\n                        callback();\n                    }\n\n                };\n            } else { //Others\n                script.onload = function() {\n                    callback();\n                };\n            }\n\n            script.src = url;\n            document.getElementsByTagName(\"head\")[0].appendChild(script);\n        }\n\n        (function() {\n\n            //jQuery is only required for the Fixation flash fix. prototypejs is unable to efficiently replace elements\n            //and introduces a 10 ms delay between loading element and firing off the scripts. Unacceptable\n            //First time jQuery should be used is the second trial\n\n            loadScript(\"https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js\", function() {\n\n                $.noConflict();\n\n            });\n\n        })();\n\n        //If preview mode is run (PreviewBanner element exists, add a QRTEngine plug with id QRTEPlug)\n\n        if ($('PreviewBanner')) {\n            var plug, row, banner = $('PreviewBanner');\n            //Go down to the first table row inside that banner\n            row = banner.children[0].children[0].children[0];\n            //Insert new cell    \n            plug = row.insertCell(2);\n            plug.id = \"QRTEPlug\";\n            plug.width = \"20%\";\n            plug.innerHTML = 'This survey is proudly and successfully powered by <a href=\"http://qrtengine.com\" target=\"_blank\"><i><b>QRTEngine</b></i></a>';\n            plug.style.textAlign = \"center\";\n        }\n    }"],"pos":-1},"hash":"bc37e9908b413249fe666f189265c03143e4d841"}